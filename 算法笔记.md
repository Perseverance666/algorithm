# 算法笔记

## 一、基础+进阶

### 1、class01

#### 1）选择排序，复杂度O(N^2)

1.先从a[0] - a[N-1] 个数中找到最小的数把它放在a[0]的位置

2.在从a[1] - a[N-1]个数中找到最小的数把它放在a[1]的位置上，以此类推

3.一次循环找到一个最小值，放在开头，然后每次循环找一个最小值往之前找到的最小值后面放

```java
    public static void SelectionSort(int[] arr) {
        //1、临界条件判断
        if (arr == null || arr.length <= 1) {
            return;
        }
        //2、进行从小到大选择排序
        for (int i = 0; i < arr.length; i++) {
            //先找一个当做最小值
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++){
                if(arr[j] < arr[minIndex]){
                    minIndex = j;
                }
            }
            swap(arr,i,minIndex);
        }
    }
```

#### 2）冒泡排序，复杂度O(N^2)

1.先从a[0] - a[N-1]个数中，从头开始两两比较，将较大的数放到后面，这样最后一个数就是最大的

2.再从a[0] - a[N-2]个数中，像上面步骤一样两两比较，这样倒数第二个数就是第二大的，以此类推

3.一次循环两两比较，最终将找到一个最大值放在最后，然后每次循环再找剩下数中的最大值

```java
    public static void BubbleSort(int[] arr) {
        //1、临界条件判断
        if (arr == null || arr.length <= 1) {
            return;
        }
        //2、进行从小到大冒泡排序  0 ~ N-1    0 ~ N-2  ...
        for (int i = arr.length-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[j + 1] < arr[j]) {
                    swap(arr, j + 1, j);
                }
            }
        }

    }
```

#### 3）插入排序，复杂度O(N^2)

1.先确保0 - 1 位置上的数有序，若a[1] 小于a[0]，交换，反之不变

2.在确保0 - 2 位置上的数有序，若a[2] 小于a[1]，交换，直到比前面的数大，或者前面没数了，以此类推

3.这样确保第i个数前面的数都是有序的，然后将该数插入到合适位置

```java
    public static void insertionSort(int[] arr) {
        //1、临界条件判断
        if (arr == null || arr.length <= 1) {
            return;
        }
        //2、进行从小到大插入排序 0~1   0~2 ... 最后0~N-1 上都是有序的
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                if(arr[j - 1] > arr[j]){
                    swap(arr, j-1, j);
                }
            }
        }
    }
```

#### 4）二分法

##### 1、题目一

题目在一个有序数组中，找某个数是否存在

1.先找中间的数，若当前数 = 指定数，找到了

2.若当前数 < 指定数，说明所求可能在右边，将L移到mid右边

3.若当前数 > 指定数，说明所求可能在左边，将R移到mid左边

4.当L> R时，就全找完了，没有找到，返回false

```java
    public static boolean exist(int[] sortedArr, int num) {
        if (sortedArr == null || sortedArr.length == 0) {
            return false;
        }
        int L = 0;
        int R = sortedArr.length - 1;
        int mid = 0;
        while (L <= R){
            mid = L + ((R - L) >> 1); //等同于 mid = (L + R) / 2;
            if(sortedArr[mid] == num){
                return true;
            } else if(sortedArr[mid] < num){
                L = mid + 1;
            } else {
                R = mid - 1 ;
            }
        }
        //全都比较完了，没有找到
        return false;
    }
```

##### 2、题目二

题目：在一个有序数组中，找到 >= 某个数最左侧的位置 (<= 最右侧位置 问题类似)

1.先找中间的数，若当前数 >= 指定数，说明左面有可能还有符合要求的数，记录当前位置，并将R移到mid左边

2.若当前数 < 指定数，说明左边肯定没有了，不记录当前位置，并将L移到mid右边，继续向右找

3.当L> R时，就找完了，index存的就是所求

```java
    public static int nearestIndex(int[] arr, int value) {
        int L = 0;
        int R = arr.length - 1;
        int mid = 0;
        int index = -1;
        while(L <= R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] >= value){
                //若当前数 >= 指定数，记录当前位置，并将R移到mid左边
                index = mid;
                R = mid - 1;
            }else{
                //若当前数 < 指定数，不记录当前位置，并将L移到mid右边
                L = mid + 1;

            }
        }
        return index;
    }
```

##### 3、题目三

题目：局部最小值问题，找一个局部最小即可

1.先判断第0个数，或者第N-1个数是否是局部最小

2.以上两个数不满足，开始二分，若mid大于左边的数，不管是否大于还是小于右边的数，mid左边一定存在局部最小

3.若mid大于右边的数，不管是否大于还是小于左边的数，mid右边一定存在局部最小

4.当L=R时，这个数一定是局部最小

```java
    public static int getLessIndex(int[] arr) {
        if(arr == null || arr.length <= 0){
            return -1; //不存在
        }
        if(arr.length == 1 || arr[0] < arr[1]){
            return 0; //0位置就是局部最小
        }
        if(arr[arr.length - 1] < arr[arr.length - 2]){
            return arr.length - 1;  //arr.length -1 位置就是局部最小
        }
        int L = 1;
        int R = arr.length - 2;
        int mid = 0;
        while(L < R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] < arr[mid -1] && arr[mid] < arr[mid + 1]){
                return mid;
            }else if(arr[mid] > arr[mid -1]){
                //说明局部最小在左边
                R = mid - 1;
            }else{
                //说明局部最小在右边
                L = mid + 1;
            }
        }
        //此时L = R,这个数一定是局部最小
        return L;
    }
```

### 2、class02

#### 1）异或运算

技巧：如何不用额外变量交换两个数

```java
    public static void swap (int[] arr, int i, int j) {
        arr[i]  = arr[i] ^ arr[j];
        arr[j]  = arr[i] ^ arr[j];
        arr[i]  = arr[i] ^ arr[j];
    }
```

##### 1、题目一

题目：一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

定义一个变量eor初值为0，将所有数进行异或运算，出现偶数次的其他数经过异或运算变成0，最终只剩出现奇数次的那个数，即为所求

```java
public static void printOddTimesNum1(int[] arr) {
    int eor = 0;
    for (int i = 0; i < arr.length; i++) {
        eor ^= arr[i];
    }
    System.out.println(eor);
}
```

##### 2、题目二

题目：一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

1.定义一个变量eor初值为0，将所有数进行异或运算，出现偶数次的其他数经过异或运算变成0，最后eor = a ^ b

2.我们知道a != b，故eor二进制状态下一定存在1，只有a与b的某一位不同，eor才等于1，我们取eor最右边的1这位进行研究，此时a和b的这一位一定是一个1一个0

3.将原来的所有数分成两组，一组是那一位是1的，另外一组是那一位是0的，这样就将a和b分成了两组，各自再带几个出现偶数次的数

4.然后再定义一个变量eor2，规定只对那一位是1的进行异或，这样经过异或运算最终假如就得到a了，然后b = eor ^ a =  a ^ b

```java
public static void printOddTimesNum2(int[] arr) {
    int eor = 0;
    for(int i = 0; i < arr.length; i++){
        eor ^= arr[i];
    }
    System.out.println(eor);  //eor = a ^ b;

    //取eor最右边的1最为条件，然后分成两组
    int rightOne = eor & (-eor);   //eor & (~eor + 1)    等同于  eor & (-eor) ，可以得到最右边的1，例如：0001000
    int eor2 = 0;
    for(int i = 0; i < arr.length; i++){
        //这次只异或那一位是1的
        if((arr[i] & rightOne) == rightOne){
            eor2 ^= arr[i];
        }

    }

    int a = eor2; //eor2的异或结果就是其中一个数
    int b = eor ^ a;   //b = eor ^ a = a ^ b ^ a;
    System.out.println(a + " " + b);

}
```

##### 3、题目三

题目：数组中所有的数都出现了M次，只有一种数出现了K次，1 <= K < M 返回这种数

1.先创建一个32位的数组，开始存的全是0

2.然后依次检查原数组中的每个数，每个数的哪一位上有1((arr[i] >> j) & 1) != 0)，就在32位数组上的对应位置加1，最后完成32位数组

3.检查32位数组，若某一位模M 等于 0，说明出现K次的那个数在这一位上是0，若模M不等于0，说明出现K次的那个数在这一位上是1，把这一位的1加到结果上去 ans = ans | (1 << i)。最终找到这个数

```java
  public static int km(int[] arr, int k, int m) {
        int[] t = new int[32];
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < 32; j++) {
                if(((arr[i] >> j) & 1) != 0){
                    //说明从右向左数，第j位是1，加到32位数组中
                    t[j]++;
                }

            }
        }

        int ans = 0;
        for(int i = 0; i < 32; i++){
            if(t[i] % m != 0){
                //说明出现k次的那个数，从右往左，二进制在第i位上是1
                ans = ans | (1 << i);
            }
        }

        return ans;
    }
```

### 3、class03

#### 1）链表反转

##### 1、单链表反转

要点：先记录下一节点，在翻转指针，最后移动两个指针准备翻转下一组

1.准备两个指针pre和next都先指向null，他俩用来记录位置，先让next记录当前节点的下一结点

2.然后反转指针

3.然后pre指向Head记录当前节点位置，即下一个节点的上一个节点

4.最后更新Head，此时第一个节点完成，依次完成之后的节点

```java
    public static Node reverseLinkedList(Node head) {
        Node pre = null;
        Node next = null;
        while(head != null){
            //1、记录下一个节点
            next = head.next;
            //2、翻转指针
            head.next = pre;
            //3、两个指针移动，准备翻转下一组
            pre = head;
            head = next;
        }
        return pre;
    }
```

##### 2、双链表反转

双链表和单链表过程一样，只是反转链表时，要反转next和last两个

```java
    public static DoubleNode reverseDoubleList(DoubleNode head) {
        DoubleNode pre = null;
        DoubleNode next = null;
        while(head != null){
            //1、记录下一个节点
            next = head.next;
            //2、翻转指针
            head.next = pre;
            head.last = next;
            //3、两个指针移动，准备翻转下一个
            pre = head;
            head = next;
        }
        return pre;
    }
```

#### 2）移除链表元素

1.首先让head指向第一个不需要删除的节点，用来返回

2.然后创建两个指针pre，cur先指向head（cur用来指向当前节点，pre用来指向下一个节点）

3.判断该节点值是否与指定值相等。若相等，让pre跳过这个节点，pre不动，pre.next指向下一个节点，然后cur后移。确保cur指向下一个节点，pre指向当前节点

4.若不等，pre指向cur指向的节点（因为cur和pre有可能指向同一个位置，也有可能一前一后)，目的是让pre指向cur指向的位置，然后cur后移。确保cur指向下一个节点，pre指向当前节点



```java
    public static Node removeValue(Node head, int num) {
        //1、首先让head指向第一个不需要删除的节点
        while(head != null){
            if(head.value != num){
                break;
            }
            head = head.next;
        }
        //2、然后进行删除
        Node pre = head;
        Node cur = head;
        while (cur != null){
            if(cur.value == num){
                pre.next = cur.next;
            }else{
                pre = cur;
            }
            cur = cur.next;
        }
        return head;
    }

```

#### 3）返回栈中最小元素

1.首先定义两个栈，一个存数据，另一个存最小值

2.若当前元素比当前最小值小，当前元素入两个栈

3.若当前元素大于当前最小值，当前元素入数据栈，另一个栈再存一次之前的最小值，保证两个栈有相同的层次

```java
 public static class MyStack2 {
        private Stack<Integer> stackData;
        private Stack<Integer> stackMin;

        public MyStack2() {
            this.stackData = new Stack<Integer>();
            this.stackMin = new Stack<Integer>();
        }

        public void push(int newNum) {
            if (this.stackMin.isEmpty()) {
                this.stackMin.push(newNum);
            } else if (newNum < this.getmin()) {
                this.stackMin.push(newNum);
            } else {
                int newMin = this.stackMin.peek();
                this.stackMin.push(newMin);
            }
            this.stackData.push(newNum);
        }

        public int pop() {
            if (this.stackData.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            this.stackMin.pop();
            return this.stackData.pop();
        }

        public int getmin() {
            if (this.stackMin.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            return this.stackMin.peek();
        }
    }
```

#### 4）用栈实现队列

1.准备两个栈，push栈用来加数据，pop栈用来弹出数据

2.首先将push栈中的所有数据全都弹出到pop栈中，这样pop栈弹出就实现队列了

3.若在pop栈弹出的过程中，push栈又加入了新的元素。必须等pop栈都弹出完了，才能将push栈的元素弹出到pop栈中

4.模拟添加，先加入push栈，等pop栈为空时，再全部添加到pop栈

5.模拟弹出，等pop栈为空时，再全部添加到pop栈，然后弹出pop栈，模拟完成

```java
    public static class TwoStacksQueue {
        public Stack<Integer> stackPush;
        public Stack<Integer> stackPop;

        public TwoStacksQueue() {
            stackPush = new Stack<Integer>();
            stackPop = new Stack<Integer>();
        }

        // push栈向pop栈倒入数据
        private void pushToPop() {
            //只有pop栈为空时，才将push栈的所有元素弹出到pop栈中
            if (stackPop.empty()) {
                while (!stackPush.empty()) {
                    //一次将push栈中的所有元素都弹出到pop栈中
                    stackPop.push(stackPush.pop());
                }
            }
        }

        public void add(int pushInt) {
            stackPush.push(pushInt);
            pushToPop();
        }

        public int poll() {
            if (stackPop.empty() && stackPush.empty()) {
                throw new RuntimeException("Queue is empty!");
            }
            pushToPop();
            return stackPop.pop();
        }

        public int peek() {
            if (stackPop.empty() && stackPush.empty()) {
                throw new RuntimeException("Queue is empty!");
            }
            pushToPop();
            return stackPop.peek();
        }
    }
```

#### 5）用队列实现栈

1.首先准备两个队列，一个queue最终用来弹出的，另一个help用来暂时存放其他元素的

2.模拟添加，直接往queue队列中加入元素即可

3.模拟弹出，先将queue队列的元素弹出到help队列中，让queue只剩一个元素，这样弹出queue中的元素就实现了栈。

4.queue队列弹出完这一个元素后，将help队列改成queue队列，将queue队列改成help队列

```java
    public static class TwoQueueStack<T> {
        public Queue<T> queue;
        public Queue<T> help;

        public TwoQueueStack() {
            queue = new LinkedList<>();
            help = new LinkedList<>();
        }

        public void push(T value) {
            queue.offer(value);
        }

        public T poll() {
            while (queue.size() > 1) {
                help.offer(queue.poll());
            }
            T ans = queue.poll();
            Queue<T> tmp = queue;
            queue = help;
            help = tmp;
            return ans;
        }

        public T peek() {
            while (queue.size() > 1) {
                help.offer(queue.poll());
            }
            T ans = queue.poll();
            help.offer(ans);
            Queue<T> tmp = queue;
            queue = help;
            help = tmp;
            return ans;
        }

        public boolean isEmpty() {
            return queue.isEmpty();
        }

    }
```

#### 6）Master公式

形如T(N)=a*T(N/b) + O(N^d) (其中的a、b、d都是常数)的递归函数并且子规模一致的条件下，可以直接通过Master公式来确定时间复杂度

1.如果log(b,a) < d，复杂度为O(N ^ d)

2.如果log(b,a) > d，复杂度为O(N ^ log(b,a))

3.如果log(b,a) = d，复杂度为O(N ^ d * log(2,N))

### 4、class04 -- 归并排序

#### 1）归并排序，复杂度O(N*logN)

##### 1、递归实现

1.定义一个函数process(int[] arr, int L, int R)，把L到R上变有序

2.然后分成两部分把L到M变有序，再把M+1到R变有序，然后再把它们两个merge

3.merge(int[] arr, int L, int M, int R)，准备一个数组help用来存最后排序好的数据。准备两个变量p1和p2首先分别指向L和M+1，然后经过挑选完成最终排序

```java
    // 递归方法实现
    public static void mergeSort1(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    // 把arr[L..R]排有序
    public static void process(int[] arr, int L, int R) {
        if (L == R) { // base case
            return;
        }
        int mid = L + ((R - L) >> 1);
        process(arr, L, mid);
        process(arr, mid + 1, R);
        merge(arr, L, mid, R);
    }

    //将L到M 和 M+1到R上的数据进行归并排序
    public static void merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = M + 1;
        while (p1 <= M && p2 <= R) {
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        // 要么p1越界了，要么p2越界了
        while (p1 <= M) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        //将help数组数据存回arr
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }

    }
```

##### 2、非递归实现

1.首先步长设置为1，然后进入循环判断此时步长是否超出数组长度，若超出了证明排序完成

2.先从左边第一个数，即L=0开始，然后再进入循环判断此时L是否超出数组长度，若超出证明越界了。循环结束后还要检测一下，看看此时步长是否 > 2分之数组长度，防止溢出（因为有可能由于精度问题导致越界，结果变成负数，这样就又进入第一个循环了，所以要检测一下）。若没有越界，则将步长乘2

3.在第二个循环中，若此时剩下的元素数量(N-L) <= 步长，就结束当前循环。否则确定M位置和R位置，其中要是确定的R位置已经越界了就改成N-1

4.然后合并merge(int[] arr, int L, int M, int R)，修改L的位置，L = R + 1

```java
    // 非递归方法实现
    public static void mergeSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int N = arr.length;
        // 步长
        int mergeSize = 1;
        while (mergeSize < N) { //步长小于数组长度才继续
            // 当前左组的，第一个位置
            int L = 0;
            while (L < N) {		//L越界就结束循环
                if (mergeSize >= N - L) {	//剩下的元素 <= 步长就结束循环
                    break;
                }
                int M = L + mergeSize - 1;
                int R = M + Math.min(mergeSize, N - 1 - M);
                merge(arr, L, M, R);
                L = R + 1;
            }
            // 防止溢出
            if (mergeSize > N / 2) {
                break;
            }
            mergeSize <<= 1;
        }
    }
```

#### 2）返回数组的最小和，归并排序

将数组中每个元素左边比它小的**值**全部累加起来。左值小于右值才返回

1.定义一个函数process(int[] arr, int L, int R)，把0到N-1上变有序，并返回最小和

2.先返回L到M上的最小和，再返回M+1到R上的最小和，最后merge两部分再求最小和，把这三部分最小和加起来

3.merge将元素放到help数组时，如果左侧指定值 < 右侧指定值，说明左值是 右值以及右边剩下数 的最小和中的一个值，左值在 右值以及右边剩下数 的所有最小和中，占据的总值为：左值 * （右侧剩下数的个数）。左侧指针移动，边计算最小和边merge

4.如果左值 > 右值，只将较小数放到help，右侧指针移动，最小和不加，继续比较接下来的

5.如果左值 = 右值，将右值放入help，右侧指针移动，最小和不加。(要确保左右值不等时，能知道右侧有多少个比左值大的，所以要右侧指针移动)

```java
 public static int smallSum(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    // arr[L..R]既要排好序，也要求小和返回
    // 所有merge时，产生的小和，累加
    public static int process(int[] arr, int l, int r) {
        if (l == r) {
            return 0;
        }
        // l < r
        int mid = l + ((r - l) >> 1);
        return process(arr, l, mid) + process(arr, mid + 1, r) + merge(arr, l, mid, r);
    }

    public static int merge(int[] arr, int L, int m, int r) {
        int[] help = new int[r - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = m + 1;
        int res = 0;
        while (p1 <= m && p2 <= r) {
            res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= m) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
        return res;
    }
```

#### 3）返回逆序对数量，归并排序

将数组中每个元素右边比它小的数的**个数**全部累加起来。左值大于右值才返回

1.定义一个函数process(int[] arr, int L, int R)，把0到N-1上变有序，并返回逆序对数量

2.先返回L到M上的逆序对数量，再返回M+1到R上的逆序对数量，最后merge两部分再求逆序对数量，把这三部分逆序对数量加起来

3.这次的merge指针从右往左，merge将元素放到help数组时，若左值 > 右值，说明左值和 右值及右值左边的所有数 都可构成逆序对，左指针向左移动检验下一个左值。边计算逆序对数量边merge

4.如果左值 < 右值，只将较小数放到help，右侧指针左移，逆序对数量不加，继续比较接下来的

5.如果左值 = 右值，将右值放入help，右侧指针左移，逆序对数量不加。(要确保左右值不等时，能知道右侧有多少个比左值小的，所以要右侧指针移动)

```java
public static int reversePairNumber(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    // arr[L..R]既要排好序，也要求逆序对数量返回
    // 所有merge时，产生的逆序对数量，累加，返回
    public static int process(int[] arr, int l, int r) {
        if (l == r) {
            return 0;
        }
        // l < r
        int mid = l + ((r - l) >> 1);
        return process(arr, l, mid) + process(arr, mid + 1, r) + merge(arr, l, mid, r);
    }

    //这次指针从右边开始移动
    public static int merge(int[] arr, int L, int m, int r) {
        int[] help = new int[r - L + 1];
        int i = help.length - 1;
        int p1 = m;
        int p2 = r;
        int res = 0;
        while (p1 >= L && p2 > m) {
            res += arr[p1] > arr[p2] ? (p2 - m) : 0;
            help[i--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
        }
        while (p1 >= L) {
            help[i--] = arr[p1--];
        }
        while (p2 > m) {
            help[i--] = arr[p2--];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
        return res;
    }
```

#### 4）翻转对，归并排序

题目：给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。返回给定数组中的重要翻转对的数量

1.定义一个函数process(int[] arr, int L, int R)，把0到N-1上变有序，并返回翻转对数量

2.先返回L到M上的翻转对数量，再返回M+1到R上的翻转对数量，最后merge两部分再求翻转对数量，把这三部分翻转对数量加起来

3.这次的先求翻转对数量，再进行merge。利用for循环指向左侧的变量，再定义一个变量指向右侧的变量，初始值为m+1，如果左值 > 2 * 右值，右侧指针右移，直到不满足停下，翻转对数量 += 右侧指针 - (M+1)。先计算翻转数量再merge

4.然后左侧指针移动，以此类推。最后merge

```java
 public static int reversePairs(int[] nums) {
        if(nums == null || nums.length <= 1){
            return 0;
        }
        return process(nums,0,nums.length - 1);
    }

    public static int process(int[] arr,int L,int R){
        //边界条件
        if(L == R){
            return 0;
        }
        int M = (L + R) / 2;
        //先计算左侧数量，再计算右侧数量，然后计算merge数量，最后三者加起来
        return process(arr,L,M) + process(arr,M+1,R) + merge(arr,L,M,R);
    }

    
    public static int merge (int[] arr,int L,int M,int R){
        int ans = 0;
        int windowR = M + 1;  //用来追踪右侧
        //用一个for循环来追踪左侧
        for(int i = L;i <= M; i++){
            //1、先计算翻转对
            while(windowR <= R && (long)arr[i] > (long)2 * arr[windowR]){
                windowR++;
            }
            ans += windowR - (M + 1);
        }

        //2、再进行merge
        int[] help = new int[R - L + 1];
        int p1 = L;
        int p2 = M + 1;
        int i = 0;
        while(p1 <= M && p2 <= R){
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        //一侧都排完了
        while(p1 <= M){
            help[i++] = arr[p1++];
        }
        while(p2 <= R){
            help[i++] = arr[p2++];
        }
        //将排好序的help数组拷贝到arr中
        for(i = 0;i < help.length; i++){
            arr[L + i] = help[i];
        }

        return ans;
    }
```

### 5、class05

#### 1）区间和的个数，归并排序，难

题目：给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的区间和的个数 。区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

1.该问题要转换成 利用前缀数组来求区间和的个数

2.定义一个函数process(long[] sum, int L, int R, int lower, int upper)，返回0 ~ N-1上满足条件的区间和数量

3.边界条件L==R，即求L这个位置上的区间和数量，若这个数满足[lower,upper]，说明对于原数组0~L这是一个区间和，区间和数+1。若不满足，区间和数+0，继续接下的操作

4.先求L到M上的区间和数，再求M+1到R上的区间和数，然后求merge后的区间和数，最后加起来

5.这次先求区间和数，再进行merge。目标就是求右侧每个元素的区间和个数的总和。两个变量追踪左侧，min =  右数 - upper ,max = 右数 - lower，若左数在[min,max]之间，则(左数,右数)这个区间和就满足条件，利用两个变量追踪 求所有满足条件的左数

6.然后再merge

```java
    public int countRangeSum(int[] nums, int lower, int upper) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        //转换为利用前缀数组求区间和个数
        long[] sum = new long[nums.length];
        sum[0] = nums[0];
        for(int i = 1; i < nums.length;i++){
            sum[i] = sum[i - 1] + nums[i];
        }
        //返回前缀数组0 ~ N-1上的区间和个数
        return process(sum,0,sum.length - 1,lower,upper);
    }
     
    public static int process(long[] sum,int L,int R,int lower,int upper){
        if(L == R){
            //若L这个数满足，即对于原数组(0,L)这个区间和满足条件，区间和+1，否则+0
            return sum[L] >= lower && sum[L] <= upper ? 1 : 0;
        }
        int M = (L + R) / 2;
        //先求左侧区间和数，再求右侧区间和数，然后求merge后的区间和数，最后加起来
        return process(sum,L,M,lower,upper) + process(sum,M+1,R,lower,upper) + merge(sum,L,M,R,lower,upper);

    }

    public static int merge(long[] sum,int L,int M,int R,int lower,int upper){
        //1、先计算区间和数
        int ans = 0;   //区间和数
        //定义两个变量追踪左侧，用来判断右侧的每个数的区间和数
        int windowL = L;
        int windowR = L;
        //定义一个循环来，追踪右侧每个数  [windowL, windowR)
        for(int i = M + 1; i <= R; i++){
            long min = sum[i] - upper;
            long max = sum[i] - lower;
            //若左数在[min,max]之间，则(左数,右数)这个区间和就满足条件
            while (windowR <= M && sum[windowR] <= max) {
                windowR++;
            }
            while (windowL <= M && sum[windowL] < min) {
                windowL++;
            }
            //此时windowL ~ windowR是满足条件的，即(windowL,右数) 一直到 (windowR,右数)这些区间和都是满足条件的
            ans += windowR - windowL;
        }
        //2、再merge
        long[] help = new long[R-L+1];
        int p1 = L;
        int p2 = M + 1;
        int i = 0;
        while(p1 <= M && p2 <= R){
            help[i++] = sum[p1] <= sum[p2] ? sum[p1++] : sum[p2++];
        }
        while(p1 <= M){
            help[i++] = sum[p1++];
        }
        while(p2 <= R){
            help[i++] = sum[p2++];
        }
        for(i = 0; i < help.length; i++){
            sum[L+i] = help[i];
        }

        return ans;
    }
```

#### 2）荷兰国旗问题的划分

题目：将小于最后的数arr[R]，等于arr[R]和大于arr[R]的数分成三个区域，排好后 返回等于arr[R]的区间

1.设置小于区域 less = L -1和 大于区域more = R，大于区域先把arr[R]囊括起来，最后再来处理

2.定义个变量用来追踪当前数，如果当前数 = arr[R]，追踪下一个数

3.如果当前数 < arr[R] ，当前数与小于区域右边的那一数互换，然后区域向右移，追踪下一个数

4.如果当前数 > arr[R] ，当前数与大于区域左边的那一数互换，然后区域向左移，不追踪下一个数

5.最后将arr[R]与 大于区域 第一个数互换。最终返回的区间是 (小于区域 + 1,大于区域)，因为大于区域的第一个数是之前的最后的那个arr[R]

```java
    // arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值
    // <arr[R] ==arr[R] > arr[R]
    //返回最终排好的 等于arr[R]的那些数的坐标区间(都在中间位置)
    public static int[] netherlandsFlag(int[] arr, int L, int R) {
        if (L > R) { // L...R L>R
            return new int[] { -1, -1 };
        }
        if (L == R) {
            return new int[] { L, R };
        }
        int less = L - 1; // < 区 右边界
        int more = R; // > 区 左边界
        int index = L;
        while (index < more) { // 当前位置，不能和 >区的左边界撞上
            //如果当前数 = arr[R]，追踪下一个数
            if (arr[index] == arr[R]) {
                index++;
            } else if (arr[index] < arr[R]) {
                //如果当前数 < arr[R] ，当前数与区域前一个数互换，然后区域向后移，追踪下一个数
				swap(arr, less + 1, index);
				less++;
				index++;
            } else {
                //如果当前数 > arr[R] ，当前数与区域前一个数互换，然后区域向左移，不追踪下一个数
                swap(arr, index, more - 1);
                more--;
            }
        }
        //最后将arr[R]与 大于区域 第一个数互换
        swap(arr, more, R); // <[R]   =[R]   >[R]
        //返回的区间是 (小于区域 + 1,大于区域)，因为大于区域的第一个数是之前的最后的那个arr[R]
        return new int[] { less + 1, more };
    }
```

#### 3）随机快速排序，复杂度O(N*logN)

普通快速排序最差情况复杂度O(N^2)

1.调用方法process3(int[] arr, int L, int R)，将0~N-1 上的元素进行随机快速排序

2.边界条件L >= R返回上一层

3.先将最后一个数与前面随机一个数进行互换 变成随机快速排序

4.然后通过netherlandsFlag方法 将以arr[R]进行分割3部分，然后返回 囊括所有的arr[R] 的区间

5.最后递归调用process方法，先完成(L，区间左值 -1)上的随机快速排序，再完成(区间右值+1，R)上的随机快速排序

```java
	// 荷兰国旗问题
	public static int[] netherlandsFlag(int[] arr, int L, int R) {
		if (L > R) {
			return new int[] { -1, -1 };
		}
		if (L == R) {
			return new int[] { L, R };
		}
		int less = L - 1;
		int more = R;
		int index = L;
		while (index < more) {
			if (arr[index] == arr[R]) {
				index++;
			} else if (arr[index] < arr[R]) {
				swap(arr, index++, ++less);
			} else {
				swap(arr, index, --more);
			}
		}
		swap(arr, more, R);
		return new int[] { less + 1, more };
	}
   
	public static void quickSort3(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process3(arr, 0, arr.length - 1);
    }

    public static void process3(int[] arr, int L, int R) {
        if (L >= R) {
            return;
        }
        swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
        int[] equalArea = netherlandsFlag(arr, L, R);
        process3(arr, L, equalArea[0] - 1);
        process3(arr, equalArea[1] + 1, R);
    }
```

### 6、class06 --  堆

#### 1）堆

堆本质是一棵完全二叉树，完全二叉树只要有右孩子就必须有左孩子，它包括大根堆和小根堆，大根堆是每个子树的根节点都比孩子节点要大，这样第一个根节点数就是最大的

堆的相关操作：

```java
// 新加进来的数，现在停在了index位置，若它爹小于它，依次往上移动，
//向上调整
private void heapInsert(int[] arr, int index) {
    // [index] [index-1]/2
    // index == 0
    while (arr[index] > arr[(index - 1) / 2]) {
        //若新加的数大于它爹，与它爹交换位置，再去比较它与它的新爹谁大，循环下去，直到它爹>=它
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

// 背景：将第一个元素与最后一个元素互换后，heapSize--，逻辑删除最大元素。
// 检验此时第一个数 下面它大是否比孩子大。若它比下面的孩子小。从index位置，它不断的下沉
// 直到 左右孩子中较大的孩子都不再比index位置的数大 或者 已经没孩子了，结束
//向下调整
private void heapify(int[] arr, int index, int heapSize) {
    int left = index * 2 + 1;
    while (left < heapSize) { // 如果有左孩子，有没有右孩子，可能有可能没有！
        //1、先取左右孩子中较大的。如果有右孩子并且右孩子大于左孩子选右孩子。如果没有右孩子或者左孩子大于右孩子选左孩子
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        //2、然后将孩子与它爹比较。 把爹和孩子中较大的下标，给largest。
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            //3、若它爹就是较大的，不用交换，结束循环
            break;
        }
        //4、若孩子大于爹，交换位置，把大的放上面。然后继续检查它的孩子是否比它大，循环下去
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}
```

#### 2）堆排序，复杂度O(N*logN)

```java
public static void heapSort(int[] arr) {
    if(arr == null || arr.length <= 1){
        return;
    }

    // //1.1、先把数组从0开始依次heapInsert，最后变成大根堆
    // // O(N*logN)
    // for(int i = 0; i < arr.length; i++){
    //     heapInsert(arr,i);
    // }
    //或者1.2、从最底层开始，把这一层都变成大根堆，然后再处理上一层，依次变成大根堆
    // O(N)
    for(int i = arr.length-1; i >=0 ;i--){
        heapify(arr,i,arr.length);
    }
    //2、然后把第一个元素也就是最大的元素与最后一个元素交换，同时heapSize有效值减一，逻辑删除最大值，最大值排好序了
    int heapSize = arr.length;      //heapSize以内的数满足大根堆
    swap(arr,0,heapSize - 1);
    heapSize--;

    while(heapSize > 0){
        //3、对新换上来的根节点向下heapify
        heapify(arr,0,heapSize);
        //4、heapify后又变成大根堆，再把第一个元素和最后一个元素交换，这样又一个第二大的排好序了，直到heapSize变为0
        swap(arr,0,heapSize - 1);
        heapSize--;
    }
}

// arr[index]刚来的数，往上移动
public static void heapInsert(int[] arr, int index) {
    while (arr[index] > arr[(index - 1) / 2]) {
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

// arr[index]位置的数，能否往下移动
public static void heapify(int[] arr, int index, int heapSize) {
    int left = index * 2 + 1; // 左孩子的下标
    while (left < heapSize) { // 下方还有孩子的时候
        // 两个孩子中，谁的值大，把下标给largest
        // 1）只有左孩子，left -> largest
        // 2) 同时有左孩子和右孩子，右孩子的值<= 左孩子的值，left -> largest
        // 3) 同时有左孩子和右孩子并且右孩子的值> 左孩子的值， right -> largest
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        // 父和较大的孩子之间，谁的值大，把下标给largest
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            break;
        }
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}
```

#### 3）部分有序数组变有序

给定一个数组，部分有序，意思就是现在数组元素的位置 距离 排好顺序后的位置 不超过k个单位

思想：最小的数一定在(0,k)上，因为若在k+1或者以后，最小数移动k位就无法到0的位置上了。第二小的一定在(1,k+1)，以此类推。这样 堆加一个，弹一个，因为是小根堆，弹出来的都是当前堆中最小的

```java
public static void sortedArrDistanceLessK(int[] arr, int k) {
    //若k=0 说明已经排好序了
    if (k == 0) {
        return;
    }
    // 默认小根堆
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    int index = 0;  //放入堆中的元素下标
    // 最小的数一定在(0,k)上，因为若在k+1或者以后，最小数移动k位就无法到0的位置上了
    //1、先把(0,k-1)上的数放入小根堆里
    for (; index <= Math.min(arr.length - 1, k - 1); index++) {
        heap.add(arr[index]);
    }

    //2、再把k上的数到堆里，然后弹出堆的第一个元素就是最小值，放进新数组。然后依次往后，堆加一个，弹一个
    int i = 0;	//排好序数组的下标
    for (; index < arr.length; i++, index++) {

        heap.add(arr[index]);
        arr[i] = heap.poll();
    }
    //3、等到元素都已经加过堆里面了，就把堆剩余的元素都弹出来，就是排好序的
    while (!heap.isEmpty()) {
        arr[i++] = heap.poll();
    }
}
```

### 7、class07

#### 1）最大线段重合问题，堆实现

题目：给定很多线段，每个线段都有两个数[start,end]，表示线段开始位置和结束为止，左右都是闭区间。规定：1、线段的开始和结束位置一定都是整数值，2、线段重合区域的长度必须 >= 1。返回线段最多重合区域中，包含了几条线段

由于重合线段的左端点必定是其中某一个线段的左端点。所以求每一个线段 以这个线段左端点开始重合线段的个数，然后返回最大的，即为所求。

```java
public static int maxCover3(int[][] m) {
    // m是二维数组，可以认为m内部是一个一个的一维数组
    // 每一个一维数组就是一个对象，也就是线段
    // 如下的code，就是根据每一个线段的开始位置排序
    // 比如, m = { {5,7}, {1,4}, {2,6} } 跑完如下的code之后变成：{ {1,4}, {2,6}, {5,7} }

    //1、首先把所有线段按左端点从小到大排序
    Arrays.sort(m, (a, b) -> (a[0] - b[0]));
    //2、创建小根堆，用于存放每一个线段的右端点
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    //3、依次检验每个线段的 以这个线段左端点开头的重合线段的个数
    int max = 0;
    for (int[] line : m) {
        //4、若小根堆不为空 并且 小跟堆顶值小于当前线段的左端点，说明之前的这个线段不与当前线段重合，从小根堆中把它弹出。
        while (!heap.isEmpty() && heap.peek() <= line[0]) {
            heap.poll();
        }
        //5、此时小跟堆中线段都是与当前线段重合的，把当前线段的右端点也放进小根堆中
        heap.add(line[1]);
        //6、小根堆中存放线段右端点的数量就是与当前线段重合的线段数
        //若当前线段的重合线段数比之前的线段重合数大，更新max，否则继续遍历下一个线段
        max = Math.max(max, heap.size());
    }
    return max;
}
```

#### 2）加强堆

```java
//T一定要是非基础类型，有基础类型需求 包一层
public class HeapGreater<T> {

	private ArrayList<T> heap;				//堆
	private HashMap<T, Integer> indexMap;	//反向索引表
	private int heapSize;					//数组中表示堆的有效长度
	private Comparator<? super T> comp;		//比较器

	public HeapGreater(Comparator<? super T> c) {
		heap = new ArrayList<>();
		indexMap = new HashMap<>();
		heapSize = 0;
		comp = c;
	}

	public boolean isEmpty() {
		return heapSize == 0;
	}

	public int size() {
		return heapSize;
	}

	public boolean contains(T obj) {
		return indexMap.containsKey(obj);
	}

	public T peek() {
		return heap.get(0);
	}

	public void push(T obj) {
		//1、堆和反向索引表都要添加该元素
		heap.add(obj);
		indexMap.put(obj, heapSize);
		//2、将该元素向上heapInsert，继续变成堆
		heapInsert(heapSize++);
	}

	public T pop() {
		//1、获取要弹出的元素
		T ans = heap.get(0);
		//2、将要弹出的元素和最后一个元素交换
		swap(0, heapSize - 1);
		//3、反向索引表和堆 都要删除 交换后的最后一个元素(就是要弹出的元素)
		indexMap.remove(ans);
		heap.remove(--heapSize);
		//4、新换上来的元素，向下进行heapify，继续变成堆
		heapify(0);
		return ans;
	}

	//删除元素：就是把要删除的元素和最后一个元素互换 然后删除
	//经过该方法删除完某个元素后，仍满足堆
	public void remove(T obj) {
		//1、获取最后一个元素
		T replace = heap.get(heapSize - 1);
		//2、获取要删除元素的索引
		int index = indexMap.get(obj);
		//3、反向索引表删除该元素 堆逻辑删除数组最后一个位置
		indexMap.remove(obj);
		heap.remove(--heapSize);
		//如果要删除的元素不是最后一个元素
		if (obj != replace) {
			//4、将删除的元素的位置替换成原来最后一个元素 并更新原来最后一个元素的反向索引表
			heap.set(index, replace);
			indexMap.put(replace, index);
			//5、对原来最后一个元素进行调整，使其仍满足堆
			resign(replace);
		}
	}

	//对元素obj进行调整，使其仍满足堆
	public void resign(T obj) {
		//两个只会执行一个
		heapInsert(indexMap.get(obj));
		heapify(indexMap.get(obj));
	}

	// 请返回堆上的所有元素
	public List<T> getAllElements() {
		List<T> ans = new ArrayList<>();
		for (T c : heap) {
			ans.add(c);
		}
		return ans;
	}

	private void heapInsert(int index) {
		while (comp.compare(heap.get(index), heap.get((index - 1) / 2)) < 0) {
			swap(index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

	private void heapify(int index) {
		int left = index * 2 + 1;
		while (left < heapSize) {
			int best = left + 1 < heapSize && comp.compare(heap.get(left + 1), heap.get(left)) < 0 ? (left + 1) : left;
			best = comp.compare(heap.get(best), heap.get(index)) < 0 ? best : index;
			if (best == index) {
				break;
			}
			swap(best, index);
			index = best;
			left = index * 2 + 1;
		}
	}

	private void swap(int i, int j) {
		T o1 = heap.get(i);
		T o2 = heap.get(j);
		heap.set(i, o2);
		heap.set(j, o1);
		indexMap.put(o2, i);
		indexMap.put(o1, j);
	}

}
```



#### 3）手动改写堆题目，了解

题目：给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作，arr = [3,3,1,1,2,5...]，op=[T,T,T,F,T,F...]。一对arr[i]和op[i]就代表一个事件：用户号为arr[i]，op[i]=T就代表这个用户购买了一件商品，op[i]=F就代表这个用户退货了一件商品。现在你作为电商平台负责人，你想在每一个事件到来的时候，都给购买次数最多的前K名用户颁奖。所以每个事件发生后，你都需要一个得奖名单(得奖区)。

得奖系统的规则：

1.如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效，得奖名单和之前时一致

2.某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1

3.每次都是最多K个用户得奖，K也为传入的参数，如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果

4.得奖系统分为得奖区和候选区，任何用户只要购买数>0，就一定在这两个区域中的一个

5.购买数量最大的前K名用户进入得奖区，在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区

6.如果购买数不足以进入得奖区的用户，进入候选区

7.如果候选区购买数最多的用户，已经足以进入得奖区，该用户就会替换得奖区中购买数最少的用户（大于才能替换），如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户；如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户。

8.候选区和得奖区是两套时间。因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有。

从得奖区出来进入候选区的用户，得奖区时间删除，进入候选区的事件就是当前事件的时间(可以理解为arr[i]和op[i]中的i)；

从候选区出来进入得奖区的用户，候选区时间删除，进入得奖区的事件就是当前事件的时间

9.如果某用户购买数等于0，不管在哪个区域都得离开，区域时间删除，离开是指彻底离开，哪个区域也不会找到该用户。如果下次该用户又发生购买行为，产生>0的购买数，会再次根据之前规则回到某个区域中，进入区域的时间重记

```java
public static class Customer {
    public int id;              //顾客id
    public int buy;             //顾客购买件数
    public int enterTime;       //顾客进入得奖区或者候选区的新时间

    public Customer(int v, int b, int o) {
        id = v;
        buy = b;
        enterTime = 0;
    }
}

//将购买件数高的顾客，放在候选区顶部；若购买件数相等，将早来的顾客放前面
//大根堆实现候选区
public static class CandidateComparator implements Comparator<Customer> {

    @Override
    public int compare(Customer o1, Customer o2) {
        return o1.buy != o2.buy ? (o2.buy - o1.buy) : (o1.enterTime - o2.enterTime);
    }

}

//将购买件数少的顾客，放在得奖区顶部；若购买件数相等，将早来的顾客放前面
//小根堆实现得奖区
public static class DaddyComparator implements Comparator<Customer> {

    @Override
    public int compare(Customer o1, Customer o2) {
        return o1.buy != o2.buy ? (o1.buy - o2.buy) : (o1.enterTime - o2.enterTime);
    }

}

public static class WhosYourDaddy {
    private HashMap<Integer, Customer> customers;  //顾客表，key -> 顾客id   value ->顾客信息
    private HeapGreater<Customer> candHeap;        //候选区，加强大根堆实现
    private HeapGreater<Customer> daddyHeap;       //得奖区，加强小根堆实现
    private final int daddyLimit;                  //得奖区人数的限制，问题中是K

    public WhosYourDaddy(int limit) {
        customers = new HashMap<Integer, Customer>();
        candHeap = new HeapGreater<>(new CandidateComparator());
        daddyHeap = new HeapGreater<>(new DaddyComparator());
        daddyLimit = limit;
    }

    // 当前处理i号事件，arr[i] -> id,  buyOrRefund
    public void operate(int time, int id, boolean buyOrRefund) {
        //1、若该顾客退货，并且顾客表都没有该顾客的信息，不进行操作，直接忽略
        if (!buyOrRefund && !customers.containsKey(id)) {
            return;
        }
        //2、若该顾客购货，并且顾客表没有该顾客的信息，说明该顾客是第一次购买商品，先在顾客表中记录上新顾客id，确保每个顾客都有记录
        if (!customers.containsKey(id)) {
            customers.put(id, new Customer(id, 0, 0));
        }
        //3、顾客表中获取顾客信息，判断此时事件是购买还是退货
        Customer c = customers.get(id);
        if (buyOrRefund) {
            c.buy++;
        } else {
            c.buy--;
        }
        //4、若顾客购买数变成0，将顾客表中信息移除。下次来的话在重新记录
        if (c.buy == 0) {
            customers.remove(id);
        }
        //5、经过事件后，候选区和得奖区都没有该顾客
        if (!candHeap.contains(c) && !daddyHeap.contains(c)) {
            //5.1、得奖区目前没满，直接加入得奖区
            if (daddyHeap.size() < daddyLimit) {
                c.enterTime = time;
                daddyHeap.push(c);
            } else {
                //5.2、得奖区满了，直接进入候选区
                c.enterTime = time;
                candHeap.push(c);
            }
        } else if (candHeap.contains(c)) {
            //6、之前候选区有该顾客，若购买数变成0，从候选区删除；否则对候选区进行调整，使它仍满足大根堆
            if (c.buy == 0) {
                candHeap.remove(c);
            } else {
                candHeap.resign(c);
            }
        } else {
            //7、之前得奖区有该顾客，若购买数变成0，从得奖区删除；否则对得奖区进行调整，使它仍满足小根堆
            if (c.buy == 0) {
                daddyHeap.remove(c);
            } else {
                daddyHeap.resign(c);
            }
        }
        //8、更新得奖区最新情况
        daddyMove(time);
    }

    //获取得奖区的顾客id集合
    public List<Integer> getDaddies() {
        List<Customer> customers = daddyHeap.getAllElements();
        List<Integer> ans = new ArrayList<>();
        for (Customer c : customers) {
            ans.add(c.id);
        }
        return ans;
    }

    //更新得奖区最新情况
    private void daddyMove(int time) {
        //1、候选区为空，不用更新得奖区
        if (candHeap.isEmpty()) {
            return;
        }
        //2、得奖区不满，将候选区的第一个放进来，也就是大根堆第一个放进来，并赋予最新事件的时间
        if (daddyHeap.size() < daddyLimit) {
            Customer p = candHeap.pop();
            p.enterTime = time;
            daddyHeap.push(p);
        } else {
            //3、得奖区满了，并且候选区不为空
            //4、检验候选区第一个是否满足替换得奖区第一个的条件
            if (candHeap.peek().buy > daddyHeap.peek().buy) {
                Customer oldDaddy = daddyHeap.pop();
                Customer newDaddy = candHeap.pop();
                oldDaddy.enterTime = time;
                newDaddy.enterTime = time;
                daddyHeap.push(newDaddy);
                candHeap.push(oldDaddy);
            }
        }
    }

}

//主函数，返回每次事件的得奖区的信息
public static List<List<Integer>> topK(int[] arr, boolean[] op, int k) {
    List<List<Integer>> ans = new ArrayList<>();
    WhosYourDaddy whoDaddies = new WhosYourDaddy(k);
    for (int i = 0; i < arr.length; i++) {
        //for循环遍历 每次事件的得奖区的信息
        whoDaddies.operate(i, arr[i], op[i]);
        ans.add(whoDaddies.getDaddies());
    }
    return ans;
}
```

### 8、class08

#### 1）前缀树

```java
 class Trie {
        //前缀树节点类型
        class Node {
            public int pass;    //有几个字符经过该节点
            public int end;      //有几个字符串以该结点结束
            public Node[] nexts;  //以数组下标为路的下一个节点。  数组下标0代表a  1代表b ...

            public Node() {
                pass = 0;
                end = 0;
                nexts = new Node[26];
            }
        }

        //头结点
        private Node root;

        public Trie() {
            root = new Node();
        }

        //往前缀树中加入字符串
        public void insert(String word) {
            if (word == null) {
                return;
            }
            //字符串拆成字符
            char[] str = word.toCharArray();
            Node node = root;       //node先指向根节点
            node.pass++;
            int path = 0;
            for (int i = 0; i < str.length; i++) { // 从左往右遍历字符
                path = str[i] - 'a'; // 由字符，对应成走向哪条路      a走0号路，b走1号路...
                //如果当前节点后面没有 这个字符的路
                if (node.nexts[path] == null) {
                    node.nexts[path] = new Node();
                }
                //node指向新的结点
                node = node.nexts[path];
                node.pass++;
            }
            node.end++;
        }

        //删除前缀树中的word
        public void erase(String word) {
            if (countWordsEqualTo(word) != 0) {
                char[] chs = word.toCharArray();
                Node node = root;
                node.pass--;
                int path = 0;
                for (int i = 0; i < chs.length; i++) {
                    path = chs[i] - 'a';
                    if (--node.nexts[path].pass == 0) {
                        node.nexts[path] = null;
                        return;
                    }
                    node = node.nexts[path];
                }
                node.end--;
            }
        }

        //word这个单词出现了几次
        public int countWordsEqualTo(String word) {
            if (word == null) {
                return 0;
            }
            char[] chs = word.toCharArray();
            Node node = root;
            int index = 0;
            for (int i = 0; i < chs.length; i++) {
                index = chs[i] - 'a';
                if (node.nexts[index] == null) {
                    //如果没路了，就是出现0次
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.end;
        }

        //pre前缀出现了几次
        public int countWordsStartingWith(String pre) {
            if (pre == null) {
                return 0;
            }
            char[] chs = pre.toCharArray();
            Node node = root;
            int index = 0;
            for (int i = 0; i < chs.length; i++) {
                index = chs[i] - 'a';
                if (node.nexts[index] == null) {
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.pass;
        }
    }
```

#### 2）计数排序

```java
public static void countSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
        //1、先找到数组中的最大值，作为新数组的数组大小，因为新数组的下标代表原数组的值
        max = Math.max(max, arr[i]);
    }
    int[] bucket = new int[max + 1];
    for (int i = 0; i < arr.length; i++) {
        //2、创建一个新的数组，下标代表存的数值，新数组值代表 值为下标的这个数在原数组中的个数
        //新数组中间会有好多空着的
        bucket[arr[i]]++;
    }
    int i = 0;
    //3、然后把新数组依次遍历，就是排好序的了
    for (int j = 0; j < bucket.length; j++) {
        //遍历完所有 以这个下标为值的这个数
        while (bucket[j]-- > 0) {
            arr[i++] = j;
        }
    }
}
```

#### 3）基数排序

```java
// 基数排序, 十进制的最大位数digit
public static void radixSort(int[] arr, int digit) {
    final int radix = 10;
    int i = 0, j = 0;
    // 有多少个数准备多少个辅助空间
    int[] help = new int[arr.length];
    for (int d = 1; d <= digit; d++) { // 有多少位就进出几次。  1->个位  2->十位...
        //现在count[i]表示d位数字=i的一共有多少个
        int[] count = new int[radix]; // 规定count数组大小是10，10个空间，
        for (i = 0; i < arr.length; i++) {
            //1、获取数组元素第d位上的数，添加到count数组。现在count[i]表示d位数字=i的一共有多少个
            j = getDigit(arr[i], d);
            count[j]++;
        }
        for (i = 1; i < radix; i++) {
            //2、现在count[i]表示d位数字<=i的一共有多少个，后面就这样用
            count[i] = count[i] + count[i - 1];
        }
        for (i = arr.length - 1; i >= 0; i--) {
            //3、从右往左遍历获取d位上的数，count[j]表示d位<=j的个数，所以新数组0~count[j]-1上放的都是d位<=j的数，将它放在最右边就是count[j]-1上，核心就是从右往左放
            //只减count数组j下标的数量即可，>j下标的数量不用减，不耽误后面计算
            j = getDigit(arr[i], d);
            help[count[j] - 1] = arr[i];
            count[j]--;
        }
        for (i = 0; i < arr.length; i++) {
            //将d位排好序的数组更新到arr中。省了10个桶
            arr[i] = help[i];
        }
    }
}
```

#### 4）排序算法总结

|          | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| :------: | :--------: | :------------: | :----: |
| 选择排序 |   O(N^2)   |      O(1)      |   无   |
| 冒泡排序 |   O(N^2)   |      O(1)      |   有   |
| 插入排序 |   O(N^2)   |      O(1)      |   有   |
| 归并排序 | O(N*logN)  |      O(N)      |   有   |
| 随机快排 | O(N*logN)  |    O(logN)     |   无   |
|  堆排序  | O(N*logN)  |      O(1)      |   无   |
| ======== |   ======   |   =========    | =====  |
| 计数排序 |    O(N)    |      O(M)      |   有   |
| 基数排序 |    O(N)    |      O(N)      |   有   |

总结：

1.不基于比较的排序，对样本数据有严格要求，不易改写

2.基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用

3.基于比较的排序，时间复杂度的极限是O(N*logN)

4.时间复杂度O(N*logN)，额外空间复杂度低于O(N)，且稳定的基于比较的排序是不存在的

5.为了绝对的速度选快排（快排的常数时间最快），为了省空间选堆排序，为了稳定性选归并

### 9、class09 -- 链表题目

#### 1）快慢指针练习

1.输入链表头节点，奇数长度返回中点，偶数长度返回上中点

```java
public static Node midOrUpMidNode(Node head) {
    //链表长度为0,1,2
    if(head == null || head.next == null || head.next.next == null){
        return head;
    }
    //链表长度为3个及以上
    //1、定义两个指针快指针和慢指针
    Node fast = head;
    Node slow = head;
    //2、慢指针一次走一位，快指针一次走两位
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

2.输入链表头节点，奇数长度返回中点，偶数长度返回下中点

```java
public static Node midOrDownMidNode(Node head) {
    //链表长度为0,1
    if(head == null || head.next == null){
        return head;
    }
    //链表长度为2个及以上
    Node fast = head.next;
    Node slow = head.next;
    while (fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

3.输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个

```java
public static Node midOrUpMidPreNode(Node head) {
    //链表长度为0，1，2
    if(head == null || head.next == null || head.next.next == null){
        return null;
    }
    //链表长度为3个及以上
    Node fast = head.next.next;
    Node slow = head;
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

4.输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

```java
public static Node midOrDownMidPreNode(Node head) {
    //链表长度为0,1
    if(head == null || head.next == null){
        return null;
    }
    //链表长度为2个及以上
    Node fast = head.next;
    Node slow = head;
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

#### 2）判断一个链表是否为回文结构

题目：给定一个单链表的头节点head，请判断该链表是否为回文结构

```java
public static boolean isPalindrome3(Node head) {
    //没有节点或者一个结点默认是回文结构
    if(head == null || head.next == null){
        return true;
    }
    //1、利用快慢指针先找到链表中点
    Node slow = head;
    Node fast = head;
    while(fast.next != null && fast.next.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }
    //此时slow指向的就是中点，让中点的next指向空
    //2、然后翻转链表
    Node pre = slow;
    Node cur = pre.next;
    pre.next = null;
    Node next = null;
    while(cur != null){
        //记录下一个节点位置
        next = cur.next;
        //翻转指针
        cur.next = pre;
        //移动两个指针，准备翻转后面的
        pre = cur;
        cur = next;
    }
    //3、从左往右，从右往左开始比对
    boolean res = true;
    Node tail = pre;
    while(head != null && tail != null){
        if(head.value != tail.value){
            //注意：若不相等记录false，然后后面还要将链表翻转回来
            res = false;
            break;
        }
        head = head.next;
        tail = tail.next;
    }
    //4、最后还要把链表翻转回来
    cur = pre.next;
    pre.next = null;
    while(cur != null){
        //记录下一个节点位置
        next = cur.next;
         //翻转指针
        cur.next = pre;
        //移动两个指针，准备翻转后面的
        pre = cur;
        cur = next;
    }
    return res;
}
```

#### 3）将单向链表按某值划分成左边小，中间相等，右边大的形式

题目：将单向链表按某值划分成左边小，中间相等，右边大的形式

```java
public static Node listPartition2(Node head, int pivot) {
    //1、准备6个指针
    Node sH = null; // small head
    Node sT = null; // small tail
    Node eH = null; // equal head
    Node eT = null; // equal tail
    Node mH = null; // big head
    Node mT = null; // big tail

    Node next = null;  //用来获取链表下一个元素
    while(head != null){
        //2、记录下一个节点，并把当前节点与其他节点分离开
        next = head.next;
        head.next = null;
        //3、若这个元素比pivot小
        if(head.value < pivot){
            if(sH == null){
                //3.1、说明现在sH和sT之间没有元素，直接添加
                sH = head;
                sT = head;
            } else {
                //3.2、说明现在sH和sT之间有元素
                sT.next = head;
                sT = head;
            }
        } else if(head.value == pivot){
            //4、若这个元素和pivot一样大
            if(eH == null){
                //4.1、说明现在eH和eT之间没有元素，直接添加
                eH = head;
                eT = head;
            } else {
                //4.2、说明现在eH和eT之间有元素
                eT.next = head;
                eT = head;
            }
        } else{
            //5、若这个元素比pivot大
            if(mH == null){
                //5.1、说明现在mH和mT之间没有元素，直接添加
                mH = head;
                mT = head;
            } else {
                //5.2、说明现在mH和mT之间有元素
                mT.next = head;
                mT = head;
            }

        }
        //6、继续看下一个元素
        head = next;
    }

    //7、开始连起来，不用管右区域，只关心左中区域
    if(sH != null){
        //7.1、左有中无
        if(eH == null){
            sT.next = mH;
        }else{
            //7.2、左有中有
            sT.next = eH;
            eT.next = mH;
        }
        return sH;
    } else {
        //7.3、左无中无
        if(eH == null){
            return mH;
        }else {
            //7.4、左无中有
            eT.next = mH;
            return eH;
        }
    }
    //        if (sT != null) { // 如果有小于区域
    //            sT.next = eH;
    //            eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
    //        }
    //        // 下一步，一定是需要用eT 去接 大于区域的头
    //        // 有等于区域，eT -> 等于区域的尾结点
    //        // 无等于区域，eT -> 小于区域的尾结点
    //        // eT 尽量不为空的尾巴节点
    //        if (eT != null) { // 如果小于区域和等于区域，不是都没有
    //            eT.next = mH;
    //        }
    //        return sH != null ? sH : (eH != null ? eH : mH);
}
```

#### 4）复制带随机指针的链表

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

```java
public Node copyRandomList(Node head) {
    if(head == null){
        return null;
    }
    //1、先在第一个节点和第二个节点之间添加第一个节点的克隆，后面以此类推
    Node cur = head;    //记录老链表的当前节点
    Node next = null;   //记录老链表的下一个节点
    while(cur != null){
        next = cur.next;
        cur.next = new Node(cur.val);
        cur.next.next = next;
        cur = next;
    }

    //2、然后根据老节点的random找到新节点的random
    cur = head;
    Node copy = null;
    while(cur != null){
        next = cur.next.next;
        copy = cur.next;
        copy.random = cur.random == null ? null : cur.random.next;  //注意空指针问题
        cur = next;
    }

    //3、分离老链表和新链表，即更新老链表的next和新链表的next
    cur = head;
    Node res = cur.next;
    while(cur != null){
        next = cur.next.next;
        copy = cur.next;
        cur.next = next;
        copy.next = cur.next == null ? null : next.next;    //注意空指针问题
        cur = next;
    }
    return res;

}
```

### 10、class10

#### 1）两个单链表相交的一系列问题，难

题目：给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null。要求：如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

```java
//如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null
public static Node getIntersectNode(Node head1, Node head2) {
    //若某个链表为null，肯定不相交
    if (head1 == null || head2 == null) {
        return null;
    }
    //1、获取两个链表的入环节点，若无环返回null
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    //2、两个无环节点，求相交的第一个节点
    if (loop1 == null && loop2 == null) {
        return noLoop(head1, head2);
    }
    //3、两个有环节点，求相交的第一个节点
    if (loop1 != null && loop2 != null) {
        return bothLoop(head1, loop1, head2, loop2);
    }
    //4、一个有环和一个无环的链表一定不会相交
    return null;
}

// 利用快慢指针找到链表第一个入环节点，如果无环，返回null
public static Node getLoopNode(Node head) {
    //先将0，1,2节点的情况写出来，防止后面fast为空
    if (head == null || head.next == null || head.next.next == null) {
        return null;
    }
    //1、定义快慢指针，一直遍历到两个指针指向同一个位置
    Node slow = head.next; // n1 -> slow
    Node fast = head.next.next; // n2 -> fast
    while (slow != fast) {
        if (fast.next == null || fast.next.next == null) {
            //若存在null说明链表肯定无环
            return null;
        }
        fast = fast.next.next;
        slow = slow.next;
    }
    //2、让快指针回到头节点位置，慢指针位置不变。让快指针也一次走一个节点，两个指针相遇的位置就是第一个入环节点的位置
    fast = head; // n2 -> walk again from head
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}

// 1、两个无环的链表可能相交
// 如果两个链表都无环，返回第一个相交节点，如果不相交，返回null
public static Node noLoop(Node head1, Node head2) {
    //如果两个链表其中一个为null，肯定不相交
    if (head1 == null || head2 == null) {
        return null;
    }
    //1、先统计一下两个链表的长度。为了后面把长部分走完，再一起走相同的部分，然后找到第一个相交节点
    Node cur1 = head1;
    Node cur2 = head2;
    int len1 = 0;
    int len2 = 0;
    while (cur1.next != null) {
        len1++;
        cur1 = cur1.next;
    }
    while (cur2.next != null) {
        len2++;
        cur2 = cur2.next;
    }
    //2、如果两个链表的最后一个节点不是同一个，说明他俩肯定没相交
    if (cur1 != cur2) {
        return null;
    }
    //3、让cur1指向长链表的头结点，cur2指向另一个链表的头节点
    cur1 = len1 > len2 ? head1 : head2; // 谁长，谁的头变成cur1
    cur2 = cur1 == head1 ? head2 : head1; // 谁短，谁的头变成cur2
    //4、先让长链表把长的那部分走完
    int n = Math.abs(len1 - len2);
    while (n != 0) {
        n--;
        cur1 = cur1.next;
    }
    //5、然后长链表和短链表再各自走完后面的部分，此时他俩后面的部分长度相等。直到走到他俩相交的第一个节点
    while (cur1 != cur2) {
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    return cur1;
}

// 2、一个有环一个无环的链表一定不会相交

// 3、两个有环的链表可能相交
// 两个有环链表，返回第一个相交节点，如果不想交返回null
// 两个有环链表可能有3种情况：
//  1.两个链表不相交。loop1 != loop2
//  2.两个链表相交之后才进入入环节点   loop1 == loop2  相交的节点在loop1前面
//  3.先进入入环节点，在环的途中两个节点相交 loop1 != loop2。loop1或者loop2都可作为第一个相交节点
public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
    Node cur1 = null;
    Node cur2 = null;
    if (loop1 == loop2) {
        //1、loop1 == loop2，两个链表相交之后才进入入环节点，相交的节点在loop1前面
        //方法和求两个无环节点的第一个相交节点类似，只是这次只需遍历里到loop1即可，之前是遍历到null
        cur1 = head1;
        cur2 = head2;
        //1.1、先统计一下两个链表从头节点到loop1的长度
        int len1 = 0;
        int len2 = 0;
        while (cur1 != loop1) {
            len1++;
            cur1 = cur1.next;
        }
        while (cur2 != loop2) {
            len2++;
            cur2 = cur2.next;
        }
        //1.2、cur1指向长链表，cur2指向短链表
        cur1 = len1 > len2 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        //1.3、让长链表先把长的那部分走完
        int n = Math.abs(len1 - len2);
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        //1.4、长短链表一块遍历，直到第一个交点
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    } else {
        //2、loop1 != loop2，开始从其中一个链表的入环节点开始遍历
        cur1 = loop1.next;
        while (cur1 != loop1) {
            //2.1、准备开始从loop1遍历一圈
            if (cur1 == loop2) {
                //2.2、若在遍历一圈的过程中找到了loop2，说明是先进入入环节点，在环的途中两个节点相交
                return loop2;  //返回loop1或loop2都可以。返回loop1是相对于loop2链表，返回loop2是相对于loop1链表
            }
            cur1 = cur1.next;
        }
        //2.3、此时遍历了一圈，都没有找到loop2，说明两个链表不相交，是两个独立的有环链表
        return null;
    }
}
```

#### 2）递归方式实现二叉树的先序、中序、后序遍历

```java
// 先序遍历
public static void pre(Node head) {
    if (head == null) {
        return;
    }
    System.out.println(head.value);
    pre(head.left);
    pre(head.right);
}

//中序
public static void in(Node head) {
    if (head == null) {
        return;
    }
    in(head.left);
    System.out.println(head.value);
    in(head.right);
}

//后序
public static void pos(Node head) {
    if (head == null) {
        return;
    }
    pos(head.left);
    pos(head.right);
    System.out.println(head.value);
}
```

#### 3）非递归方式实现二叉树的先序、中序、后序遍历

```java
//先序
//确保一个节点的右孩子先进栈左孩子后进栈，这样弹出的时候就能先弹出左孩子再弹出右孩子
public static void pre(Node head) {
    System.out.print("pre-order: ");
    if (head != null) {
        Stack<Node> stack = new Stack<Node>();
        //1、根节点进栈
        stack.add(head);
        while (!stack.isEmpty()) {
            //2、只要栈中有元素就弹出
            head = stack.pop();
            //3、弹出这个节点后，先将这个节点的右孩子进栈，再将这个节点的左孩子进栈
            //这样弹出的时候就能保证 根->左->右 这个顺序了
            System.out.print(head.value + " ");
            if (head.right != null) {
                stack.push(head.right);
            }
            if (head.left != null) {
                stack.push(head.left);
            }
        }
    }
    System.out.println();
}

//中序
public static void in(Node head) {
    System.out.print("in-order: ");
    if(head != null){
        Stack<Node> stack = new Stack<>();
        //1、先将根节点一直遍历左孩子到底并将其都压入栈中
        stack.push(head);
        while(head.left != null){
            head = head.left;
            stack.push(head);
        }
        while(!stack.isEmpty()){
            //2、弹出元素栈顶元素并打印
            head = stack.pop();
            System.out.print(head.value + " ");
            //3、然后将弹出元素的右孩子一直遍历它的左孩子到底并将其都压入栈中。这样从栈弹出的顺序就是 左根右
            if(head.right != null){
                head = head.right;
                stack.push(head);
                while(head.left != null){
                    head = head.left;
                    stack.push(head);
                }
            }
        }

    }
    System.out.println();
}

//后序1，使用两个栈
public static void pos1(Node head) {
    System.out.print("pos-order: ");
    if (head != null) {
        Stack<Node> s1 = new Stack<Node>();
        Stack<Node> s2 = new Stack<Node>();
        //1、根节点进栈
        s1.push(head);
        while (!s1.isEmpty()) {
            //2、只要栈中有元素就弹出，弹出不是打印，而是放入另一个栈
            head = s1.pop();
            s2.push(head);
            //3、弹出这个节点后，先将这个节点的左孩子进栈，再将这个节点的右孩子进栈
            //这样弹出的时候就能保证 根->右->左 这个顺序了
            if (head.left != null) {
                s1.push(head.left);
            }
            if (head.right != null) {
                s1.push(head.right);
            }
        }
        //4、再弹出另一个栈，因为进这个栈时是根右左，弹出时就是左右根了
        while (!s2.isEmpty()) {
            System.out.print(s2.pop().value + " ");
        }
    }
    System.out.println();
}

//后序2，使用一个栈，难
public static void pos2(Node h) {
    System.out.print("pos-order: ");
    if (h != null) {
        Stack<Node> stack = new Stack<Node>();
        stack.push(h);
        Node c = null;
        while (!stack.isEmpty()) {
            c = stack.peek();
            if (c.left != null && h != c.left && h != c.right) {
                stack.push(c.left);
            } else if (c.right != null && h != c.right) {
                stack.push(c.right);
            } else {
                System.out.print(stack.pop().value + " ");
                h = c;
            }
        }
    }
    System.out.println();
}
```

### 11、class11--二叉树题目

#### 1）层次遍历二叉树

```java
//层次遍历利用队列
public static void level(Node head) {
    if (head == null) {
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    //1、先将根节点入队列
    queue.add(head);
    while (!queue.isEmpty()) {
        //2、弹出队列元素
        Node cur = queue.poll();
        System.out.println(cur.value);
        //3、弹出一个元素后，如果有的话，将它左孩子和右孩子依次进入队列
        if (cur.left != null) {
            queue.add(cur.left);
        }
        if (cur.right != null) {
            queue.add(cur.right);
        }
    }
}
```

#### 2）二叉树的序列化和反序列化

```java
//先序序列化
public static Queue<String> preSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    pres(head, ans);
    return ans;
}

public static void pres(Node head, Queue<String> ans) {
    if (head == null) {
        ans.add(null);
    } else {
        ans.add(String.valueOf(head.value));
        pres(head.left, ans);
        pres(head.right, ans);
    }
}

//中序序列化
public static Queue<String> inSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    ins(head, ans);
    return ans;
}

public static void ins(Node head, Queue<String> ans) {
    if (head == null) {
        ans.add(null);
    } else {
        ins(head.left, ans);
        ans.add(String.valueOf(head.value));
        ins(head.right, ans);
    }
}

//后序序列化
public static Queue<String> posSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    poss(head, ans);
    return ans;
}

public static void poss(Node head, Queue<String> ans) {
    if (head == null) {
        ans.add(null);
    } else {
        poss(head.left, ans);
        poss(head.right, ans);
        ans.add(String.valueOf(head.value));
    }
}

//先序反序列化
public static Node buildByPreQueue(Queue<String> prelist) {
    if (prelist == null || prelist.size() == 0) {
        return null;
    }
    return preb(prelist);
}

public static Node preb(Queue<String> prelist) {
    String value = prelist.poll();
    if (value == null) {
        return null;
    }
    Node head = new Node(Integer.valueOf(value));
    head.left = preb(prelist);
    head.right = preb(prelist);
    return head;
}

//后序反序列化
public static Node buildByPosQueue(Queue<String> poslist) {
    if (poslist == null || poslist.size() == 0) {
        return null;
    }
    // 左右中  ->  stack(中右左)
    Stack<String> stack = new Stack<>();
    while (!poslist.isEmpty()) {
        stack.push(poslist.poll());
    }
    return posb(stack);
}

public static Node posb(Stack<String> posstack) {
    String value = posstack.pop();
    if (value == null) {
        return null;
    }
    Node head = new Node(Integer.valueOf(value));
    head.right = posb(posstack);
    head.left = posb(posstack);
    return head;
}

//层次序列化--利用队列
public static Queue<String> levelSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    if (head == null) {
        ans.add(null);
    } else {
        ans.add(String.valueOf(head.value));
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(head);
        while (!queue.isEmpty()) {
            head = queue.poll(); // head 父   子
            if (head.left != null) {
                ans.add(String.valueOf(head.left.value));
                queue.add(head.left);
            } else {
                ans.add(null);
            }
            if (head.right != null) {
                ans.add(String.valueOf(head.right.value));
                queue.add(head.right);
            } else {
                ans.add(null);
            }
        }
    }
    return ans;
}

//层次反序列化--利用队列
public static Node buildByLevelQueue(Queue<String> levelList) {
    if (levelList == null || levelList.size() == 0) {
        return null;
    }
    Node head = generateNode(levelList.poll());
    Queue<Node> queue = new LinkedList<Node>();
    if (head != null) {
        queue.add(head);
    }
    Node node = null;
    while (!queue.isEmpty()) {
        node = queue.poll();
        node.left = generateNode(levelList.poll());
        node.right = generateNode(levelList.poll());
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
    return head;
}

public static Node generateNode(String val) {
    if (val == null) {
        return null;
    }
    return new Node(Integer.valueOf(val));
}
```

#### 3）将N叉树编码为二叉树

将N叉树某个节点的所有孩子 在转为二叉树时都遍历到这个节点的左数一直往右遍历，这样转换后保证唯一，转换后的二叉树所有节点的右孩子都是null

```java
// 多叉树结构
public static class Node {
    public int val;
    public List<Node> children;

    public Node() {
    }

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};

// 二叉树结构
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

// 只提交这个类即可
class Codec {
    // 编码为二叉树
    public TreeNode encode(Node root) {
        if (root == null) {
            return null;
        }
        //1、将多叉树的根节点放到二叉树的根节点上
        TreeNode head = new TreeNode(root.val);
        //2、递归调用将多叉树的根节点的孩子放到二叉树的左孩子一直往右遍历
        head.left = en(root.children);
        //二叉树的所有节点的右孩子一直为null
        return head;
    }

    private TreeNode en(List<Node> children) {
        TreeNode head = null;
        TreeNode cur = null;
        for (Node child : children) {
            TreeNode tNode = new TreeNode(child.val);
            if (head == null) {
                //1、head指向第一个孩子。整个for循环只执行一次，最终返回head
                head = tNode;
            } else {
                //2、将传来的所有孩子一直往右遍历
                cur.right = tNode;
            }
            cur = tNode;
            //3、这些孩子中也有孩子，递归调用将它们的孩子放到二叉树的左孩子一直往右遍历
            cur.left = en(child.children);
        }
        return head;
    }

    // 解码为多叉树
    public Node decode(TreeNode root) {
        if (root == null) {
            return null;
        }
        return new Node(root.val, de(root.left));
    }

    //生成多叉树传入节点的所有孩子
    public List<Node> de(TreeNode root) {
        List<Node> children = new ArrayList<>();
        //从根节点开始遍历
        while (root != null) {
            //1、二叉树的节点的左孩子是多叉树节点的第一个孩子
            Node cur = new Node(root.val, de(root.left));
            children.add(cur);
            //2、然后二叉树节点左孩子一直向右遍历，都是原节点的孩子们。
            root = root.right;
        }
        return children;
    }

}
```

#### 4）求二叉树最宽的层有多少节点

```java
public static int maxWidthNoMap(Node head) {
        if (head == null) {
            return 0;
        }
        Queue<Node> queue = new LinkedList<>();
        //1、根节点入队列
        queue.add(head);
        Node curEnd = head; // 当前层，最右节点是谁
        Node nextEnd = null; // 下一层，最右节点是谁
        int max = 0;           //最宽层的节点数
        int curLevelNodes = 0; // 当前层的节点数
        while (!queue.isEmpty()) {
            //2、弹出队列元素，并检查是否有左右孩子。若有，将它们依次设置为下一层的最右节点，随时记录
            Node cur = queue.poll();
            if (cur.left != null) {
                queue.add(cur.left);
                //为下一层做准备
                nextEnd = cur.left;
            }
            if (cur.right != null) {
                queue.add(cur.right);
                //为下一层做准备
                nextEnd = cur.right;
            }
            //3、弹出元素后，当前层节点数+1
            curLevelNodes++;
            //4、检验该节点是否为当前层最后一个节点。若是开始准备下一层，若不是继续弹出这层后面的节点
            if (cur == curEnd) {
                //5、当前层节点数与max比较
                max = Math.max(max, curLevelNodes);
                //6、为下一层做准备，下一层节点置为0，下一层的curEnd置为之前记录好的nextEnd
                curLevelNodes = 0;
                curEnd = nextEnd;
            }
        }
        return max;
    }
```

#### 5）在二叉树中找到一个节点的后继节点

```java
public static Node getSuccessorNode(Node node) {
    if (node == null) {
        return null;
    }
    //1、该节点有右子树，它右子树的最左节点就是该节点的后继节点
    if (node.right != null) {
        //指针指向它的右孩子，然后开始一直向左遍历
        node = node.right;
        while(node.left != null){
            node = node.left;
        }
        return node;
    } else { 
        //2、该节点无右子树，去找它爹
        // 该节点若作为它爹的左孩子，它爹就是该节点的后继节点；
        // 该节点若作为它爹的右孩子，那就找它爹的爹，一直往上遍历直到某个节点作为它爹的左孩子，这个爹即为所求。若到根节点都没找到，说明该节点没有后继节点
        Node parent = node.parent;
        while (parent != null && parent.right == node) { //parent为null说明遍历到根节点了
            // 当前节点若是它父亲节点右孩子，就一直往上遍历
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}
```

#### 6）附加题

题目：请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有3条折痕，从上到下依次是下折痕、下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。

例：N=1时，打印：down；N=2时，打印：down down up

思路：转换成中序遍历二叉树问题

```java
public static void printAllFolds(int N) {
    //打印第一层第一个节点的状态，第一个节点为凹
    process(1, N, true);
    System.out.println();
}
//中序遍历这N层的节点状态。i表示当前节点在第i层
public static void process(int i, int N, boolean down) {
    //检验该层是否超出N了
    if (i > N) {
        return;
    }
    //1、先打印该节点下一层的左孩子，左孩子为凹
    process(i + 1, N, true);
    //2、打印节点
    System.out.print(down ? "凹 " : "凸 ");
    //3、最后打印该节点下一层的右孩子，右孩子为凸
    process(i + 1, N, false);
}
```

### 12、class12--二叉树题目

#### 1）判断二叉树是否是完全二叉树

```java
//1、非递归套路
public static boolean isCBT1(Node head) {
    if (head == null) {
        return true;
    }
    LinkedList<Node> queue = new LinkedList<>();
    // 是否遇到过左右两个孩子不双全的节点
    boolean leaf = false;
    Node l = null;
    Node r = null;
    queue.add(head);
    while (!queue.isEmpty()) {
        head = queue.poll();
        l = head.left;
        r = head.right;
        if (  //1、遇到了不双全的节点之后，leaf置为true，又发现下一个节点不是叶节点，不满足完全二叉树。遇到了不双全的节点，后面的节点应该都是叶子节点
            (leaf && (l != null || r != null))
            ||
            //2、某个节点有右孩子没有左孩子，不满足完全二叉树
            (l == null && r != null)
        ) {
            return false;
        }
        if (l != null) {
            queue.add(l);
        }
        if (r != null) {
            queue.add(r);
        }
        if (l == null || r == null) {
            //3、该节点是不双全的，leaf置为true。之后判断后面的节点是否为叶子节点
            leaf = true;
        }
    }
    return true;
}

//2、递归套路
public static boolean isCBT2(Node head){
    return process(head).isCBT;
}
//封装指定节点构成树的信息
public static class Info{
    public boolean isFull; //该节点构成的树是否是满二叉树
    public boolean isCBT;  //该节点构成的树是否是完全二叉树
    public int height; //该节点构成的树的高度
    public Info(boolean iF,boolean iC,int h){
        isFull = iF;
        isCBT = iC;
        height = h;
    }
}
public static Info process(Node x){
    if(x == null){
        return new Info(true,true,0);
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    ////这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height,rightInfo.height) + 1;
    //当左右树为满二叉树，并且左右树的高等相等时，该树才是满二叉树
    boolean isFull = leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height;

    //该二叉树是否是完全二叉树，只有4种可能
    boolean isCBT = false;
    if(isFull){
        //1、这棵树是满二叉树
        isCBT = true;
    }else if(leftInfo.isCBT && rightInfo.isFull && leftInfo.height == rightInfo.height + 1){
        //2、左树是完全二叉树，右树是满二叉树，且左树高度 = 右树高度 + 1
        isCBT = true;
    }else if(leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height + 1){
        //3、左树是满二叉树，右树是满二叉树，且左树高度 = 右树高度 + 1
        isCBT = true;
    }else if(leftInfo.isFull && rightInfo.isCBT && leftInfo.height == rightInfo.height){
        //4、左树是满二叉树，右树是完全二叉树，且左树高度 = 右树高度
        isCBT = true;
    }

    return new Info(isFull,isCBT,height);
}
```

#### 2）判断二叉树是否是搜索二叉树

搜索二叉树的条件：
	1、每个节点的左树和右树都是搜索二叉树
	2、每个节点左树的最大值 < 该节点，右树的最小值 > 该节点

```java
//存放某个节点构成树中的最大值和最小值以及是否是搜索二叉树
public static class Info {
    public boolean isBST;
    public int max;
    public int min;

    public Info(boolean i,int ma,int mi){
        isBST = i;
        max = ma;
        min = mi;
    }
}

//主函数，判断二叉树是否是搜索二叉树
public static boolean isBST2(Node head){
    if(head == null){
        return true;
    }
    return process(head).isBST;
}

//返回指定节点的树的信息
public static Info process(Node x){
    if(x == null){
        return null;
    }
    //获取该节点左右树的信息
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //先设置该节点的构成树的最大值和最小值，值都先设置为该节点，然后和左右树的去比较
    //这里其实没太大用，主要用于递归传递信息
    int max = x.value;
    int min = x.value;
    if(leftInfo != null){
        max = Math.max(leftInfo.max, max);
        min = Math.min(leftInfo.min,min);
    }
    if(rightInfo != null){
        max = Math.max(rightInfo.max, max);
        min = Math.min(rightInfo.min,min);
    }

    boolean isBST = true;
    //1、检验该节点的左右树是否是搜索二叉树
    if(leftInfo != null && !leftInfo.isBST || rightInfo != null && !rightInfo.isBST){
        isBST = false;
    }

    //2、检验该节点的左树的最大值是否 < 该节点，右树的最小值是否 > 该节点
    if(leftInfo != null && leftInfo.max >= x.value || rightInfo != null && rightInfo.min <= x.value){
        isBST = false;
    }
    return new Info(isBST,max,min);
}
```

#### 3）判断二叉树是否是平衡二叉树

 平衡二叉树的条件：
      1、每个节点的左树和右树都是平衡二叉树
      2、每个节点左右树的高度之差<2

```java
//存放某个节点构成树的高度以及是否是平衡二叉树
public static class Info{
    public boolean isBalanced;
    public int height;

    public Info(boolean i,int h){
        isBalanced = i;
        height = h;
    }
}
//主函数，判断二叉树是否是平衡二叉树
public static boolean isBalanced2(Node head){
    return process(head).isBalanced;
}

//返回指定节点的树的信息
public static Info process(Node x){
    if(x == null){
        return new Info(true,0);
    }
    //获取左右子树的信息
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //该节点树的高度
    //这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    boolean isBalanced = true;
    //1、要满足左树和右树都是平衡二叉树
    if(!leftInfo.isBalanced || !rightInfo.isBalanced){
        isBalanced = false;
    }
    //2、该节点左右树的高度之差<2。满足这两条该节点的树才是平衡二叉树
    if(Math.abs(leftInfo.height - rightInfo.height) > 1){
        isBalanced = false;
    }

    return new Info(isBalanced,height);
}
```

#### 4）二叉树节点间的最大距离

题目：给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整颗二叉树的最大距离

最大距离只有如下可能：
      1、当最大距离不经过根节点时，最大距离 = 根节点的左子树最大距离 或者 根节点的右子树最大距离
      2、当最大距离经过根节点时，最大距离 = 根节点左子树的高度 + 根节点右子树的高度 + 1

```java
//存放某个节点构成树的节点间最大距离 和 这棵树的高度
public static class Info{
    public int maxDistance;
    public int height;
    public Info(int md,int h){
        maxDistance = md;
        height = h;
    }
}
//主函数，返回二叉树节点间的最大距离
public static int maxDistance2(Node head){
    return process(head).maxDistance;
}
//返回指定节点的树的信息
public static Info process(Node x){
    if(x == null){
        return new Info(0,0);
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    //1、最大距离不经过x节点，最大距离 = 根节点的左子树最大距离 或者 根节点的右子树最大距离
    int maxDistance = Math.max(leftInfo.maxDistance, rightInfo.maxDistance);
    //2、最大距离经过x节点，最大距离 = 根节点左子树的高度 + 根节点右子树的高度 + 1
    //maxDistance取3种结果中较大的那一个
    maxDistance = Math.max(maxDistance, leftInfo.height + rightInfo.height + 1);

    return new Info(maxDistance,height);
}
```

#### 5）判断二叉树是否是满二叉树

```java
//存放某个节点构成树是否为满树 和 这棵树的高度
public static class Info2 {
    public boolean isFull;
    public int height;

    public Info2(boolean f, int h) {
        isFull = f;
        height = h;
    }
}
//主函数，判断二叉树是否是满二叉树
public static boolean isFull2(Node head) {
    if (head == null) {
        return true;
    }
    return process2(head).isFull;
}
//返回指定节点的树的信息
public static Info2 process2(Node h) {
    if (h == null) {
        return new Info2(true, 0);
    }
    Info2 leftInfo = process2(h.left);
    Info2 rightInfo = process2(h.right);
    //这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    //该节点构成树是否为满二叉树的条件：左右子树都是满二叉树并且左右子树高度相等
    boolean isFull = leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height;
    return new Info2(isFull, height);
}
```

#### 6）求二叉树中最大搜索二叉子树的节点个数

题目：给定一棵二叉树的头节点head，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的节点个数。这道题说明整棵树不一定是搜索二叉树

```java
//节点构成树的相关信息
public static class Info {
    public int maxBSTSubtreeSize;  //当前节点构成树的最大搜索二叉子树的节点个数
    public int size; //当前节点构成树的所有节点个数。
    //注意：当 maxBSTSubtreeSize == size时，说明该节点构成树是搜索二叉树，这里我们不用单定义另一个变量isBST了
    public int max; //当前节点构成树的节点数值的最大值
    public int min; //当前节点构成树的节点数值的最小值

    public Info(int ms,int s,int ma,int mi){
        maxBSTSubtreeSize = ms;
        size = s;
        max = ma;
        min = mi;
    }
}
//主函数，返回二叉树中的最大搜索二叉子树的节点个数
public static int largestBSTSubtree(TreeNode head) {
    if(head == null){
        return 0;
    }
    return process(head).maxBSTSubtreeSize;
}
//返回指定节点构成树的信息
public static Info process(TreeNode x) {
    if (x == null) {
        //因为涉及到max和min，这里返回null而不返回对象，后面的分析过程中要注意空指针异常
        return null;
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //这里其实没太大用，主要用于递归传递信息
    int size = (leftInfo == null ? 0 : leftInfo.size) + (rightInfo == null ? 0 : rightInfo.size) + 1;
    int max = x.val;
    int min = x.val;
    if (leftInfo != null) {
        max = Math.max(max,leftInfo.max);
        min = Math.min(min,leftInfo.min);
    }
    if (rightInfo != null) {
        max = Math.max(max,rightInfo.max);
        min = Math.min(min,rightInfo.min);
    }
    //该节点构成树的maxBSTSubtreeSize只有3种可能
    //1、整棵树不是搜索二叉树，取左树的maxBSTSubtreeSize
    int p1 = -1;  //给个默认值-1，如果左树不存在，后面3种可能取最大时，-1会被舍弃
    if(leftInfo != null){
        p1 = leftInfo.maxBSTSubtreeSize;
    }
    //2、整棵树不是搜索二叉树，取右树的maxBSTSubtreeSize
    int p2 = -1;
    if(rightInfo != null){
        p2 = rightInfo.maxBSTSubtreeSize;
    }
    //3、整棵树是搜索二叉树
    int p3 = -1;
    //3.1、先判断左右子树是否是搜索二叉树
    boolean leftIsBST = leftInfo == null ? true : (leftInfo.maxBSTSubtreeSize == leftInfo.size);
    boolean rightIsBST = rightInfo == null ? true : (rightInfo.maxBSTSubtreeSize == rightInfo.size);
    if(leftIsBST && rightIsBST){
        //3.2、然后判断该节点的左树的最大值是否 < 该节点，右树的最小值是否 > 该节点
        boolean leftMaxLessX = leftInfo == null ? true : (leftInfo.max < x.val);
        boolean rightMinMoreX = rightInfo == null ? true : (x.val < rightInfo.min);
        if(leftMaxLessX && rightMinMoreX){
            //这样这棵树才是搜索二叉树
            int leftSize = leftInfo == null ? 0 : leftInfo.size;
            int rightSize = rightInfo == null ? 0 : rightInfo.size;
            p3 = leftSize + rightSize + 1;
        }

    }
    //4、该节点构成树的maxBSTSubtreeSize是上面3种可能的最大值
    int maxBSTSubtreeSize = Math.max(Math.max(p1,p2),p3);
    return new Info(maxBSTSubtreeSize, size, max, min);
}
```

### 13、class13--二叉树题目

#### 1）找到二叉树中的最大搜索二叉子树并返回头节点

题目：给定一棵二叉树的头节点head，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点。这道题说明整棵树不一定是搜索二叉树

```java
public static Node maxSubBSTHead2(Node head) {
    if(head == null){
        return null;
    }
    return process(head).maxSubBSTHead;
}
public static class Info{
    public Node maxSubBSTHead;   //该节点构成树中的最大搜索二叉子树的节点
    public int maxSubBSTSize;    //该节点构成树中的最大搜索二叉子树的节点个数
    public int max;             //该节点构成树的节点数值的最大值
    public int min;             //该节点构成树的节点数值的最小值
    public Info(Node mh,int ms,int ma,int mi){
        maxSubBSTHead = mh;
        maxSubBSTSize = ms;
        max = ma;
        min = mi;
    }
}
public static Info process(Node x){
    if(x == null){
        return null;
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    int max = x.value;
    int min = x.value;
    int maxSubBSTSize = 0;
    Node maxSubBSTHead = null;
    if(leftInfo != null){
        max = Math.max(max, leftInfo.max);
        min = Math.min(min, leftInfo.min);
        //1、先把左树的maxSubBSTHead作为整棵树的maxSubBSTHead
        maxSubBSTHead = leftInfo.maxSubBSTHead;
        maxSubBSTSize = leftInfo.maxSubBSTSize;
    }
    if(rightInfo != null){
        max = Math.max(max, rightInfo.max);
        min = Math.min(min, rightInfo.min);
        if(rightInfo.maxSubBSTSize > maxSubBSTSize){
            //2、若右树的maxSubBSTSize大于左树，就先把右树的maxSubBSTHead作为整棵树的maxSubBSTHead
            maxSubBSTHead = rightInfo.maxSubBSTHead;
            maxSubBSTSize = rightInfo.maxSubBSTSize;
        }
    }
    //3、假如整棵树是搜索二叉树
    boolean leftIsBST = leftInfo == null ? true : leftInfo.maxSubBSTHead == x.left;
    boolean rightIsBST = rightInfo == null ? true : rightInfo.maxSubBSTHead == x.right;
    //3.1、确保左右树都是搜索二叉树
    if(leftIsBST && rightIsBST){
        //3.2、然后判断该节点的左树的最大值是否 < 该节点，右树的最小值是否 > 该节点
        boolean leftMaxLessX = leftInfo == null ? true : (leftInfo.max < x.value);
        boolean rightMinMoreX = rightInfo == null ? true : (rightInfo.min > x.value);
        if(leftMaxLessX && rightMinMoreX){
            //这样这棵树才是搜索二叉树
            int leftSize = leftInfo == null ? 0 : leftInfo.maxSubBSTSize;
            int rightSize = rightInfo == null ? 0 : rightInfo.maxSubBSTSize;
            maxSubBSTSize = leftSize + rightSize + 1;
            maxSubBSTHead = x;
        }
    }
    return new Info(maxSubBSTHead,maxSubBSTSize,max,min);
}
```



#### 2）在二叉树中找到两个节点的最近公共祖先

题目：给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先

在某个节点构成的树中找到了a和b，才有可能找到最近公共祖先，然后去看他的左右子树是否找到了，若找到，即为所求，若没找到，这个节点就是所有

```java
public static Node lowestAncestor2(Node head, Node a, Node b){
    return process(head,a,b).ans;
}
public static class Info{
    public boolean findA;  //在该节点构成树中找到了a
    public boolean findB;  //在该节点构成树中找到了b
    public Node ans;       //在该节点构成树中找到了最低公共祖先
    public Info(boolean fa,boolean fb,Node a){
        findA = fa;
        findB = fb;
        ans = a;
    }
}
public static Info process(Node x,Node a,Node b){
    if(x == null){
        return new Info(false,false,null);
    }
    Info leftInfo = process(x.left, a, b);
    Info rightInfo = process(x.right, a, b);
    //当前节点为a，或者在左树右树中找到了a，说明在该节点构成树中找到了a
    boolean findA = (x == a) || leftInfo.findA || rightInfo.findA;
    //当前节点为b，或者在左树右树中找到了b，说明在该节点构成树中找到了b
    boolean findB = (x == b) || leftInfo.findB || rightInfo.findB;
    Node ans = null;
    //在这棵树中只有找到了a和b，这棵树中才存在最低公共祖先
    if(findA && findB){
        if(leftInfo.ans != null){
            //1、在左树找到了答案
            ans = leftInfo.ans;
        }else if(rightInfo.ans != null){
            //2、在右树找到了答案
            ans = rightInfo.ans;
        }else{
            //3、左右树都没找到答案，并且在这颗树中已经找到了a和b，那就说明x就是最低公共祖先
            ans = x;
        }
    }
    return new Info(findA,findB,ans);
}
```

#### 3）派对的最大快乐值

题目：公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板，除老板外，每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工，除基层员工外，每个员工都有一个或多个直接下级。这个公司现在要办party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下规则：1、如果某个员工来了，那么这员工的所有直接下级都不能来。2、派对的整体快乐值是所有到场员工快乐值的累加。3、你的目标是让派对的整体快乐值尽量大。

给定一个头节点boss，请返回派对的最大快乐值。

```java
public static int maxHappy2(Employee head){
    //取boss来或者不来中快乐值较大的
    return Math.max(process(head).yes,process(head).no);
}
public static class Info{
    public int yes;  //该节点来的时候的最大快乐值
    public int no;   //该节点不来的时候的最大快乐值
    public Info(int y,int n){
        yes = y;
        no = n;
    }
}
public static Info process(Employee x){
    if(x == null){
        return new Info(0,0);
    }
    int yes = x.happy;
    int no = 0;
    for (Employee e : x.nexts) {
        Info info = process(e);
        //1、当前节点来，它的直接下级一定不来。当前节点来时的最大快乐值 = 所有直接下级不来时的最大快乐值
        yes += info.no;
        //2、当前节点不来，它的直接下级可能来可能不来。当前节点来时的最大快乐值 = max（所有直接下级不来时的最大快乐值，所有直接下级来时的最大快乐值）
        no += Math.max(info.yes, info.no);
    }
    return new Info(yes,no);
}
```

### 14、class14--贪心算法题目

贪心算法类的题目一般用到排序和堆

#### 1）拼接所有字符串产生字典顺序最小的字符串

题目：给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果

贪心策略：要满足字符串拼接的字典序 a+b <= b+a

```java
public static class MyComparator implements Comparator<String> {
    @Override
    public int compare(String a, String b) {
        //比较器规则：字符串拼接 a+b <= b+a
        return (a + b).compareTo(b + a);
    }
}

public static String lowestString2(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    Arrays.sort(strs, new MyComparator());
    String res = "";
    for (int i = 0; i < strs.length; i++) {
        res += strs[i];
    }
    return res;
}
```

#### 2）贪心算法题目二

题目：一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回最多的宣讲场次

贪心策略：每一次都选结束时间最早的

```java
//比较器：会议结束时间早的排在前面
public static class ProgramComparator implements Comparator<Program> {
    @Override
    public int compare(Program o1, Program o2) {
        return o1.end - o2.end;
    }

}
// 会议的开始时间和结束时间，都是数值，不会 < 0
public static int bestArrange2(Program[] programs) {
    Arrays.sort(programs, new ProgramComparator());
    int timeLine = 0;
    int result = 0;
    //1、依次遍历每一个会议，结束时间早的会议先遍历
    for (int i = 0; i < programs.length; i++) {
        if (timeLine <= programs[i].start) {
            //2、当前会议的开始时间 >= 上一个会议结束时间，这个会议才能加入
            result++;
            timeLine = programs[i].end;
        }
    }
    return result;
}
```

#### 3）分金条的最小花费

题目：一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管怎么切，都要花费20个铜板，一群人想整分整块金条，怎么分最省铜板？例如，给定数组[10,20,30]，代表一共三个人，整块金条长度为60，金条要分成10,20,30三个部分。如果先把60的金条分成10和50，花费60,；再把长度为50的金条分成20和30，花费50；一共花费110铜板。但如果先把长度60的金条分成30和30，花费60；再把长度为30的金条分成10和20，花费30；一共花费90铜板。输入一个数组，返回分割的最小代价

贪心策略：利用哈夫曼编码思想来切金条

```java
public static int lessMoney2(int[] arr) {
    //1、用小根堆来存放数组元素，从小到大排序
    PriorityQueue<Integer> pQ = new PriorityQueue<>();
    for (int i = 0; i < arr.length; i++) {
        pQ.add(arr[i]);
    }
    int sum = 0;
    int cur = 0;
    while (pQ.size() > 1) {
        //2、只要小根堆中元素超过1个，就弹出前两个，然后相加后再放回小根堆里，自动重新排序
        cur = pQ.poll() + pQ.poll();
        sum += cur;
        pQ.add(cur);
    }
    return sum;
}
```

#### 4）做项目的最大收益问题 IPO

题目：输入：正数数组costs、正数数组profits、正数K、正数M。costs[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费之后还能挣到的钱（利润），K表示你只能串行地最多做k个项目，M表示你初始的资金。说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。输出：你最后获得的最大钱数。

贪心策略：小根堆，项目花费小的放前面；大根堆，纯利润高的放前面

```java
//项目类
public static class Program{
    public int p;  //纯利润
    public int c;  //项目的花费
    public Program(int p,int c){
        this.p = p;
        this.c = c;
    }
}
//比较器，项目花费小的放前面
public static class MinCostComparator implements Comparator<Program>{
    @Override
    public int compare(Program p1,Program p2){
        return p1.c - p2.c;
    }
}
//比较器，纯利润高的放前面
public static class MaxProfitComparator implements Comparator<Program>{
    @Override
    public int compare(Program p1,Program p2){
        return p2.p - p1.p;
    }
}
public static int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    //小根堆，项目花费小的放前面
    //也可以用排好序的数组来存放
    PriorityQueue<Program> minCostQ = new PriorityQueue<>(new MinCostComparator());
    //大根堆，纯利润高的放前面
    PriorityQueue<Program> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
    //1、现将所有项目放进小根堆，自动按项目花费排序，小的放上面
    for(int i = 0; i < profits.length; i++){
        minCostQ.add(new Program(profits[i],capital[i]));
    }
    //2、开始进行选择项目，最多选k个
    for(int i = 0; i < k;i++){
        while(!minCostQ.isEmpty() && minCostQ.peek().c <= w){
            //3、将小跟堆中所有项目花费<=k的全部放到大根堆中
            maxProfitQ.add(minCostQ.poll());
        }
        //4、注意若经过调整后，大根堆仍然没有元素，说明没有符合条件的项目了，返回之前的最终资本
        if(maxProfitQ.isEmpty()){
            return w;
        }
        //5、最终资本=大根堆顶部即利润最高的项目 + 之前的资本
        w += maxProfitQ.poll().p;
    }
    return w;
}
```

#### 5）贪心算法题目五

题目：给定一个字符串str，只由' X '和' . '两种字符构成。' X '表示墙，不能放灯，也不需要点亮；' . '表示居民点，可以放灯，需要点亮。如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮。返回如果点亮str中所有需要点亮的位置，至少需要几盏灯。

贪心策略：i，i+1，i+2是点时，灯放在i+1处。（这题贪心策略不太明显。。）

```java
public static int minLight2(String road) {
    char[] str = road.toCharArray();
    int i = 0;
    int light = 0;
    while (i < str.length) {
        //1、如果i位置是X不用放灯，去看下一个位置
        if (str[i] == 'X') {
            i++;
        } else {
            //2、i位置是点，无论越界，i+1,i+2上是点还是X，都要放灯
            light++;
            if (i + 1 == str.length) {
                //下一个位置越界，结束循环
                break;
            } else {
                if (str[i + 1] == 'X') {
                    //3、i位置是点，i+1位置是X，i上放灯，然后去看i+2位置
                    i = i + 2;
                } else {
                    //4、i位置是点，i+1位置是点，无论i+2是点还是X，i+1位置都要放灯(i+2是X时，i+1和i哪里放灯都行)，然后去看i+3位置
                    i = i + 3;
                }
            }
        }
    }
    return light;
}
```

### 15、class15--并查集题目

#### 1）省份数量

题目：有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中 省份 的数量

```java
public static int findCircleNum(int[][] isConnected) {
    int N = isConnected.length;
    UnionFind unionFind = new UnionFind(N);
    //因为矩阵是对称的，所以只需关注上三角形
    for(int i = 0; i < N; i++){
        for(int j = i+1; j < N; j++){
            if(isConnected[i][j] == 1){
                //i，j直接相连，将两个集合合并
                unionFind.union(i,j);
            }
        }
    }
    return unionFind.sets();
}

public static class UnionFind{
    //parent[i] = k   -->  i的父亲是k
    private int[] parent; 
    //size[i] = k ： 如果i是代表节点，size[i]才有意义，否则无意义
    //i所在的集合大小是多少
    private int[] size;   
    //辅助结构，用来find过程中的路径压缩
    private int[] help;
    //一共有多少个集合
    private int sets;

    public int sets(){
        return sets;
    }

    public UnionFind(int N){
        parent = new int[N];
        size = new int[N];
        help = new int[N];
        sets = N;
        //初始化：将所有节点的父节点都设置为自己，并将所有集合的大小设置为1
        for(int i = 0; i < N; i++){
            parent[i] = i;
            size[i] = 1;
        }
    }

    //从i开始一直往上，往上到不能再往上，返回代表节点
    //这个过程要做路径压缩，即把沿途上的节点父节点都改成顶端的代表节点
    public int find(int i){
        int hi = 0;
        //1、检查节点，找到代表节点
        while(i != parent[i]){
            //1.1、将沿途节点存放到help数组
            help[hi] = i;
            hi++;
            //1.2、检查上一个节点
            i = parent[i];
        }
        //2、路径压缩
        for(hi--; hi >=0; hi--){
            parent[help[hi]] = i;
        }
        return i;
    }

    //两个集合合并，小的合在大的上
    public void union(int i,int j){
        int f1 = find(i);
        int f2 = find(j);
        if(f1 != f2){
            if(size[f1] >= size[f2]){
                parent[f2] = f1;
                size[f1] += size[f2];
                size[f2] = 0;
            } else{
                parent[f1] = f2;
                size[f2] += size[f1];
                size[f1] = 0;
            }
            sets--;
        }
    }
}
```

#### 2）岛屿数量

题目：给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

```java
public static int numIslands(char[][] grid) {
    int row = grid.length;
    int col = grid[0].length;
    UnionFind uf = new UnionFind(grid);

    //检查某个节点的左边和上边就能都检查完

    //先判断第一行
    for(int i = 1;i < col; i++){
        if(grid[0][i] == '1' && grid[0][i-1] == '1'){
            //检查当前节点和左边节点
            uf.union(0,i-1,0,i);
        }
    }
    //再判断第一列
    for(int j = 1; j < row; j++){
        if(grid[j][0] == '1' && grid[j-1][0] == '1'){
            //检查当前节点和上边节点
            uf.union(j-1,0,j,0);
        }
    }
    //先判断玩第一行和第一列，避免边界讨论
    //判断剩下部分
    for(int i = 1; i < row; i++){
        for(int j = 1; j < col; j++){
            if(grid[i][j] == '1'){
                //检查当前节点和左边节点
                if(grid[i][j-1] == '1'){
                    uf.union(i,j,i,j-1);
                }
                //检查当前节点和上边节点
                if(grid[i-1][j] == '1'){
                    uf.union(i,j,i-1,j);
                }
            }
        }
    }

    return uf.sets();

}

public static class UnionFind{
    private int[] parent;   //每个节点的代表节点
    private int[] size;     //这个集合的大小
    private int[] help;     //路径压缩时用的辅助数组
    private int sets;       //集合的数量
    private int col;        //二维数组的列数

    public UnionFind(char[][] grid){
        sets = 0;
        col = grid[0].length;
        int row = grid.length;
        int len = row * col;
        parent = new int[len];
        size = new int[len];
        help = new int[len];
        for(int r = 0; r < row; r++){
            for(int c = 0; c < col; c++){
                if(grid[r][c] == '1'){
                    int i = index(r,c);
                    parent[i] = i;
                    size[i] = 1;
                    sets++;
                }
            }
        }
    }

    //将二维数组的下标转成一维数组下标
    public int index(int r,int c){
        return r*col + c;
    }

    //并
    public void union(int r1,int c1,int r2,int c2){
        int i1 = index(r1,c1);
        int i2 = index(r2,c2);
        int f1 = find(i1);
        int f2 = find(i2);
        if(f1 != f2){
            if(size[f1] >= size[f2]){
                parent[f2] = f1;
                size[f1] += size[f2];
                size[f2] = 0;
            }else {
                parent[f1] = f2;
                size[f2] += size[f1];
                size[f1] = 0;
            }
            sets--;
        }
    }

    //查
    public int find(int i){
        int hi = 0;
        while(i != parent[i]){
            //检查上一个点
            i = parent[i];
            //记录沿途的点
            help[hi++] = i;
        }
        //路径压缩
        for(hi--; hi >= 0; hi--){
            parent[help[hi]] = i;
        }
        return i;
    }

    //集
    public int sets(){
        return this.sets;
    }

} 
```

### 16、class16--图

#### 1）图的宽度优先遍历（BFS）

```java
public static void bfs(Node start) {
    if (start == null) {
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> set = new HashSet<>();    //用来防止重复节点继续入队列
    queue.add(start);
    set.add(start);
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        System.out.println(cur.value);
        for (Node next : cur.nexts) {
            if (!set.contains(next)) {
                //set里面没有才能进队列
                set.add(next);
                queue.add(next);
            }
        }
    }
}
```

#### 2）图的深度优先遍历（DFS）

```java
public static void dfs(Node start) {
    if (start == null) {
        return;
    }
    Stack<Node> stack = new Stack<>();      //栈里面存的是目前的整条路径
    HashSet<Node> set = new HashSet<>();    //用来记录已经打印过的节点，避免重复打印
    stack.add(start);
    set.add(start);
    //压入栈就打印
    System.out.println(start.value);
    while (!stack.isEmpty()) {
        //准备遍历当前弹出节点的所有邻接节点
        Node cur = stack.pop();
        for (Node next : cur.nexts) {
            if (!set.contains(next)) {
                //只要set集合中没有记录该邻接节点，就将当前节点和该邻接节点压入栈，并且结束循环不去检查其他邻接节点了
                stack.push(cur);
                stack.push(next);
                set.add(next);
                //压入栈就打印
                System.out.println(next.value);
                break;
            }
        }
    }
}
```

#### 3）图的拓扑排序

返回入度为0的点，然后将这个点和相关边删除，再返回入度为0的点，依次类推，形成拓扑排序。

注意：拓扑排序一般不唯一

```java
public static List<Node> sortedTopology(Graph graph) {
    // key->某个节点  value->这个节点的入度
    HashMap<Node, Integer> inMap = new HashMap<>();
    // 只有入度为0的点，才进入这个队列
    Queue<Node> zeroInQueue = new LinkedList<>();

    for (Node node : graph.nodes.values()) {
        //1、将所有节点和入度信息存入inMap
        inMap.put(node, node.in);
        if (node.in == 0) {
            //2、若节点入度为0，存入队列
            zeroInQueue.add(node);
        }
    }
    List<Node> result = new ArrayList<>();
    while (!zeroInQueue.isEmpty()) {
        //3、弹出队列第一个节点，并加入result
        Node cur = zeroInQueue.poll();
        result.add(cur);
        //4、删除该节点，就是把它所有邻接节点的入度都减1
        for (Node next : cur.nexts) {
            //邻接节点入度减1
            inMap.put(next, inMap.get(next) - 1);
            if (inMap.get(next) == 0) {
                zeroInQueue.add(next);
            }
        }
    }
    return result;
}
```

#### 4）最小生成树算法Kruskal

1、总是从权值最小的边开始考虑，依次考察权值依次变大的边。

2、当前的边要么进入最小生成树的集合，要么丢弃。

3、如果当前的边进入最小生成树的集合中不会形成环，就要当前边。

4、如果会形成环，就不要当前边。

5、考察完所有边之后，最小生成树的集合也得到了。

```java
//并查集
public static class UnionFind {
    // key 某一个节点， value key节点往上的节点
    private HashMap<Node, Node> fatherMap;
    // key 某一个集合的代表节点, value key所在集合的节点个数
    private HashMap<Node, Integer> sizeMap;

    public UnionFind() {
        fatherMap = new HashMap<Node, Node>();
        sizeMap = new HashMap<Node, Integer>();
    }
	
    //使所有节点各自成为集合
    public void makeSets(Collection<Node> nodes) {
        fatherMap.clear();
        sizeMap.clear();
        for (Node node : nodes) {
            fatherMap.put(node, node);
            sizeMap.put(node, 1);
        }
    }

    private Node findFather(Node n) {
        Stack<Node> path = new Stack<>();
        while(n != fatherMap.get(n)) {
            path.add(n);
            n = fatherMap.get(n);
        }
        while(!path.isEmpty()) {
            fatherMap.put(path.pop(), n);
        }
        return n;
    }

    public boolean isSameSet(Node a, Node b) {
        return findFather(a) == findFather(b);
    }

    public void union(Node a, Node b) {
        if (a == null || b == null) {
            return;
        }
        Node aDai = findFather(a);
        Node bDai = findFather(b);
        if (aDai != bDai) {
            int aSetSize = sizeMap.get(aDai);
            int bSetSize = sizeMap.get(bDai);
            if (aSetSize <= bSetSize) {
                fatherMap.put(aDai, bDai);
                sizeMap.put(bDai, aSetSize + bSetSize);
                sizeMap.remove(aDai);
            } else {
                fatherMap.put(bDai, aDai);
                sizeMap.put(aDai, aSetSize + bSetSize);
                sizeMap.remove(bDai);
            }
        }
    }
}
//边权重从小到大排序
public static class EdgeComparator implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight - o2.weight;
    }
}

public static Set<Edge> kruskalMST(Graph graph) {
    //1、将所有节点先各自称为集合
    UnionFind unionFind = new UnionFind();
    unionFind.makeSets(graph.nodes.values());
    //2、小根堆存入所有边，边的权重由小到大排序
    PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
    for (Edge edge : graph.edges) { // M 条边
        priorityQueue.add(edge);  // O(logM)
    }
    //用于收集最后最小生成树的边
    Set<Edge> result = new HashSet<>();
    while (!priorityQueue.isEmpty()) { // M 条边
        //3、按权重从小到大弹出边
        Edge edge = priorityQueue.poll(); // O(logM)
        if (!unionFind.isSameSet(edge.from, edge.to)) { // O(1)
            //4、只要这条边的from和to不是一个集合，就不会形成环。
            // 边集合加入这条边，合并两个节点
            result.add(edge);
            unionFind.union(edge.from, edge.to);
        }
    }
    return result;
}
```

#### 5）最小生成树算法Prim

1、可以从任意节点出发来寻找最小生成树

2、某个点加入到被选取的点中后，解锁这个点出发的所有新的边

3、在所有解锁的边中选最小的边，然后看着这个边会不会形成环

4、如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3

5、如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2

6、当所有点都被选取，最小生成树就得到了

```java
//边权重从小到大排序
public static class EdgeComparator implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight - o2.weight;
    }
}   
public static Set<Edge> primMST(Graph graph) {
    // 解锁的边进入小根堆
    PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
    // 哪些点被解锁出来了
    HashSet<Node> nodeSet = new HashSet<>();
    // 依次挑选的的边在result里
    Set<Edge> result = new HashSet<>();
    // 随便挑了一个点，node 是开始点
    for (Node node : graph.nodes.values()) {
        if (!nodeSet.contains(node)) {
            //1、这个点被解锁了
            nodeSet.add(node);
            for (Edge edge : node.edges) { 
                //2、解锁这个点相连的边，按边的权重放入小根堆中
                priorityQueue.add(edge);
            }
            while (!priorityQueue.isEmpty()) {
                //3、弹出解锁的边中权重最小的
                Edge edge = priorityQueue.poll();
                //4、检查这条边的to节点
                Node toNode = edge.to; 
                if (!nodeSet.contains(toNode)) { // 点集合中没有，说明这是新的点
                    //5、这个点被解锁了，这条边加入result集合
                    nodeSet.add(toNode);
                    result.add(edge);
                    for (Edge nextEdge : toNode.edges) {
                        //6、解锁这个点相连的边
                        priorityQueue.add(nextEdge);
                    }
                }
            }
        }
        // break;
    }
    return result;
}
```

#### 6）从一个顶点到其余各顶点的最短路径算法Dijkstra

```java
public static HashMap<Node, Integer> dijkstra1(Node from) {
    //存放from节点到其他节点的距离(以下简称距离)
    HashMap<Node, Integer> distanceMap = new HashMap<>();
    distanceMap.put(from, 0);
    // 存放已经确定最短路径的节点
    HashSet<Node> selectedNodes = new HashSet<>();
    //1、先获取没有确定最短路径节点中距离最小的节点
    Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
    while (minNode != null) {
        //2、获取当前map中记录的距离
        int distance = distanceMap.get(minNode);
        for (Edge edge : minNode.edges) {
            //3、考察这个节点的所有边的to节点
            Node toNode = edge.to;
            if (!distanceMap.containsKey(toNode)) {
                //4、若to节点在map中没有数据，说明距离是正无穷，给to节点赋新值distance + edge.weight
                distanceMap.put(toNode, distance + edge.weight);
            } else { // toNode
                //5、若to节点在map中有数据，to节点距离取 map中数据和这次数据distance + edge.weight的较小值
                distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
            }
        }
        //6、这个节点minNode已经确定，以后不在考虑，准备下一个没有确定最短路径节点中距离最小的节点
        selectedNodes.add(minNode);
        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
    }
    return distanceMap;
}

public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
    Node minNode = null;
    int minDistance = Integer.MAX_VALUE;
    for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
        Node node = entry.getKey();
        int distance = entry.getValue();
        if (!touchedNodes.contains(node) && distance < minDistance) {
            minNode = node;
            minDistance = distance;
        }
    }
    return minNode;
}
```

#### 7）从一个顶点到其余各顶点的最短路径算法Dijkstra--加强堆

```java
public static class NodeRecord {
    public Node node;
    public int distance;

    public NodeRecord(Node node, int distance) {
        this.node = node;
        this.distance = distance;
    }
}

public static class NodeHeap {
    private Node[] nodes; // 实际的堆结构
    // key 某一个node， value 上面堆中的位置
    private HashMap<Node, Integer> heapIndexMap;
    // key 某一个节点， value 从源节点出发到该节点的目前最小距离
    private HashMap<Node, Integer> distanceMap;
    private int size; // 堆上有多少个点

    public NodeHeap(int size) {
        nodes = new Node[size];
        heapIndexMap = new HashMap<>();
        distanceMap = new HashMap<>();
        size = 0;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    // 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance
    // 判断要不要更新，如果需要的话，就更新
    public void addOrUpdateOrIgnore(Node node, int distance) {
        //update
        if (inHeap(node)) {
            distanceMap.put(node, Math.min(distanceMap.get(node), distance));
            insertHeapify(heapIndexMap.get(node));
        }
        //add
        if (!isEntered(node)) {
            nodes[size] = node;
            heapIndexMap.put(node, size);
            distanceMap.put(node, distance);
            insertHeapify(size++);
        }
    }

    public NodeRecord pop() {
        NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
        //将堆顶元素与堆最后一个元素交换位置，然后删除最后一个元素，再进行heapify，实现堆顶元素弹出
        swap(0, size - 1);
        heapIndexMap.put(nodes[size - 1], -1);
        distanceMap.remove(nodes[size - 1]);
        // free C++同学还要把原本堆顶节点析构，对java同学不必
        nodes[size - 1] = null;
        heapify(0, --size);
        return nodeRecord;
    }

    //将index上的数进行向上调整
    private void insertHeapify(int index) {
        while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    //将index上的数进行向下调整
    private void heapify(int index, int size) {
        int left = index * 2 + 1;
        while (left < size) {
            //选左右孩子中较小的
            int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
                ? left + 1
                : left;
            //选孩子和爹中较小的
            smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
            if (smallest == index) {
                break;
            }
            swap(smallest, index);
            index = smallest;
            left = index * 2 + 1;
        }
    }

    private boolean isEntered(Node node) {
        //只要反向索引表中有数据，不管是-1还是其他的，说明这个节点已经进入过堆了
        return heapIndexMap.containsKey(node);
    }

    private boolean inHeap(Node node) {
        //若反向索引表中的值为-1，说明不在堆中，已经弹出了
        return isEntered(node) && heapIndexMap.get(node) != -1;
    }

    private void swap(int index1, int index2) {
        heapIndexMap.put(nodes[index1], index2);
        heapIndexMap.put(nodes[index2], index1);
        Node tmp = nodes[index1];
        nodes[index1] = nodes[index2];
        nodes[index2] = tmp;
    }
}

// 改进后的dijkstra算法
// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回
public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
    NodeHeap nodeHeap = new NodeHeap(size); //加强堆
    //1、将head节点添加到加强堆中
    nodeHeap.addOrUpdateOrIgnore(head, 0);
    HashMap<Node, Integer> result = new HashMap<>(); //用于收集最后的结果
    while (!nodeHeap.isEmpty()) {
        //2、弹出加强堆中的节点，它的距离是最小的
        NodeRecord record = nodeHeap.pop();
        Node cur = record.node;
        int distance = record.distance;
        for (Edge edge : cur.edges) {
            //3、处理这个节点的所有边的to节点
            //若加强堆中没有，add。若此时的距离edge.weight + distance < 加强堆中的距离，update。若此时距离 >=加强堆中距离，ignore
            nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
        }
        //4、该节点处理完成，以后不在讨论，放入到结果集
        result.put(cur, distance);
    }
    return result;
}
```

### 17、class17--暴力递归

#### 1）汉诺塔问题

```java
public static void hanoi2(int n) {
    if (n > 0) {
        func(n, "left", "right", "mid");
    }
}

public static void func(int N, String left, String right, String mid) {
    if (N == 1) {
        // base case，只有一个圆盘时，只需将它从左转移到右边
        System.out.println("Move 1 from " + left + " to " + right);
    } else {
        //1、将左边的n-1个圆盘借助right放到mid上
        func(N - 1, left, mid, right);
        //2、将左边最后一个圆盘从left放到right上
        System.out.println("Move " + N + " from " + left + " to " + right);
        //3、将mid上放好的n-1个圆盘借助left放到right上
        func(N - 1, mid, right, left);
    }
}
```

#### 2）打印一个字符串的全部子序列

```java
public static List<String> subs(String s) {
    char[] str = s.toCharArray();
    String path = "";
    List<String> ans = new ArrayList<>();
    process1(str, 0, ans, path);
    return ans;
}

	/**
     * 递归过程
     * @param str   固定参数，给定初始的字符串
     * @param index 来到了str[index]字符，index是当前位置
     * @param ans   将index及以后的所有生成的子序列放到ans里
     * @param path   path存放的是str[0..index-1]上的决定
     */
public static void process1(char[] str, int index, List<String> ans, String path) {
    if (index == str.length) {
        //若index越界，path就是最终结果
        ans.add(path);
        return;
    }
    //每个字符只有两个可能
    //1、不要index位置的字符
    process1(str, index + 1, ans, path);
    //2、要index位置的字符
    process1(str, index + 1, ans, path + String.valueOf(str[index]));
}
```

#### 3）打印一个字符串的全部排列

```java
public static List<String> permutation2(String s) {
    List<String> ans = new ArrayList<>();
    if (s == null || s.length() == 0) {
        return ans;
    }
    char[] str = s.toCharArray();
    g1(str, 0, ans);
    return ans;
}
//将str的所有字符从index开始全排列放到ans中
public static void g1(char[] str, int index, List<String> ans) {
    if (index == str.length) {
        //index越界，表示调整好了一种可能，将调整好的str放入ans中
        ans.add(String.valueOf(str));
    } else {
        for (int i = index; i < str.length; i++) {
            //1、将index上的字符与i上的字符互换。这样确保每个字符都有在index位置的情况
            swap(str, index, i);
            //2、将str的所有字符从index+1开始全排列放到ans中
            g1(str, index + 1, ans);
            //3、恢复现场。准备原index上的字符与i++上的字符互换
            //如果不恢复现场，一定会出现重复遗漏现象
            swap(str, index, i);
        }
    }
}
```

#### 4）使用递归函数逆序栈

给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数

思想：拿出一个元素，剩余元素递归，再把拿出的元素放到最后的位置

```java
//将栈中元素翻转
public static void reverse(Stack<Integer> stack){
    if(stack.isEmpty()){
        return;
    }
    //1、获取栈底元素
    int last = f(stack);
    //2、将栈中剩余元素翻转
    reverse(stack);
    //3、在将栈底元素放回栈顶
    stack.push(last);
}
//将栈底元素移除并返回
//递归过程中到最后一层才知道栈底元素last，然后一层一层返回，这样每层都知道last了。然后将每层弹出的栈顶元素result在放回去
public static int f(Stack<Integer> stack) {
    //1、弹出栈顶元素
    int result = stack.pop();
    if(stack.isEmpty()){
        //弹出元素后栈为空，说明这个元素是栈底元素，返回
        return result;
    } else{
        //2、获取此时栈底元素
        int last = f(stack);
        //3、将之前弹出的元素再放回栈中
        stack.push(result);
        return last;
    }
}
```

### 18、class18--从暴力递归到动态规划

#### 1）机器人达到指定位置方法数

题目：假设有排成一行的N个位置，记为1~N，N一定大于或等于2，开始时机器人在其中的M位置上（M一定是1~N中的一个），如果机器人来到1位置，那么下一步只能往右来到2位置；如果机器人来到N位置，那么下一步只能往左来到N-1位置；如果机器人来到中间位置，那么下一步可以往左走或者往右走；规定机器人必须走K步，最终能来到P位置（P也是1~N中的一个）的方法有多少种。给定四个删除N、M、K、P，返回方法数

```java
//1、暴力递归
public static int ways1(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
        return -1;
    }
    return process1(start, K, aim, N);
}

public static int process1(int cur, int rest, int aim, int N) {
    //base case
    if (rest == 0) {
        //若已经走完K步了，cur与aim位置一样，方法数+1，否则为0
        return cur == aim ? 1 : 0;
    }
    if (cur == 1) {
        //1、当前机器人在1位置，它只能往2位置走
        return process1(2, rest - 1, aim, N);
    } else if (cur == N) {
        //2、当前机器人在N位置，它只能往N-1位置走
        return process1(N - 1, rest - 1, aim, N);
    } else {
        //3、当前机器人在中间位置，可以往左走，也可以往右走
        return process1(cur - 1, rest - 1, aim, N) + process1(cur + 1, rest - 1, aim, N);
    }
}

//2、动态规划
public static int ways3(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
        return -1;
    }
    //建立dp表，第0行不参与赋值。行代表当前机器人位置，列代表机器人还剩几步可以走
    int[][] dp = new int[N + 1][K + 1];
    //1、将第一列初始化，只需将dp[aim][0] = 1，其他为0
    dp[aim][0] = 1;
    for (int rest = 1; rest <= K; rest++) {
        //2、处理第一行
        dp[1][rest] = dp[2][rest - 1];
        //3、处理中间行
        for (int cur = 2; cur <= N - 1; cur++) {
            dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
        }
        //4、处理最后一行
        dp[N][rest] = dp[N-1][rest-1];
    }
    //5、返回dp表中的位置dp[start][K]为结果
    return dp[start][K];
}
```

#### 2）排成一条线的纸牌博弈问题

题目：给定一个整型数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。

```java
//1、暴力递归
public static int win1(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    //1、先手玩家最终获得的分数
    int first = f1(arr, 0, arr.length - 1);
    //2、后手玩家最终获得的分数
    int second = g1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}
//先手从L到R上选择最优的解
public static int f1(int[] arr, int L, int R) {
    //base case
    if (L == R) {
        return arr[L];
    }
    //1、先手挑最左边的牌后得到最优解
    int p1 = arr[L] + g1(arr, L + 1, R);
    //2、先手挑最右边的牌后得到最优解
    int p2 = arr[R] + g1(arr, L, R - 1);
    //3、先手选两种可能中最优的
    return Math.max(p1, p2);
}
//后手从L到R上选择最优的解
public static int g1(int[] arr, int L, int R) {
    //base case
    if (L == R) {
        return 0;
    }
    //1、先手的玩家先挑走了最左边的牌
    int p1 = f1(arr, L + 1, R);
    //2、先手的玩家先挑走了最右边的牌
    int p2 = f1(arr, L, R - 1);
    //3、后手玩家只能选两种可能中最差的，因为先手玩家一定是给后手剩下最差的
    return Math.min(p1, p2);
}

//2、动态规划
public static int win3(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int N = arr.length;
    //建立两张dp表相互依赖。行代表L最左边的值，列代表R最右边的值
    int fDp[][] = new int[N][N];
    int gDp[][] = new int[N][N];
    //1、先将f表对角线初始化。g表对角线都是0，默认初始化好了
    for (int i = 0; i < N; i++) {
        fDp[i][i] = arr[i];
    }
    //2、开始从对角线上面一条对角线开始往上面对角线填，两张表交替填写对角线上的值
    for (int col = 1; col < N; col++) {
        int L = 0;
        int R = col;
        while (R < N) {  //列c 比行r 先越界
            //fDp表和gDp表用来替代之前的递归过程
            fDp[L][R] = Math.max(arr[L] + gDp[L + 1][R], arr[R] + gDp[L][R - 1]);
            gDp[L][R] = Math.min(fDp[L + 1][R], fDp[L][R - 1]);
            //准备填写下一个位置两个表的值
            L++;
            R++;
        }
    }
    //3、返回先手最优和后手最优中值较大的数
    return Math.max(fDp[0][N - 1], gDp[0][N - 1]);
}
```

### 19、class19--从暴力递归到动态规划

#### 1）背包装最大价值问题

题目：给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？

```java
/**
     * 1、暴力递归
     *
     * @param w   i号物品的重量，没有负数
     * @param v   i号物品的价值，没有负数
     * @param bag 背包容量，装的物品不能超过这个重量
     * @return 返回不超重情况下，能够得到的最大价值
     */
public static int maxValue(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || w.length == 0) {
        return 0;
    }
    return process(w, v, 0, bag);
}
//此时背包还能装rest重量的物品，返回从index物品开始往后剩下物品的最大价值
//从0到w.length递归调用
public static int process(int[] w, int[] v, int index, int rest) {
    if (index == w.length) {
        return 0;
    }
    //1、不选当前物品
    int p1 = process(w, v, index + 1, rest);
    //2、选当前物品
    //注意：判断选完当前物品后是否超重，若超重，从index开始往后剩下物品的最大价值为0；若不超重，v[index] + 从index+1开始往后剩下物品的最大价值
    int p2 = rest - w[index] < 0 ? 0 : v[index] + process(w, v, index + 1, rest - w[index]);
    //3、返回价值较大的选择
    return Math.max(p1, p2);

}

//2、动态规划
public static int dp(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || w.length == 0) {
        return 0;
    }
    int N = w.length;
    //1、建立dp表，行为当前物品的下标0~index，列为背包的剩余容量0~bag，bag为负数时单独处理
    int[][] dp = new int[N + 1][bag + 1];
    //2、初始化dp表，N行全部为0，已经初始化好了
    //3、填表，从下往上填，因为index行依赖index+1行
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= bag; rest++) {
            //4、不选当前物品
            int p1 = dp[index + 1][rest];
            //5、选当前物品。注意：判断选完当前物品后是否超重
            int p2 = rest - w[index] < 0 ? 0 : v[index] + dp[index + 1][rest - w[index]];
            dp[index][rest] = Math.max(p1, p2);
        }
    }

    //6、返回背包容量为bag，从0号物品开始的最大价值
    return dp[0][bag];

}
```

#### 2）数字字符串转换为字母组合的种数

题目：规定1和数字A对应、2和B对应、...26和Z对应。那么一个数字字符串比如“111”就可以转化为：AAA、KA和AK。给定一个只有数字字符组成的字符串str，返回有多少种转化结果

```java
/**
     * 1、暴力递归
     *
     * @param str str只含有数字字符0~9
     * @return 返回多少种转化方案
     */
public static int number(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    return process(str.toCharArray(), 0);
}
//0~i-1位置已经设置好，设置i位置以及往后的转化方案
public static int process(char[] c, int i) {
    if (i == c.length) {
        //此时所有字符串已经转化好了，转化方案数+1
        return 1;
    }
    if (c[i] == '0') {
        //如果当前字符是0，说明这个方案不行。0只能和10或者20才能符合题意
        return 0;
    }
    //1、选当前一个数字字符来转化。再获取i+1以后的方案数
    int num = process(c, i + 1);
    //2、选两个数字字符来转化。要先判断i+1是否越界以及这两个数字字符是否能转化为字母，再获取i+2以后的方案数
    if (i + 1 < c.length && (c[i] - '0') * 10 + c[i + 1] - '0' <= 26) {
        num += process(c, i + 2);
    }
    return num;
}

//2、动态规划
public static int dp1(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] cs = str.toCharArray();
    int N = cs.length;
    //1、建立dp表。列代表当前字符的位置0~N
    int[] dp = new int[N + 1];
    //2、初始化dp表。0~N-1位置字符串已经设置好了，转化方案数+1
    dp[N] = 1;
    //3、填表
    for (int i = N - 1; i >= 0; i--) {
        //只有当前字符不是0才能继续，否则说明这个方案不行
        if (cs[i] != '0') {
            //4、选当前一个数字字符来转化。再获取i+1以后的方案数
            dp[i] = dp[i + 1];
            //5、选两个数字字符来转化。要先判断i+1是否越界以及这两个数字字符是否能转化为字母，再获取i+2以后的方案数
            if (i + 1 < cs.length && (cs[i] - '0') * 10 + cs[i + 1] - '0' <= 26) {
                dp[i] += dp[i + 2];
            }
        }
    }
    //6、返回从0位置开始的转化方案数
    return dp[0];
}
```

#### 3）贴纸拼词，难

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文，arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来，返回需要至少多少张贴纸可以完成整个任务。

例：str=“babac”，arr={“ba”，“c”，“”abcd}。至少需要两张贴纸“ba”和“abcd”，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a，2个b，1个c。是可以拼出str的，所以返回2。

```java
//核心思想：将stickers转化为二维词频表，将target转化为一维词频表
public int minStickers(String[] stickers, String target) {
    int counts[][] = new int[stickers.length][26];
    for(int i = 0; i < stickers.length; i++){
        char[] cs = stickers[i].toCharArray();
        for(char c : cs){
            //stickers转化为二维词频表
            counts[i][c - 'a']++;
        }       
    }
    //傻缓存，存放key所需的最小贴纸数量。（注意：无法列dp表，变量是字符串，没有明确的边界条件，只能用傻缓存优化）
    HashMap<String,Integer> dp = new HashMap<>();
    //先在map中加入key->"",value->0。递归调用一直到底后需要用到
    dp.put("",0);
    int ans = process(counts,target,dp);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

/**
     * @param stickers   有这些贴纸，二维数组形式
     * @param target          当前目标字符串target
     * @param dp         缓存表
     * @return           返回拼完当前target所需要的最少贴纸数
     */
public static int process(int[][] stickers, String target, HashMap<String, Integer> dp) {
    //map表中有直接用
    //若当前target为null，说明此时不需要贴纸，返回0。主函数已经提前设置好了
    if (dp.containsKey(target)) {
        return dp.get(target);
    }
    //target转化为一维词频表
    int tcounts[] = new int[26];
    char[] cs = target.toCharArray();
    for(char c : cs){
        tcounts[c - 'a']++;
    }

    int min = Integer.MAX_VALUE;
    //1、从第一张贴纸开始尝试，尝试那些包含当前target第一个字符的所有贴纸，然后取最小值
    for(int i = 0; i < stickers.length; i++){
        // 2、当前贴纸包含当前target第一个字符，才进行调整，避免不必要的遍历。
        // 最关键的优化(重要的剪枝!这一步也是贪心!)
        if(stickers[i][cs[0] - 'a'] > 0){
            //用来拼接 target在减去当前贴纸所有能用的字符 后剩下的字符
            StringBuilder builder = new StringBuilder();
            for(int j = 0; j < 26; j++){
                //3、检查26个字符的分布情况。确保这个字符需要贴纸来拼
                if(tcounts[j] > 0){
                    //4、返回用当前贴纸需要几张。即target中的这个字符有多少个
                    int num = tcounts[j] - stickers[i][j];
                    for(int k = 0; k < num; k++){
                        //5、builder装 用这张贴纸后，target还剩下的那些字符
                        builder.append((char)(j+'a'));
                    }
                }
            }
            String rest = builder.toString();
            //6、选择完这张贴纸后，min=剩下的那些字符返回需要的最小贴纸数。min最终会取所有可能中的最小数
            min = Math.min(min, process(stickers, rest, dp));
        }
    }
    //7、若min为maxValue说明无法拼成当前target，返回maxValue，否则返回min + 1，min是剩余字符的最小贴纸数，需要加上当前贴纸+1
    int ans = (min == Integer.MAX_VALUE ? min : min+1);
    //8、记录在傻缓存中
    dp.put(target,ans);
    return ans;
}
```

### 20、class20--从暴力递归到动态规划

#### 1）最长公共子序列

题目：给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

```java
//1、暴力递归
public static int longestCommonSubsequence1(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
        return 0;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    return process1(str1, str2, str1.length - 1, str2.length - 1);
}

//返回str1从0到i上 和 str2从0到j上 的最长公共子序列
//从str1.length - 1 ~ 0, str2.length - 1 ~ 0的递归调用
public static int process1(char[] str1, char[] str2, int i, int j){
    if(i == 0 && j == 0){
        //1、两个字符串都只剩一个字符了
        return str1[i] == str2[j] ? 1 : 0;
    }else if(i == 0){
        //2、str1只剩一个字符了
        return str1[i] == str2[j] ? 1 : process1(str1,str2,i,j-1);
    }else if(j == 0){
        //3、str2只剩一个字符了
        return str1[i] == str2[j] ? 1 : process1(str1,str2,i-1,j);
    }else{
        //4、两个字符串都不止一个字符
        if(str1[i] == str2[j]){
            //4.1、两个字符串结尾相同
            return 1 + process1(str1,str2,i-1,j-1);
        }else{
            //4.2、两个字符串结尾不同。以下两种可能中较大的一定是对的
            //假设str1[i]不是公共的
            int p1 = process1(str1,str2,i-1,j);
            //假设str2[j]不是公共的
            int p2 = process1(str1,str2,i,j-1);
            return Math.max(p1,p2);
        }
    }
}

//2、动态规划
public static int longestCommonSubsequence2(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
        return 0;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    int M = s1.length();
    int N = s2.length();
    //建dp表并初始化
    int[][] dp = new int[M][N];
    //1、两个字符串都只剩一个字符了
    dp[0][0] = str1[0] == str2[0] ? 1 : 0;
    //2、str1只剩一个字符了
    for(int j = 1; j < N; j++){
        dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j-1];
    }
    //3、str2只剩一个字符了
    for(int i = 1; i < M; i++){
        dp[i][0] = str1[i] == str2[0] ? 1 : dp[i-1][0];
    }
    //4、两个字符串都不止一个字符
    for(int i = 1; i < M; i++){
        for(int j = 1; j < N; j++){
            if(str1[i] == str2[j]){
                //4.1、两个字符串结尾相同
                dp[i][j] = 1 + dp[i-1][j-1];
            }else{
                //4.2、两个字符串结尾不同。以下两种可能中较大的一定是对的
                //假设str1[i]不是公共的
                int p1 = dp[i-1][j];
                //假设str2[j]不是公共的
                int p2 = dp[i][j-1];
                dp[i][j] = Math.max(p1,p2);
            }
        }
    }
    return dp[M-1][N-1];
}
```

#### 2）最长回文子序列

题目：给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列

```java
//1、暴力递归
public static int lpsl1(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    return process(str, 0, s.length() - 1);
}

//返回str在L到R上的最长回文子序列
public static int process(char[] str, int L, int R) {
    if (L == R) {
        //1、当前字符串只剩一个字符了
        return 1;
    } else if (L == R - 1) {
        //2、当前字符串只剩两个字符了
        return str[L] == str[R] ? 2 : 1;
    } else {
        //3、当前字符串不止两个
        if (str[L] == str[R]) {
            //3.1、L上的字符和R上的字符一样
            return 2 + process(str, L + 1, R - 1);
        } else {
            //3.2、L上的字符和R上的字符不一样。以下两种可能中值较大的一定是对的
            //假设L上的字符不是回文子序列的一部分
            int p1 = process(str, L + 1, R);
            //假设R上的字符不是回文子序列的一部分
            int p2 = process(str, L, R - 1);
            return Math.max(p1, p2);
        }
    }
}

//2、动态规划
public static int lpsl2(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    int N = str.length;
    //建表，填表，dp表只需填上三角形即可
    int[][] dp = new int[N][N];
    //先将右下角最后一个元素赋值，避免赋值第二条对角线时越界
    dp[N - 1][N - 1] = 1;
    for (int i = 0; i < N - 1; i++) {
        //1、当前字符串只剩一个字符了
        dp[i][i] = 1;
        //2、当前字符串只剩两个字符了
        dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
    }
    //3、当前字符串不止两个，从N-3行开始往上填(N-1行和N-2行填完了)，每一行再从左往右填。
    for (int L = N - 3; L >= 0; L--) {
        for (int R = L + 2; R < N; R++) {
            if (str[L] == str[R]) {
                //3.1、L上的字符和R上的字符一样
                dp[L][R] = 2 + dp[L + 1][R - 1];
            } else {
                //3.2、L上的字符和R上的字符不一样。以下两种可能中值较大的一定是对的
                //假设L上的字符不是回文子序列的一部分
                int p1 = dp[L + 1][R];
                //假设R上的字符不是回文子序列的一部分
                int p2 = dp[L][R - 1];
                dp[L][R] = Math.max(p1, p2);
            }
        }
    }
    //4、返回从0到N-1上的最长回文子序列
    return dp[0][N - 1];
}
```

#### 3）马走棋盘问题

题目：请自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置，那么整个棋盘就是横坐标上9条线，纵坐标上10条线的区域。给你三个参数x,y,k，返回“马”从(0,0)位置出发，必须走k步，最后落在(x,y)上的方法数有多少种

```java
//1、暴力递归
public static int jump(int x, int y, int k) {
    //x-> 0~9  y-> 0~8
    //目的地越界 返回0
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    return process(0, 0, k, x, y);
}
//当前马在(a,b)位置，目的地是(x,y)位置，还剩rest步可以走
public static int process(int a, int b, int rest, int x, int y) {
    //1、当前位置已经越界
    if (a < 0 || a > 9 || b < 0 || b > 8) {
        return 0;
    }
    //2、所有步数已经走完。第0层只有(x,y)这个点为1，剩下的点都为0
    if (rest == 0) {
        return (a == x && b == y) ? 1 : 0;
    }
    //3、马走日，所以马只有8种走法。将这8中走法累加，其中无效的为0
    int num = process(a + 2, b + 1, rest - 1, x, y);
    num += process(a + 1, b + 2, rest - 1, x, y);
    num += process(a - 1, b + 2, rest - 1, x, y);
    num += process(a - 2, b + 1, rest - 1, x, y);
    num += process(a + 2, b - 1, rest - 1, x, y);
    num += process(a + 1, b - 2, rest - 1, x, y);
    num += process(a - 1, b - 2, rest - 1, x, y);
    num += process(a - 2, b - 1, rest - 1, x, y);

    return num;
}

//2、动态规划
public static int dp(int x, int y, int k) {
    //(x,y)是目的地。x-> 0~9  y-> 0~8
    //目的地越界 返回0
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    //建表，行是马此时的横坐标，列是马此时的纵坐标，高是马剩余可用的步数
    int[][][] dp = new int[10][9][k + 1];
    //1、所有步数已经走完。第0层只有(x,y)这个点为1，剩下的点都为0
    dp[x][y][0] = 1;
    //2、马走日，所以马只有8种走法。将这8中走法累加，其中无效的为0
    for (int rest = 1; rest <= k; rest++) {
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 9; j++) {
                //对于越界的那些点，没法一一赋值，建一个方法getDp()用来获取dp表中当前位置的信息
                dp[i][j][rest] = getDp(dp, i + 2, j + 1, rest - 1);
                dp[i][j][rest] += getDp(dp, i + 1, j + 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 1, j + 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 2, j + 1, rest - 1);
                dp[i][j][rest] += getDp(dp, i + 2, j - 1, rest - 1);
                dp[i][j][rest] += getDp(dp, i + 1, j - 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 1, j - 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 2, j - 1, rest - 1);
            }
        }
    }
    //3、返回马从(0,0)走k步到(x,y)的方法数
    return dp[0][0][k];
}
//获取dp表中当前位置的信息，若当前位置越界返回0
public static int getDp(int[][][] dp, int a, int b, int rest) {
    //若当前位置已经越界，返回0
    if (a < 0 || a > 9 || b < 0 || b > 8) {
        return 0;
    }
    //若不越界，返回dp表中值
    return dp[a][b][rest];
}
```

#### 4）喝咖啡问题，难

题目：给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间，给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡，只有一台洗咖啡机，一次只能洗一个杯子，时间消耗a，洗完才能洗下一杯，每个咖啡杯也可以自己挥发干净，时间消耗b，咖啡杯可以并行挥发。假设所有人拿到咖啡之后立刻喝干净，返回从开始等到所有咖啡机变干净的最短时间。三个参数：int[] arr、int N、int a、int b。

核心思想：首先求出每个人喝完咖啡的最优时间，即每个杯子可以开始洗的时间(小根堆)，再求出所有杯子变干净的最优时间(动态规划)

```java
//咖啡机信息
public static class Machine {
    public int timePoint;          //这个咖啡机可以开始冲咖啡的时间点
    public int workTime;           //这个咖啡机冲一杯咖啡所需要的时间

    //(1,3)代表1这个时间点可以开始冲咖啡，冲咖啡需要3
    public Machine(int t, int w) {
        timePoint = t;
        workTime = w;
    }
}
//比较器，冲完一杯咖啡时间点最早的排在前面
public static class MachineComparator implements Comparator<Machine> {
    @Override
    public int compare(Machine o1, Machine o2) {
        return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
    }
}

//1、暴力递归
public static int minTime1(int[] arr, int n, int a, int b) {
    PriorityQueue<Machine> heap = new PriorityQueue<Machine>(new MachineComparator());
    for (int i = 0; i < arr.length; i++) {
        //初始化小根堆，此时每台咖啡机都可以使用
        heap.add(new Machine(0, arr[i]));
    }
    //drink[i]代表第i号人喝完咖啡的时间，即第i号杯子可以开始洗的时间。利用小根堆，这个时间是最优的
    int[] drinks = new int[n];
    for (int i = 0; i < n; i++) {
        //选择最合适的咖啡机
        Machine cur = heap.poll();
        //更新这台咖啡机下一次可以冲咖啡的时间
        cur.timePoint += cur.workTime;
        heap.add(cur);
        //第i个人喝完咖啡的时间点，即第i号杯子可以开始洗的时间
        drinks[i] = cur.timePoint;
    }
    //从第0号杯子开始洗，此时洗咖啡机free=0,可以开始洗
    return bestTime(drinks, a, b, 0, 0);
}
/**
     * 洗完index及剩下杯子最早的结束时间
     *
     * @param drinks 所有杯子可以开始洗的时间
     * @param wash   单杯洗干净的时间（串行）
     * @param air    挥发干净的时间(并行)
     * @param index  第几号杯子
     * @param free   洗咖啡机什么时候可用
     * @return drinks[index.....]所有杯子都变干净，最早的结束时间（返回）
     */
public static int bestTime(int[] drinks, int wash, int air, int index, int free) {
    if (index == drinks.length) {
        //说明所有杯子都洗完了,就不用洗了
        return 0;
    }
    //1、index号杯子用洗咖啡机洗
    //index杯子洗完的时间
    int cleanIndex1 = Math.max(drinks[index], free) + wash;
    //剩余杯子变干净时间
    int cleanOther1 = bestTime(drinks, wash, air, index + 1, cleanIndex1);
    //所有杯子变干净的时间
    int p1 = Math.max(cleanIndex1, cleanOther1);

    //2、index号杯子挥发
    //index杯子挥发完的时间
    int cleanIndex2 = drinks[index] + air;
    //剩余杯子变干净时间
    int cleanOther2 = bestTime(drinks, wash, air, index + 1, free);
    //所有杯子变干净的时间
    int p2 = Math.max(cleanIndex2, cleanOther2);

    //3、就上面这两种可能,返回时间最早的
    return Math.min(p1, p2);
}

//2、动态规划
public static int minTime2(int[] arr, int n, int a, int b) {
    //1、建立小根堆，用来获取并排序每个杯子最早可以开始洗的时间
    PriorityQueue<Machine> heap = new PriorityQueue<>(new Comparator<Machine>() {
        @Override
        public int compare(Machine o1, Machine o2) {
            return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
        }
    });
    //初始化小根堆
    for (int i = 0; i < arr.length; i++) {
        heap.add(new Machine(0, arr[i]));
    }
    //每个杯子最早可以开始洗的时间
    int[] drinks = new int[n];
    for (int i = 0; i < n; i++) {
        //选择最合适的咖啡机
        Machine cur = heap.poll();
        //更新这台咖啡机的信息，并重新放回小根堆
        cur.timePoint += cur.workTime;
        heap.add(cur);
        //获取这个杯子可以开始洗的时间
        drinks[i] = cur.timePoint;
    }
    //2、动态规划，用来求所有杯子变干净的最优时间
    int maxFree = 0;
    for (int i = 0; i < n; i++) {
        //2.1、获取洗碗机能使用的最晚时间
        maxFree = Math.max(maxFree, drinks[i]) + a;
    }
    //建表，行是第几个杯子，列是洗咖啡机可以使用的时间点。因为列的范围不好规定，用最差情况来作为列的边界
    //dp[i][j]代表 在洗咖啡机j时间点可以使用时 第i号及剩下的所有杯子变干净的最早时间
    //dp[n][...] = 0; 建表时已经初始化好了，就不用在写了。第n行代表所有杯子都洗完了，就不用洗了
    int[][] dp = new int[n + 1][maxFree + 1];
    for (int index = n - 1; index >= 0; index--) {
        for (int free = 0; free <= maxFree; free++) {
            //2.2、index杯子就下面面这两种可能,返回时间最早的
            //2.2.1、index号杯子用洗咖啡机洗
            //index杯子洗完的时间
            int cleanIndex1 = Math.max(drinks[index], free) + a;
            if(cleanIndex1 > maxFree){
                //越界了，index号杯子后面的也不用填了
                break;
            }
            //剩余杯子变干净时间
            int cleanOther1 = dp[index + 1][cleanIndex1];
            //所有杯子变干净的时间
            int p1 = Math.max(cleanIndex1, cleanOther1);
            //2.2.2、index号杯子挥发
            //index杯子挥发完的时间
            int cleanIndex2 = drinks[index] + b;
            //剩余杯子变干净时间
            int cleanOther2 = dp[index + 1][free];
            //所有杯子变干净的时间
            int p2 = Math.max(cleanIndex2, cleanOther2);
            //2.2.3、就上面这两种可能,选择时间最早的
            dp[index][free] = Math.min(p1,p2);
        }
    }
    //2.3、返回在洗咖啡机0时间点可以使用时 第0号及剩下的所有杯子变干净的最早时间
    return dp[0][0];
}
```
