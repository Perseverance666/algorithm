# 算法笔记

## 一、体系学习

### 1、class01

#### 1）选择排序，复杂度O(N^2)

1.先从a[0] - a[N-1] 个数中找到最小的数把它放在a[0]的位置

2.在从a[1] - a[N-1]个数中找到最小的数把它放在a[1]的位置上，以此类推

3.一次循环找到一个最小值，放在开头，然后每次循环找一个最小值往之前找到的最小值后面放

```java
    public static void SelectionSort(int[] arr) {
        //1、临界条件判断
        if (arr == null || arr.length <= 1) {
            return;
        }
        //2、进行从小到大选择排序
        for (int i = 0; i < arr.length; i++) {
            //先找一个当做最小值
            int minIndex = i;
            for (int j = i + 1; j < arr.length; j++){
                if(arr[j] < arr[minIndex]){
                    minIndex = j;
                }
            }
            swap(arr,i,minIndex);
        }
    }
```

#### 2）冒泡排序，复杂度O(N^2)

1.先从a[0] - a[N-1]个数中，从头开始两两比较，将较大的数放到后面，这样最后一个数就是最大的

2.再从a[0] - a[N-2]个数中，像上面步骤一样两两比较，这样倒数第二个数就是第二大的，以此类推

3.一次循环两两比较，最终将找到一个最大值放在最后，然后每次循环再找剩下数中的最大值

```java
    public static void BubbleSort(int[] arr) {
        //1、临界条件判断
        if (arr == null || arr.length <= 1) {
            return;
        }
        //2、进行从小到大冒泡排序  0 ~ N-1    0 ~ N-2  ...
        for (int i = arr.length-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (arr[j + 1] < arr[j]) {
                    swap(arr, j + 1, j);
                }
            }
        }

    }
```

#### 3）插入排序，复杂度O(N^2)

1.先确保0 - 1 位置上的数有序，若a[1] 小于a[0]，交换，反之不变

2.在确保0 - 2 位置上的数有序，若a[2] 小于a[1]，交换，直到比前面的数大，或者前面没数了，以此类推

3.这样确保第i个数前面的数都是有序的，然后将该数插入到合适位置

```java
    public static void insertionSort(int[] arr) {
        //1、临界条件判断
        if (arr == null || arr.length <= 1) {
            return;
        }
        //2、进行从小到大插入排序 0~1   0~2 ... 最后0~N-1 上都是有序的
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0; j--) {
                if(arr[j - 1] > arr[j]){
                    swap(arr, j-1, j);
                }
            }
        }
    }
```

#### 4）二分法

##### 1、题目一

题目在一个有序数组中，找某个数是否存在

1.先找中间的数，若当前数 = 指定数，找到了

2.若当前数 < 指定数，说明所求可能在右边，将L移到mid右边

3.若当前数 > 指定数，说明所求可能在左边，将R移到mid左边

4.当L> R时，就全找完了，没有找到，返回false

```java
    public static boolean exist(int[] sortedArr, int num) {
        if (sortedArr == null || sortedArr.length == 0) {
            return false;
        }
        int L = 0;
        int R = sortedArr.length - 1;
        int mid = 0;
        while (L <= R){
            mid = L + ((R - L) >> 1); //等同于 mid = (L + R) / 2;
            if(sortedArr[mid] == num){
                return true;
            } else if(sortedArr[mid] < num){
                L = mid + 1;
            } else {
                R = mid - 1 ;
            }
        }
        //全都比较完了，没有找到
        return false;
    }
```

##### 2、题目二

题目：在一个有序数组中，找到 >= 某个数最左侧的位置 (<= 最右侧位置 问题类似)

1.先找中间的数，若当前数 >= 指定数，说明左面有可能还有符合要求的数，记录当前位置，并将R移到mid左边

2.若当前数 < 指定数，说明左边肯定没有了，不记录当前位置，并将L移到mid右边，继续向右找

3.当L> R时，就找完了，index存的就是所求

```java
    public static int nearestIndex(int[] arr, int value) {
        int L = 0;
        int R = arr.length - 1;
        int mid = 0;
        int index = -1;
        while(L <= R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] >= value){
                //若当前数 >= 指定数，记录当前位置，并将R移到mid左边
                index = mid;
                R = mid - 1;
            }else{
                //若当前数 < 指定数，不记录当前位置，并将L移到mid右边
                L = mid + 1;

            }
        }
        return index;
    }
```

##### 3、题目三

题目：局部最小值问题，找一个局部最小即可

1.先判断第0个数，或者第N-1个数是否是局部最小

2.以上两个数不满足，开始二分，若mid大于左边的数，不管是否大于还是小于右边的数，mid左边一定存在局部最小

3.若mid大于右边的数，不管是否大于还是小于左边的数，mid右边一定存在局部最小

4.当L=R时，这个数一定是局部最小

```java
    public static int getLessIndex(int[] arr) {
        if(arr == null || arr.length <= 0){
            return -1; //不存在
        }
        if(arr.length == 1 || arr[0] < arr[1]){
            return 0; //0位置就是局部最小
        }
        if(arr[arr.length - 1] < arr[arr.length - 2]){
            return arr.length - 1;  //arr.length -1 位置就是局部最小
        }
        int L = 1;
        int R = arr.length - 2;
        int mid = 0;
        while(L < R){
            mid = L + ((R - L) >> 1);
            if(arr[mid] < arr[mid -1] && arr[mid] < arr[mid + 1]){
                return mid;
            }else if(arr[mid] > arr[mid -1]){
                //说明局部最小在左边
                R = mid - 1;
            }else{
                //说明局部最小在右边
                L = mid + 1;
            }
        }
        //此时L = R,这个数一定是局部最小
        return L;
    }
```

### 2、class02

#### 1）异或运算

技巧：如何不用额外变量交换两个数

```java
    public static void swap (int[] arr, int i, int j) {
        arr[i]  = arr[i] ^ arr[j];
        arr[j]  = arr[i] ^ arr[j];
        arr[i]  = arr[i] ^ arr[j];
    }
```

##### 1、题目一

题目：一个数组中有一种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

定义一个变量eor初值为0，将所有数进行异或运算，出现偶数次的其他数经过异或运算变成0，最终只剩出现奇数次的那个数，即为所求

```java
public static void printOddTimesNum1(int[] arr) {
    int eor = 0;
    for (int i = 0; i < arr.length; i++) {
        eor ^= arr[i];
    }
    System.out.println(eor);
}
```

##### 2、题目二

题目：一个数组中有两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这种数

1.定义一个变量eor初值为0，将所有数进行异或运算，出现偶数次的其他数经过异或运算变成0，最后eor = a ^ b

2.我们知道a != b，故eor二进制状态下一定存在1，只有a与b的某一位不同，eor才等于1，我们取eor最右边的1这位进行研究，此时a和b的这一位一定是一个1一个0

3.将原来的所有数分成两组，一组是那一位是1的，另外一组是那一位是0的，这样就将a和b分成了两组，各自再带几个出现偶数次的数

4.然后再定义一个变量eor2，规定只对那一位是1的进行异或，这样经过异或运算最终假如就得到a了，然后b = eor ^ a =  a ^ b

```java
public static void printOddTimesNum2(int[] arr) {
    int eor = 0;
    for(int i = 0; i < arr.length; i++){
        eor ^= arr[i];
    }
    System.out.println(eor);  //eor = a ^ b;

    //取eor最右边的1最为条件，然后分成两组
    int rightOne = eor & (-eor);   //eor & (~eor + 1)    等同于  eor & (-eor) ，可以得到最右边的1，例如：0001000
    int eor2 = 0;
    for(int i = 0; i < arr.length; i++){
        //这次只异或那一位是1的
        if((arr[i] & rightOne) == rightOne){
            eor2 ^= arr[i];
        }

    }

    int a = eor2; //eor2的异或结果就是其中一个数
    int b = eor ^ a;   //b = eor ^ a = a ^ b ^ a;
    System.out.println(a + " " + b);

}
```

##### 3、题目三

题目：数组中所有的数都出现了M次，只有一种数出现了K次，1 <= K < M 返回这种数

1.先创建一个32位的数组，开始存的全是0

2.然后依次检查原数组中的每个数，每个数的哪一位上有1((arr[i] >> j) & 1) != 0)，就在32位数组上的对应位置加1，最后完成32位数组

3.检查32位数组，若某一位模M 等于 0，说明出现K次的那个数在这一位上是0，若模M不等于0，说明出现K次的那个数在这一位上是1，把这一位的1加到结果上去 ans = ans | (1 << i)。最终找到这个数

```java
  public static int km(int[] arr, int k, int m) {
        int[] t = new int[32];
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < 32; j++) {
                if(((arr[i] >> j) & 1) != 0){
                    //说明从右向左数，第j位是1，加到32位数组中
                    t[j]++;
                }

            }
        }

        int ans = 0;
        for(int i = 0; i < 32; i++){
            if(t[i] % m != 0){
                //说明出现k次的那个数，从右往左，二进制在第i位上是1
                ans = ans | (1 << i);
            }
        }

        return ans;
    }
```

### 3、class03

#### 1）链表反转

##### 1、单链表反转

要点：先记录下一节点，在翻转指针，最后移动两个指针准备翻转下一组

1.准备两个指针pre和next都先指向null，他俩用来记录位置，先让next记录当前节点的下一结点

2.然后反转指针

3.然后pre指向Head记录当前节点位置，即下一个节点的上一个节点

4.最后更新Head，此时第一个节点完成，依次完成之后的节点

```java
    public static Node reverseLinkedList(Node head) {
        Node pre = null;
        Node next = null;
        while(head != null){
            //1、记录下一个节点
            next = head.next;
            //2、翻转指针
            head.next = pre;
            //3、两个指针移动，准备翻转下一组
            pre = head;
            head = next;
        }
        return pre;
    }
```

##### 2、双链表反转

双链表和单链表过程一样，只是反转链表时，要反转next和last两个

```java
    public static DoubleNode reverseDoubleList(DoubleNode head) {
        DoubleNode pre = null;
        DoubleNode next = null;
        while(head != null){
            //1、记录下一个节点
            next = head.next;
            //2、翻转指针
            head.next = pre;
            head.last = next;
            //3、两个指针移动，准备翻转下一个
            pre = head;
            head = next;
        }
        return pre;
    }
```

#### 2）移除链表元素

1.首先让head指向第一个不需要删除的节点，用来返回

2.然后创建两个指针pre，cur先指向head（cur用来指向当前节点，pre用来指向下一个节点）

3.判断该节点值是否与指定值相等。若相等，让pre跳过这个节点，pre不动，pre.next指向下一个节点，然后cur后移。确保cur指向下一个节点，pre指向当前节点

4.若不等，pre指向cur指向的节点（因为cur和pre有可能指向同一个位置，也有可能一前一后)，目的是让pre指向cur指向的位置，然后cur后移。确保cur指向下一个节点，pre指向当前节点



```java
    public static Node removeValue(Node head, int num) {
        //1、首先让head指向第一个不需要删除的节点
        while(head != null){
            if(head.value != num){
                break;
            }
            head = head.next;
        }
        //2、然后进行删除
        Node pre = head;
        Node cur = head;
        while (cur != null){
            if(cur.value == num){
                pre.next = cur.next;
            }else{
                pre = cur;
            }
            cur = cur.next;
        }
        return head;
    }

```

#### 3）返回栈中最小元素

1.首先定义两个栈，一个存数据，另一个存最小值

2.若当前元素比当前最小值小，当前元素入两个栈

3.若当前元素大于当前最小值，当前元素入数据栈，另一个栈再存一次之前的最小值，保证两个栈有相同的层次

```java
 public static class MyStack2 {
        private Stack<Integer> stackData;
        private Stack<Integer> stackMin;

        public MyStack2() {
            this.stackData = new Stack<Integer>();
            this.stackMin = new Stack<Integer>();
        }

        public void push(int newNum) {
            if (this.stackMin.isEmpty()) {
                this.stackMin.push(newNum);
            } else if (newNum < this.getmin()) {
                this.stackMin.push(newNum);
            } else {
                int newMin = this.stackMin.peek();
                this.stackMin.push(newMin);
            }
            this.stackData.push(newNum);
        }

        public int pop() {
            if (this.stackData.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            this.stackMin.pop();
            return this.stackData.pop();
        }

        public int getmin() {
            if (this.stackMin.isEmpty()) {
                throw new RuntimeException("Your stack is empty.");
            }
            return this.stackMin.peek();
        }
    }
```

#### 4）用栈实现队列

1.准备两个栈，push栈用来加数据，pop栈用来弹出数据

2.首先将push栈中的所有数据全都弹出到pop栈中，这样pop栈弹出就实现队列了

3.若在pop栈弹出的过程中，push栈又加入了新的元素。必须等pop栈都弹出完了，才能将push栈的元素弹出到pop栈中

4.模拟添加，先加入push栈，等pop栈为空时，再全部添加到pop栈

5.模拟弹出，等pop栈为空时，再全部添加到pop栈，然后弹出pop栈，模拟完成

```java
    public static class TwoStacksQueue {
        public Stack<Integer> stackPush;
        public Stack<Integer> stackPop;

        public TwoStacksQueue() {
            stackPush = new Stack<Integer>();
            stackPop = new Stack<Integer>();
        }

        // push栈向pop栈倒入数据
        private void pushToPop() {
            //只有pop栈为空时，才将push栈的所有元素弹出到pop栈中
            if (stackPop.empty()) {
                while (!stackPush.empty()) {
                    //一次将push栈中的所有元素都弹出到pop栈中
                    stackPop.push(stackPush.pop());
                }
            }
        }

        public void add(int pushInt) {
            stackPush.push(pushInt);
            pushToPop();
        }

        public int poll() {
            if (stackPop.empty() && stackPush.empty()) {
                throw new RuntimeException("Queue is empty!");
            }
            pushToPop();
            return stackPop.pop();
        }

        public int peek() {
            if (stackPop.empty() && stackPush.empty()) {
                throw new RuntimeException("Queue is empty!");
            }
            pushToPop();
            return stackPop.peek();
        }
    }
```

#### 5）用队列实现栈

1.首先准备两个队列，一个queue最终用来弹出的，另一个help用来暂时存放其他元素的

2.模拟添加，直接往queue队列中加入元素即可

3.模拟弹出，先将queue队列的元素弹出到help队列中，让queue只剩一个元素，这样弹出queue中的元素就实现了栈。

4.queue队列弹出完这一个元素后，将help队列改成queue队列，将queue队列改成help队列

```java
    public static class TwoQueueStack<T> {
        public Queue<T> queue;
        public Queue<T> help;

        public TwoQueueStack() {
            queue = new LinkedList<>();
            help = new LinkedList<>();
        }

        public void push(T value) {
            queue.offer(value);
        }

        public T poll() {
            while (queue.size() > 1) {
                help.offer(queue.poll());
            }
            T ans = queue.poll();
            Queue<T> tmp = queue;
            queue = help;
            help = tmp;
            return ans;
        }

        public T peek() {
            while (queue.size() > 1) {
                help.offer(queue.poll());
            }
            T ans = queue.poll();
            help.offer(ans);
            Queue<T> tmp = queue;
            queue = help;
            help = tmp;
            return ans;
        }

        public boolean isEmpty() {
            return queue.isEmpty();
        }

    }
```

#### 6）Master公式

形如T(N)=a*T(N/b) + O(N^d) (其中的a、b、d都是常数)的递归函数并且子规模一致的条件下，可以直接通过Master公式来确定时间复杂度

1.如果log(b,a) < d，复杂度为O(N ^ d)

2.如果log(b,a) > d，复杂度为O(N ^ log(b,a))

3.如果log(b,a) = d，复杂度为O(N ^ d * log(2,N))

### 4、class04 -- 归并排序

#### 1）归并排序，复杂度O(N*logN)

##### 1、递归实现

1.定义一个函数process(int[] arr, int L, int R)，把L到R上变有序

2.然后分成两部分把L到M变有序，再把M+1到R变有序，然后再把它们两个merge

3.merge(int[] arr, int L, int M, int R)，准备一个数组help用来存最后排序好的数据。准备两个变量p1和p2首先分别指向L和M+1，然后经过挑选完成最终排序

```java
    // 递归方法实现
    public static void mergeSort1(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process(arr, 0, arr.length - 1);
    }

    // 把arr[L..R]排有序
    public static void process(int[] arr, int L, int R) {
        if (L == R) { // base case
            return;
        }
        int mid = L + ((R - L) >> 1);
        process(arr, L, mid);
        process(arr, mid + 1, R);
        merge(arr, L, mid, R);
    }

    //将L到M 和 M+1到R上的数据进行归并排序
    public static void merge(int[] arr, int L, int M, int R) {
        int[] help = new int[R - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = M + 1;
        while (p1 <= M && p2 <= R) {
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        // 要么p1越界了，要么p2越界了
        while (p1 <= M) {
            help[i++] = arr[p1++];
        }
        while (p2 <= R) {
            help[i++] = arr[p2++];
        }
        //将help数组数据存回arr
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }

    }
```

##### 2、非递归实现

1.首先步长设置为1，然后进入循环判断此时步长是否超出数组长度，若超出了证明排序完成

2.先从左边第一个数，即L=0开始，然后再进入循环判断此时L是否超出数组长度，若超出证明越界了。循环结束后还要检测一下，看看此时步长是否 > 2分之数组长度，防止溢出（因为有可能由于精度问题导致越界，结果变成负数，这样就又进入第一个循环了，所以要检测一下）。若没有越界，则将步长乘2

3.在第二个循环中，若此时剩下的元素数量(N-L) <= 步长，就结束当前循环。否则确定M位置和R位置，其中要是确定的R位置已经越界了就改成N-1

4.然后合并merge(int[] arr, int L, int M, int R)，修改L的位置，L = R + 1

```java
    // 非递归方法实现
    public static void mergeSort2(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        int N = arr.length;
        // 步长
        int mergeSize = 1;
        while (mergeSize < N) { //步长小于数组长度才继续
            // 当前左组的，第一个位置
            int L = 0;
            while (L < N) {		//L越界就结束循环
                if (mergeSize >= N - L) {	//剩下的元素 <= 步长就结束循环
                    break;
                }
                int M = L + mergeSize - 1;
                int R = M + Math.min(mergeSize, N - 1 - M);
                merge(arr, L, M, R);
                L = R + 1;
            }
            // 防止溢出
            if (mergeSize > N / 2) {
                break;
            }
            mergeSize <<= 1;
        }
    }
```

#### 2）返回数组的最小和，归并排序

将数组中每个元素左边比它小的**值**全部累加起来。左值小于右值才返回

1.定义一个函数process(int[] arr, int L, int R)，把0到N-1上变有序，并返回最小和

2.先返回L到M上的最小和，再返回M+1到R上的最小和，最后merge两部分再求最小和，把这三部分最小和加起来

3.merge将元素放到help数组时，如果左侧指定值 < 右侧指定值，说明左值是 右值以及右边剩下数 的最小和中的一个值，左值在 右值以及右边剩下数 的所有最小和中，占据的总值为：左值 * （右侧剩下数的个数）。左侧指针移动，边计算最小和边merge

4.如果左值 > 右值，只将较小数放到help，右侧指针移动，最小和不加，继续比较接下来的

5.如果左值 = 右值，将右值放入help，右侧指针移动，最小和不加。(要确保左右值不等时，能知道右侧有多少个比左值大的，所以要右侧指针移动)

```java
 public static int smallSum(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    // arr[L..R]既要排好序，也要求小和返回
    // 所有merge时，产生的小和，累加
    public static int process(int[] arr, int l, int r) {
        if (l == r) {
            return 0;
        }
        // l < r
        int mid = l + ((r - l) >> 1);
        return process(arr, l, mid) + process(arr, mid + 1, r) + merge(arr, l, mid, r);
    }

    public static int merge(int[] arr, int L, int m, int r) {
        int[] help = new int[r - L + 1];
        int i = 0;
        int p1 = L;
        int p2 = m + 1;
        int res = 0;
        while (p1 <= m && p2 <= r) {
            res += arr[p1] < arr[p2] ? (r - p2 + 1) * arr[p1] : 0;
            help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
        }
        while (p1 <= m) {
            help[i++] = arr[p1++];
        }
        while (p2 <= r) {
            help[i++] = arr[p2++];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
        return res;
    }
```

#### 3）返回逆序对数量，归并排序

将数组中每个元素右边比它小的数的**个数**全部累加起来。左值大于右值才返回

1.定义一个函数process(int[] arr, int L, int R)，把0到N-1上变有序，并返回逆序对数量

2.先返回L到M上的逆序对数量，再返回M+1到R上的逆序对数量，最后merge两部分再求逆序对数量，把这三部分逆序对数量加起来

3.这次的merge指针从右往左，merge将元素放到help数组时，若左值 > 右值，说明左值和 右值及右值左边的所有数 都可构成逆序对，左指针向左移动检验下一个左值。边计算逆序对数量边merge

4.如果左值 < 右值，只将较小数放到help，右侧指针左移，逆序对数量不加，继续比较接下来的

5.如果左值 = 右值，将右值放入help，右侧指针左移，逆序对数量不加。(要确保左右值不等时，能知道右侧有多少个比左值小的，所以要右侧指针移动)

```java
public static int reversePairNumber(int[] arr) {
        if (arr == null || arr.length < 2) {
            return 0;
        }
        return process(arr, 0, arr.length - 1);
    }

    // arr[L..R]既要排好序，也要求逆序对数量返回
    // 所有merge时，产生的逆序对数量，累加，返回
    public static int process(int[] arr, int l, int r) {
        if (l == r) {
            return 0;
        }
        // l < r
        int mid = l + ((r - l) >> 1);
        return process(arr, l, mid) + process(arr, mid + 1, r) + merge(arr, l, mid, r);
    }

    //这次指针从右边开始移动
    public static int merge(int[] arr, int L, int m, int r) {
        int[] help = new int[r - L + 1];
        int i = help.length - 1;
        int p1 = m;
        int p2 = r;
        int res = 0;
        while (p1 >= L && p2 > m) {
            res += arr[p1] > arr[p2] ? (p2 - m) : 0;
            help[i--] = arr[p1] > arr[p2] ? arr[p1--] : arr[p2--];
        }
        while (p1 >= L) {
            help[i--] = arr[p1--];
        }
        while (p2 > m) {
            help[i--] = arr[p2--];
        }
        for (i = 0; i < help.length; i++) {
            arr[L + i] = help[i];
        }
        return res;
    }
```

#### 4）翻转对，归并排序

题目：给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。返回给定数组中的重要翻转对的数量

1.定义一个函数process(int[] arr, int L, int R)，把0到N-1上变有序，并返回翻转对数量

2.先返回L到M上的翻转对数量，再返回M+1到R上的翻转对数量，最后merge两部分再求翻转对数量，把这三部分翻转对数量加起来

3.这次的先求翻转对数量，再进行merge。利用for循环指向左侧的变量，再定义一个变量指向右侧的变量，初始值为m+1，如果左值 > 2 * 右值，右侧指针右移，直到不满足停下，翻转对数量 += 右侧指针 - (M+1)。先计算翻转数量再merge

4.然后左侧指针移动，以此类推。最后merge

```java
 public static int reversePairs(int[] nums) {
        if(nums == null || nums.length <= 1){
            return 0;
        }
        return process(nums,0,nums.length - 1);
    }

    public static int process(int[] arr,int L,int R){
        //边界条件
        if(L == R){
            return 0;
        }
        int M = (L + R) / 2;
        //先计算左侧数量，再计算右侧数量，然后计算merge数量，最后三者加起来
        return process(arr,L,M) + process(arr,M+1,R) + merge(arr,L,M,R);
    }

    
    public static int merge (int[] arr,int L,int M,int R){
        int ans = 0;
        int windowR = M + 1;  //用来追踪右侧
        //用一个for循环来追踪左侧
        for(int i = L;i <= M; i++){
            //1、先计算翻转对
            while(windowR <= R && (long)arr[i] > (long)2 * arr[windowR]){
                windowR++;
            }
            ans += windowR - (M + 1);
        }

        //2、再进行merge
        int[] help = new int[R - L + 1];
        int p1 = L;
        int p2 = M + 1;
        int i = 0;
        while(p1 <= M && p2 <= R){
            help[i++] = arr[p1] <= arr[p2] ? arr[p1++] : arr[p2++];
        }
        //一侧都排完了
        while(p1 <= M){
            help[i++] = arr[p1++];
        }
        while(p2 <= R){
            help[i++] = arr[p2++];
        }
        //将排好序的help数组拷贝到arr中
        for(i = 0;i < help.length; i++){
            arr[L + i] = help[i];
        }

        return ans;
    }
```

### 5、class05

#### 1）区间和的个数，归并排序，难

题目：给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的区间和的个数 。区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

1.该问题要转换成 利用前缀数组来求区间和的个数

2.定义一个函数process(long[] sum, int L, int R, int lower, int upper)，返回0 ~ N-1上满足条件的区间和数量

3.边界条件L==R，即求L这个位置上的区间和数量，若这个数满足[lower,upper]，说明对于原数组0~L这是一个区间和，区间和数+1。若不满足，区间和数+0，继续接下的操作

4.先求L到M上的区间和数，再求M+1到R上的区间和数，然后求merge后的区间和数，最后加起来

5.这次先求区间和数，再进行merge。目标就是求右侧每个元素的区间和个数的总和。两个变量追踪左侧，min =  右数 - upper ,max = 右数 - lower，若左数在[min,max]之间，则(左数,右数)这个区间和就满足条件，利用两个变量追踪 求所有满足条件的左数

6.然后再merge

```java
    public int countRangeSum(int[] nums, int lower, int upper) {
        if(nums == null || nums.length == 0){
            return 0;
        }
        //转换为利用前缀数组求区间和个数
        long[] sum = new long[nums.length];
        sum[0] = nums[0];
        for(int i = 1; i < nums.length;i++){
            sum[i] = sum[i - 1] + nums[i];
        }
        //返回前缀数组0 ~ N-1上的区间和个数
        return process(sum,0,sum.length - 1,lower,upper);
    }
     
    public static int process(long[] sum,int L,int R,int lower,int upper){
        if(L == R){
            //若L这个数满足，即对于原数组(0,L)这个区间和满足条件，区间和+1，否则+0
            return sum[L] >= lower && sum[L] <= upper ? 1 : 0;
        }
        int M = (L + R) / 2;
        //先求左侧区间和数，再求右侧区间和数，然后求merge后的区间和数，最后加起来
        return process(sum,L,M,lower,upper) + process(sum,M+1,R,lower,upper) + merge(sum,L,M,R,lower,upper);

    }

    public static int merge(long[] sum,int L,int M,int R,int lower,int upper){
        //1、先计算区间和数
        int ans = 0;   //区间和数
        //定义两个变量追踪左侧，用来判断右侧的每个数的区间和数
        int windowL = L;
        int windowR = L;
        //定义一个循环来，追踪右侧每个数  [windowL, windowR)
        for(int i = M + 1; i <= R; i++){
            long min = sum[i] - upper;
            long max = sum[i] - lower;
            //若左数在[min,max]之间，则(左数,右数)这个区间和就满足条件
            while (windowR <= M && sum[windowR] <= max) {
                windowR++;
            }
            while (windowL <= M && sum[windowL] < min) {
                windowL++;
            }
            //此时windowL ~ windowR是满足条件的，即(windowL,右数) 一直到 (windowR,右数)这些区间和都是满足条件的
            ans += windowR - windowL;
        }
        //2、再merge
        long[] help = new long[R-L+1];
        int p1 = L;
        int p2 = M + 1;
        int i = 0;
        while(p1 <= M && p2 <= R){
            help[i++] = sum[p1] <= sum[p2] ? sum[p1++] : sum[p2++];
        }
        while(p1 <= M){
            help[i++] = sum[p1++];
        }
        while(p2 <= R){
            help[i++] = sum[p2++];
        }
        for(i = 0; i < help.length; i++){
            sum[L+i] = help[i];
        }

        return ans;
    }
```

#### 2）荷兰国旗问题的划分

题目：将小于最后的数arr[R]，等于arr[R]和大于arr[R]的数分成三个区域，排好后 返回等于arr[R]的区间

1.设置小于区域 less = L -1和 大于区域more = R，大于区域先把arr[R]囊括起来，最后再来处理

2.定义个变量用来追踪当前数，如果当前数 = arr[R]，追踪下一个数

3.如果当前数 < arr[R] ，当前数与小于区域右边的那一数互换，然后区域向右移，追踪下一个数

4.如果当前数 > arr[R] ，当前数与大于区域左边的那一数互换，然后区域向左移，不追踪下一个数

5.最后将arr[R]与 大于区域 第一个数互换。最终返回的区间是 (小于区域 + 1,大于区域)，因为大于区域的第一个数是之前的最后的那个arr[R]

```java
    // arr[L...R] 玩荷兰国旗问题的划分，以arr[R]做划分值
    // <arr[R] ==arr[R] > arr[R]
    //返回最终排好的 等于arr[R]的那些数的坐标区间(都在中间位置)
    public static int[] netherlandsFlag(int[] arr, int L, int R) {
        if (L > R) { // L...R L>R
            return new int[] { -1, -1 };
        }
        if (L == R) {
            return new int[] { L, R };
        }
        int less = L - 1; // < 区 右边界
        int more = R; // > 区 左边界
        int index = L;
        while (index < more) { // 当前位置，不能和 >区的左边界撞上
            //如果当前数 = arr[R]，追踪下一个数
            if (arr[index] == arr[R]) {
                index++;
            } else if (arr[index] < arr[R]) {
                //如果当前数 < arr[R] ，当前数与区域前一个数互换，然后区域向后移，追踪下一个数
				swap(arr, less + 1, index);
				less++;
				index++;
            } else {
                //如果当前数 > arr[R] ，当前数与区域前一个数互换，然后区域向左移，不追踪下一个数
                swap(arr, index, more - 1);
                more--;
            }
        }
        //最后将arr[R]与 大于区域 第一个数互换
        swap(arr, more, R); // <[R]   =[R]   >[R]
        //返回的区间是 (小于区域 + 1,大于区域)，因为大于区域的第一个数是之前的最后的那个arr[R]
        return new int[] { less + 1, more };
    }
```

#### 3）随机快速排序，复杂度O(N*logN)

普通快速排序最差情况复杂度O(N^2)

1.调用方法process3(int[] arr, int L, int R)，将0~N-1 上的元素进行随机快速排序

2.边界条件L >= R返回上一层

3.先将最后一个数与前面随机一个数进行互换 变成随机快速排序

4.然后通过netherlandsFlag方法 将以arr[R]进行分割3部分，然后返回 囊括所有的arr[R] 的区间

5.最后递归调用process方法，先完成(L，区间左值 -1)上的随机快速排序，再完成(区间右值+1，R)上的随机快速排序

```java
	// 荷兰国旗问题
	public static int[] netherlandsFlag(int[] arr, int L, int R) {
		if (L > R) {
			return new int[] { -1, -1 };
		}
		if (L == R) {
			return new int[] { L, R };
		}
		int less = L - 1;
		int more = R;
		int index = L;
		while (index < more) {
			if (arr[index] == arr[R]) {
				index++;
			} else if (arr[index] < arr[R]) {
				swap(arr, index++, ++less);
			} else {
				swap(arr, index, --more);
			}
		}
		swap(arr, more, R);
		return new int[] { less + 1, more };
	}
   
	public static void quickSort3(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        process3(arr, 0, arr.length - 1);
    }

    public static void process3(int[] arr, int L, int R) {
        if (L >= R) {
            return;
        }
        swap(arr, L + (int) (Math.random() * (R - L + 1)), R);
        int[] equalArea = netherlandsFlag(arr, L, R);
        process3(arr, L, equalArea[0] - 1);
        process3(arr, equalArea[1] + 1, R);
    }
```

### 6、class06 --  堆

#### 1）堆

堆本质是一棵完全二叉树，完全二叉树只要有右孩子就必须有左孩子，它包括大根堆和小根堆，大根堆是每个子树的根节点都比孩子节点要大，这样第一个根节点数就是最大的

堆的相关操作：

```java
// 新加进来的数，现在停在了index位置，若它爹小于它，依次往上移动，
//向上调整
private void heapInsert(int[] arr, int index) {
    // [index] [index-1]/2
    // index == 0
    while (arr[index] > arr[(index - 1) / 2]) {
        //若新加的数大于它爹，与它爹交换位置，再去比较它与它的新爹谁大，循环下去，直到它爹>=它
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

// 背景：将第一个元素与最后一个元素互换后，heapSize--，逻辑删除最大元素。
// 检验此时第一个数 下面它大是否比孩子大。若它比下面的孩子小。从index位置，它不断的下沉
// 直到 左右孩子中较大的孩子都不再比index位置的数大 或者 已经没孩子了，结束
//向下调整
private void heapify(int[] arr, int index, int heapSize) {
    int left = index * 2 + 1;
    while (left < heapSize) { // 如果有左孩子，有没有右孩子，可能有可能没有！
        //1、先取左右孩子中较大的。如果有右孩子并且右孩子大于左孩子选右孩子。如果没有右孩子或者左孩子大于右孩子选左孩子
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        //2、然后将孩子与它爹比较。 把爹和孩子中较大的下标，给largest。
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            //3、若它爹就是较大的，不用交换，结束循环
            break;
        }
        //4、若孩子大于爹，交换位置，把大的放上面。然后继续检查它的孩子是否比它大，循环下去
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}
```

#### 2）堆排序，复杂度O(N*logN)

```java
public static void heapSort(int[] arr) {
    if(arr == null || arr.length <= 1){
        return;
    }

    // //1.1、先把数组从0开始依次heapInsert，最后变成大根堆
    // // O(N*logN)
    // for(int i = 0; i < arr.length; i++){
    //     heapInsert(arr,i);
    // }
    //或者1.2、从最底层开始，把这一层都变成大根堆，然后再处理上一层，依次变成大根堆
    // O(N)
    for(int i = arr.length-1; i >=0 ;i--){
        heapify(arr,i,arr.length);
    }
    //2、然后把第一个元素也就是最大的元素与最后一个元素交换，同时heapSize有效值减一，逻辑删除最大值，最大值排好序了
    int heapSize = arr.length;      //heapSize以内的数满足大根堆
    swap(arr,0,heapSize - 1);
    heapSize--;

    while(heapSize > 0){
        //3、对新换上来的根节点向下heapify
        heapify(arr,0,heapSize);
        //4、heapify后又变成大根堆，再把第一个元素和最后一个元素交换，这样又一个第二大的排好序了，直到heapSize变为0
        swap(arr,0,heapSize - 1);
        heapSize--;
    }
}

// arr[index]刚来的数，往上移动
public static void heapInsert(int[] arr, int index) {
    while (arr[index] > arr[(index - 1) / 2]) {
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

// arr[index]位置的数，能否往下移动
public static void heapify(int[] arr, int index, int heapSize) {
    int left = index * 2 + 1; // 左孩子的下标
    while (left < heapSize) { // 下方还有孩子的时候
        // 两个孩子中，谁的值大，把下标给largest
        // 1）只有左孩子，left -> largest
        // 2) 同时有左孩子和右孩子，右孩子的值<= 左孩子的值，left -> largest
        // 3) 同时有左孩子和右孩子并且右孩子的值> 左孩子的值， right -> largest
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        // 父和较大的孩子之间，谁的值大，把下标给largest
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            break;
        }
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}
```

#### 3）部分有序数组变有序

给定一个数组，部分有序，意思就是现在数组元素的位置 距离 排好顺序后的位置 不超过k个单位

思想：最小的数一定在(0,k)上，因为若在k+1或者以后，最小数移动k位就无法到0的位置上了。第二小的一定在(1,k+1)，以此类推。这样 堆加一个，弹一个，因为是小根堆，弹出来的都是当前堆中最小的

```java
public static void sortedArrDistanceLessK(int[] arr, int k) {
    //若k=0 说明已经排好序了
    if (k == 0) {
        return;
    }
    // 默认小根堆
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    int index = 0;  //放入堆中的元素下标
    // 最小的数一定在(0,k)上，因为若在k+1或者以后，最小数移动k位就无法到0的位置上了
    //1、先把(0,k-1)上的数放入小根堆里
    for (; index <= Math.min(arr.length - 1, k - 1); index++) {
        heap.add(arr[index]);
    }

    //2、再把k上的数到堆里，然后弹出堆的第一个元素就是最小值，放进新数组。然后依次往后，堆加一个，弹一个
    int i = 0;	//排好序数组的下标
    for (; index < arr.length; i++, index++) {

        heap.add(arr[index]);
        arr[i] = heap.poll();
    }
    //3、等到元素都已经加过堆里面了，就把堆剩余的元素都弹出来，就是排好序的
    while (!heap.isEmpty()) {
        arr[i++] = heap.poll();
    }
}
```

### 7、class07

#### 1）最大线段重合问题，堆实现

题目：给定很多线段，每个线段都有两个数[start,end]，表示线段开始位置和结束为止，左右都是闭区间。规定：1、线段的开始和结束位置一定都是整数值，2、线段重合区域的长度必须 >= 1。返回线段最多重合区域中，包含了几条线段

由于重合线段的左端点必定是其中某一个线段的左端点。所以求每一个线段 以这个线段左端点开始重合线段的个数，然后返回最大的，即为所求。

```java
public static int maxCover3(int[][] m) {
    // m是二维数组，可以认为m内部是一个一个的一维数组
    // 每一个一维数组就是一个对象，也就是线段
    // 如下的code，就是根据每一个线段的开始位置排序
    // 比如, m = { {5,7}, {1,4}, {2,6} } 跑完如下的code之后变成：{ {1,4}, {2,6}, {5,7} }

    //1、首先把所有线段按左端点从小到大排序
    Arrays.sort(m, (a, b) -> (a[0] - b[0]));
    //2、创建小根堆，用于存放每一个线段的右端点
    PriorityQueue<Integer> heap = new PriorityQueue<>();
    //3、依次检验每个线段的 以这个线段左端点开头的重合线段的个数
    int max = 0;
    for (int[] line : m) {
        //4、若小根堆不为空 并且 小跟堆顶值小于当前线段的左端点，说明之前的这个线段不与当前线段重合，从小根堆中把它弹出。
        while (!heap.isEmpty() && heap.peek() <= line[0]) {
            heap.poll();
        }
        //5、此时小跟堆中线段都是与当前线段重合的，把当前线段的右端点也放进小根堆中
        heap.add(line[1]);
        //6、小根堆中存放线段右端点的数量就是与当前线段重合的线段数
        //若当前线段的重合线段数比之前的线段重合数大，更新max，否则继续遍历下一个线段
        max = Math.max(max, heap.size());
    }
    return max;
}
```

#### 2）加强堆

```java
//T一定要是非基础类型，有基础类型需求 包一层
public class HeapGreater<T> {

	private ArrayList<T> heap;				//堆
	private HashMap<T, Integer> indexMap;	//反向索引表
	private int heapSize;					//数组中表示堆的有效长度
	private Comparator<? super T> comp;		//比较器

	public HeapGreater(Comparator<? super T> c) {
		heap = new ArrayList<>();
		indexMap = new HashMap<>();
		heapSize = 0;
		comp = c;
	}

	public boolean isEmpty() {
		return heapSize == 0;
	}

	public int size() {
		return heapSize;
	}

	public boolean contains(T obj) {
		return indexMap.containsKey(obj);
	}

	public T peek() {
		return heap.get(0);
	}

	public void push(T obj) {
		//1、堆和反向索引表都要添加该元素
		heap.add(obj);
		indexMap.put(obj, heapSize);
		//2、将该元素向上heapInsert，继续变成堆
		heapInsert(heapSize++);
	}

	public T pop() {
		//1、获取要弹出的元素
		T ans = heap.get(0);
		//2、将要弹出的元素和最后一个元素交换
		swap(0, heapSize - 1);
		//3、反向索引表和堆 都要删除 交换后的最后一个元素(就是要弹出的元素)
		indexMap.remove(ans);
		heap.remove(--heapSize);
		//4、新换上来的元素，向下进行heapify，继续变成堆
		heapify(0);
		return ans;
	}

	//删除元素：就是把要删除的元素和最后一个元素互换 然后删除
	//经过该方法删除完某个元素后，仍满足堆
	public void remove(T obj) {
		//1、获取最后一个元素
		T replace = heap.get(heapSize - 1);
		//2、获取要删除元素的索引
		int index = indexMap.get(obj);
		//3、反向索引表删除该元素 堆逻辑删除数组最后一个位置
		indexMap.remove(obj);
		heap.remove(--heapSize);
		//如果要删除的元素不是最后一个元素
		if (obj != replace) {
			//4、将删除的元素的位置替换成原来最后一个元素 并更新原来最后一个元素的反向索引表
			heap.set(index, replace);
			indexMap.put(replace, index);
			//5、对原来最后一个元素进行调整，使其仍满足堆
			resign(replace);
		}
	}

	//对元素obj进行调整，使其仍满足堆
	public void resign(T obj) {
		//两个只会执行一个
		heapInsert(indexMap.get(obj));
		heapify(indexMap.get(obj));
	}

	// 请返回堆上的所有元素
	public List<T> getAllElements() {
		List<T> ans = new ArrayList<>();
		for (T c : heap) {
			ans.add(c);
		}
		return ans;
	}

	private void heapInsert(int index) {
		while (comp.compare(heap.get(index), heap.get((index - 1) / 2)) < 0) {
			swap(index, (index - 1) / 2);
			index = (index - 1) / 2;
		}
	}

	private void heapify(int index) {
		int left = index * 2 + 1;
		while (left < heapSize) {
			int best = left + 1 < heapSize && comp.compare(heap.get(left + 1), heap.get(left)) < 0 ? (left + 1) : left;
			best = comp.compare(heap.get(best), heap.get(index)) < 0 ? best : index;
			if (best == index) {
				break;
			}
			swap(best, index);
			index = best;
			left = index * 2 + 1;
		}
	}

	private void swap(int i, int j) {
		T o1 = heap.get(i);
		T o2 = heap.get(j);
		heap.set(i, o2);
		heap.set(j, o1);
		indexMap.put(o2, i);
		indexMap.put(o1, j);
	}

}
```



#### 3）手动改写堆题目，了解

题目：给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作，arr = [3,3,1,1,2,5...]，op=[T,T,T,F,T,F...]。一对arr[i]和op[i]就代表一个事件：用户号为arr[i]，op[i]=T就代表这个用户购买了一件商品，op[i]=F就代表这个用户退货了一件商品。现在你作为电商平台负责人，你想在每一个事件到来的时候，都给购买次数最多的前K名用户颁奖。所以每个事件发生后，你都需要一个得奖名单(得奖区)。

得奖系统的规则：

1.如果某个用户购买商品数为0，但是又发生了退货事件，则认为该事件无效，得奖名单和之前时一致

2.某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1

3.每次都是最多K个用户得奖，K也为传入的参数，如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果

4.得奖系统分为得奖区和候选区，任何用户只要购买数>0，就一定在这两个区域中的一个

5.购买数量最大的前K名用户进入得奖区，在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区

6.如果购买数不足以进入得奖区的用户，进入候选区

7.如果候选区购买数最多的用户，已经足以进入得奖区，该用户就会替换得奖区中购买数最少的用户（大于才能替换），如果得奖区中购买数最少的用户有多个，就替换最早进入得奖区的用户；如果候选区中购买数最多的用户有多个，机会会给最早进入候选区的用户。

8.候选区和得奖区是两套时间。因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有。

从得奖区出来进入候选区的用户，得奖区时间删除，进入候选区的事件就是当前事件的时间(可以理解为arr[i]和op[i]中的i)；

从候选区出来进入得奖区的用户，候选区时间删除，进入得奖区的事件就是当前事件的时间

9.如果某用户购买数等于0，不管在哪个区域都得离开，区域时间删除，离开是指彻底离开，哪个区域也不会找到该用户。如果下次该用户又发生购买行为，产生>0的购买数，会再次根据之前规则回到某个区域中，进入区域的时间重记

```java
public static class Customer {
    public int id;              //顾客id
    public int buy;             //顾客购买件数
    public int enterTime;       //顾客进入得奖区或者候选区的新时间

    public Customer(int v, int b, int o) {
        id = v;
        buy = b;
        enterTime = 0;
    }
}

//将购买件数高的顾客，放在候选区顶部；若购买件数相等，将早来的顾客放前面
//大根堆实现候选区
public static class CandidateComparator implements Comparator<Customer> {

    @Override
    public int compare(Customer o1, Customer o2) {
        return o1.buy != o2.buy ? (o2.buy - o1.buy) : (o1.enterTime - o2.enterTime);
    }

}

//将购买件数少的顾客，放在得奖区顶部；若购买件数相等，将早来的顾客放前面
//小根堆实现得奖区
public static class DaddyComparator implements Comparator<Customer> {

    @Override
    public int compare(Customer o1, Customer o2) {
        return o1.buy != o2.buy ? (o1.buy - o2.buy) : (o1.enterTime - o2.enterTime);
    }

}

public static class WhosYourDaddy {
    private HashMap<Integer, Customer> customers;  //顾客表，key -> 顾客id   value ->顾客信息
    private HeapGreater<Customer> candHeap;        //候选区，加强大根堆实现
    private HeapGreater<Customer> daddyHeap;       //得奖区，加强小根堆实现
    private final int daddyLimit;                  //得奖区人数的限制，问题中是K

    public WhosYourDaddy(int limit) {
        customers = new HashMap<Integer, Customer>();
        candHeap = new HeapGreater<>(new CandidateComparator());
        daddyHeap = new HeapGreater<>(new DaddyComparator());
        daddyLimit = limit;
    }

    // 当前处理i号事件，arr[i] -> id,  buyOrRefund
    public void operate(int time, int id, boolean buyOrRefund) {
        //1、若该顾客退货，并且顾客表都没有该顾客的信息，不进行操作，直接忽略
        if (!buyOrRefund && !customers.containsKey(id)) {
            return;
        }
        //2、若该顾客购货，并且顾客表没有该顾客的信息，说明该顾客是第一次购买商品，先在顾客表中记录上新顾客id，确保每个顾客都有记录
        if (!customers.containsKey(id)) {
            customers.put(id, new Customer(id, 0, 0));
        }
        //3、顾客表中获取顾客信息，判断此时事件是购买还是退货
        Customer c = customers.get(id);
        if (buyOrRefund) {
            c.buy++;
        } else {
            c.buy--;
        }
        //4、若顾客购买数变成0，将顾客表中信息移除。下次来的话在重新记录
        if (c.buy == 0) {
            customers.remove(id);
        }
        //5、经过事件后，候选区和得奖区都没有该顾客
        if (!candHeap.contains(c) && !daddyHeap.contains(c)) {
            //5.1、得奖区目前没满，直接加入得奖区
            if (daddyHeap.size() < daddyLimit) {
                c.enterTime = time;
                daddyHeap.push(c);
            } else {
                //5.2、得奖区满了，直接进入候选区
                c.enterTime = time;
                candHeap.push(c);
            }
        } else if (candHeap.contains(c)) {
            //6、之前候选区有该顾客，若购买数变成0，从候选区删除；否则对候选区进行调整，使它仍满足大根堆
            if (c.buy == 0) {
                candHeap.remove(c);
            } else {
                candHeap.resign(c);
            }
        } else {
            //7、之前得奖区有该顾客，若购买数变成0，从得奖区删除；否则对得奖区进行调整，使它仍满足小根堆
            if (c.buy == 0) {
                daddyHeap.remove(c);
            } else {
                daddyHeap.resign(c);
            }
        }
        //8、更新得奖区最新情况
        daddyMove(time);
    }

    //获取得奖区的顾客id集合
    public List<Integer> getDaddies() {
        List<Customer> customers = daddyHeap.getAllElements();
        List<Integer> ans = new ArrayList<>();
        for (Customer c : customers) {
            ans.add(c.id);
        }
        return ans;
    }

    //更新得奖区最新情况
    private void daddyMove(int time) {
        //1、候选区为空，不用更新得奖区
        if (candHeap.isEmpty()) {
            return;
        }
        //2、得奖区不满，将候选区的第一个放进来，也就是大根堆第一个放进来，并赋予最新事件的时间
        if (daddyHeap.size() < daddyLimit) {
            Customer p = candHeap.pop();
            p.enterTime = time;
            daddyHeap.push(p);
        } else {
            //3、得奖区满了，并且候选区不为空
            //4、检验候选区第一个是否满足替换得奖区第一个的条件
            if (candHeap.peek().buy > daddyHeap.peek().buy) {
                Customer oldDaddy = daddyHeap.pop();
                Customer newDaddy = candHeap.pop();
                oldDaddy.enterTime = time;
                newDaddy.enterTime = time;
                daddyHeap.push(newDaddy);
                candHeap.push(oldDaddy);
            }
        }
    }

}

//主函数，返回每次事件的得奖区的信息
public static List<List<Integer>> topK(int[] arr, boolean[] op, int k) {
    List<List<Integer>> ans = new ArrayList<>();
    WhosYourDaddy whoDaddies = new WhosYourDaddy(k);
    for (int i = 0; i < arr.length; i++) {
        //for循环遍历 每次事件的得奖区的信息
        whoDaddies.operate(i, arr[i], op[i]);
        ans.add(whoDaddies.getDaddies());
    }
    return ans;
}
```

### 8、class08

#### 1）前缀树

```java
 class Trie {
        //前缀树节点类型
        class Node {
            public int pass;    //有几个字符经过该节点
            public int end;      //有几个字符串以该结点结束
            public Node[] nexts;  //以数组下标为路的下一个节点。  数组下标0代表a  1代表b ...

            public Node() {
                pass = 0;
                end = 0;
                nexts = new Node[26];
            }
        }

        //头结点
        private Node root;

        public Trie() {
            root = new Node();
        }

        //往前缀树中加入字符串
        public void insert(String word) {
            if (word == null) {
                return;
            }
            //字符串拆成字符
            char[] str = word.toCharArray();
            Node node = root;       //node先指向根节点
            node.pass++;
            int path = 0;
            for (int i = 0; i < str.length; i++) { // 从左往右遍历字符
                path = str[i] - 'a'; // 由字符，对应成走向哪条路      a走0号路，b走1号路...
                //如果当前节点后面没有 这个字符的路
                if (node.nexts[path] == null) {
                    node.nexts[path] = new Node();
                }
                //node指向新的结点
                node = node.nexts[path];
                node.pass++;
            }
            node.end++;
        }

        //删除前缀树中的word
        public void erase(String word) {
            if (countWordsEqualTo(word) != 0) {
                char[] chs = word.toCharArray();
                Node node = root;
                node.pass--;
                int path = 0;
                for (int i = 0; i < chs.length; i++) {
                    path = chs[i] - 'a';
                    if (--node.nexts[path].pass == 0) {
                        node.nexts[path] = null;
                        return;
                    }
                    node = node.nexts[path];
                }
                node.end--;
            }
        }

        //word这个单词出现了几次
        public int countWordsEqualTo(String word) {
            if (word == null) {
                return 0;
            }
            char[] chs = word.toCharArray();
            Node node = root;
            int index = 0;
            for (int i = 0; i < chs.length; i++) {
                index = chs[i] - 'a';
                if (node.nexts[index] == null) {
                    //如果没路了，就是出现0次
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.end;
        }

        //pre前缀出现了几次
        public int countWordsStartingWith(String pre) {
            if (pre == null) {
                return 0;
            }
            char[] chs = pre.toCharArray();
            Node node = root;
            int index = 0;
            for (int i = 0; i < chs.length; i++) {
                index = chs[i] - 'a';
                if (node.nexts[index] == null) {
                    return 0;
                }
                node = node.nexts[index];
            }
            return node.pass;
        }
    }
```

#### 2）计数排序

```java
public static void countSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    int max = Integer.MIN_VALUE;
    for (int i = 0; i < arr.length; i++) {
        //1、先找到数组中的最大值，作为新数组的数组大小，因为新数组的下标代表原数组的值
        max = Math.max(max, arr[i]);
    }
    int[] bucket = new int[max + 1];
    for (int i = 0; i < arr.length; i++) {
        //2、创建一个新的数组，下标代表存的数值，新数组值代表 值为下标的这个数在原数组中的个数
        //新数组中间会有好多空着的
        bucket[arr[i]]++;
    }
    int i = 0;
    //3、然后把新数组依次遍历，就是排好序的了
    for (int j = 0; j < bucket.length; j++) {
        //遍历完所有 以这个下标为值的这个数
        while (bucket[j]-- > 0) {
            arr[i++] = j;
        }
    }
}
```

#### 3）基数排序

```java
// 基数排序, 十进制的最大位数digit
public static void radixSort(int[] arr, int digit) {
    final int radix = 10;
    int i = 0, j = 0;
    // 有多少个数准备多少个辅助空间
    int[] help = new int[arr.length];
    for (int d = 1; d <= digit; d++) { // 有多少位就进出几次。  1->个位  2->十位...
        //现在count[i]表示d位数字=i的一共有多少个
        int[] count = new int[radix]; // 规定count数组大小是10，10个空间，
        for (i = 0; i < arr.length; i++) {
            //1、获取数组元素第d位上的数，添加到count数组。现在count[i]表示d位数字=i的一共有多少个
            j = getDigit(arr[i], d);
            count[j]++;
        }
        for (i = 1; i < radix; i++) {
            //2、现在count[i]表示d位数字<=i的一共有多少个，后面就这样用
            count[i] = count[i] + count[i - 1];
        }
        for (i = arr.length - 1; i >= 0; i--) {
            //3、从右往左遍历获取d位上的数，count[j]表示d位<=j的个数，所以新数组0~count[j]-1上放的都是d位<=j的数，将它放在最右边就是count[j]-1上，核心就是从右往左放
            //只减count数组j下标的数量即可，>j下标的数量不用减，不耽误后面计算
            j = getDigit(arr[i], d);
            help[count[j] - 1] = arr[i];
            count[j]--;
        }
        for (i = 0; i < arr.length; i++) {
            //将d位排好序的数组更新到arr中。省了10个桶
            arr[i] = help[i];
        }
    }
}
```

#### 4）排序算法总结

|          | 时间复杂度 | 额外空间复杂度 | 稳定性 |
| :------: | :--------: | :------------: | :----: |
| 选择排序 |   O(N^2)   |      O(1)      |   无   |
| 冒泡排序 |   O(N^2)   |      O(1)      |   有   |
| 插入排序 |   O(N^2)   |      O(1)      |   有   |
| 归并排序 | O(N*logN)  |      O(N)      |   有   |
| 随机快排 | O(N*logN)  |    O(logN)     |   无   |
|  堆排序  | O(N*logN)  |      O(1)      |   无   |
| ======== |   ======   |   =========    | =====  |
| 计数排序 |    O(N)    |      O(M)      |   有   |
| 基数排序 |    O(N)    |      O(N)      |   有   |

总结：

1.不基于比较的排序，对样本数据有严格要求，不易改写

2.基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用

3.基于比较的排序，时间复杂度的极限是O(N*logN)

4.时间复杂度O(N*logN)，额外空间复杂度低于O(N)，且稳定的基于比较的排序是不存在的

5.为了绝对的速度选快排（快排的常数时间最快），为了省空间选堆排序，为了稳定性选归并

### 9、class09 -- 链表题目

#### 1）快慢指针练习

1.输入链表头节点，奇数长度返回中点，偶数长度返回上中点

```java
public static Node midOrUpMidNode(Node head) {
    //链表长度为0,1,2
    if(head == null || head.next == null || head.next.next == null){
        return head;
    }
    //链表长度为3个及以上
    //1、定义两个指针快指针和慢指针
    Node fast = head;
    Node slow = head;
    //2、慢指针一次走一位，快指针一次走两位
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

2.输入链表头节点，奇数长度返回中点，偶数长度返回下中点

```java
public static Node midOrDownMidNode(Node head) {
    //链表长度为0,1
    if(head == null || head.next == null){
        return head;
    }
    //链表长度为2个及以上
    Node fast = head.next;
    Node slow = head.next;
    while (fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

3.输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个

```java
public static Node midOrUpMidPreNode(Node head) {
    //链表长度为0，1，2
    if(head == null || head.next == null || head.next.next == null){
        return null;
    }
    //链表长度为3个及以上
    Node fast = head.next.next;
    Node slow = head;
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

4.输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

```java
public static Node midOrDownMidPreNode(Node head) {
    //链表长度为0,1
    if(head == null || head.next == null){
        return null;
    }
    //链表长度为2个及以上
    Node fast = head.next;
    Node slow = head;
    while(fast.next != null && fast.next.next != null){
        fast = fast.next.next;
        slow = slow.next;
    }
    return slow;
}
```

#### 2）判断一个链表是否为回文结构

题目：给定一个单链表的头节点head，请判断该链表是否为回文结构

```java
public static boolean isPalindrome3(Node head) {
    //没有节点或者一个结点默认是回文结构
    if(head == null || head.next == null){
        return true;
    }
    //1、利用快慢指针先找到链表中点
    Node slow = head;
    Node fast = head;
    while(fast.next != null && fast.next.next != null){
        slow = slow.next;
        fast = fast.next.next;
    }
    //此时slow指向的就是中点，让中点的next指向空
    //2、然后翻转链表
    Node pre = slow;
    Node cur = pre.next;
    pre.next = null;
    Node next = null;
    while(cur != null){
        //记录下一个节点位置
        next = cur.next;
        //翻转指针
        cur.next = pre;
        //移动两个指针，准备翻转后面的
        pre = cur;
        cur = next;
    }
    //3、从左往右，从右往左开始比对
    boolean res = true;
    Node tail = pre;
    while(head != null && tail != null){
        if(head.value != tail.value){
            //注意：若不相等记录false，然后后面还要将链表翻转回来
            res = false;
            break;
        }
        head = head.next;
        tail = tail.next;
    }
    //4、最后还要把链表翻转回来
    cur = pre.next;
    pre.next = null;
    while(cur != null){
        //记录下一个节点位置
        next = cur.next;
         //翻转指针
        cur.next = pre;
        //移动两个指针，准备翻转后面的
        pre = cur;
        cur = next;
    }
    return res;
}
```

#### 3）将单向链表按某值划分成左边小，中间相等，右边大的形式

题目：将单向链表按某值划分成左边小，中间相等，右边大的形式

```java
public static Node listPartition2(Node head, int pivot) {
    //1、准备6个指针
    Node sH = null; // small head
    Node sT = null; // small tail
    Node eH = null; // equal head
    Node eT = null; // equal tail
    Node mH = null; // big head
    Node mT = null; // big tail

    Node next = null;  //用来获取链表下一个元素
    while(head != null){
        //2、记录下一个节点，并把当前节点与其他节点分离开
        next = head.next;
        head.next = null;
        //3、若这个元素比pivot小
        if(head.value < pivot){
            if(sH == null){
                //3.1、说明现在sH和sT之间没有元素，直接添加
                sH = head;
                sT = head;
            } else {
                //3.2、说明现在sH和sT之间有元素
                sT.next = head;
                sT = head;
            }
        } else if(head.value == pivot){
            //4、若这个元素和pivot一样大
            if(eH == null){
                //4.1、说明现在eH和eT之间没有元素，直接添加
                eH = head;
                eT = head;
            } else {
                //4.2、说明现在eH和eT之间有元素
                eT.next = head;
                eT = head;
            }
        } else{
            //5、若这个元素比pivot大
            if(mH == null){
                //5.1、说明现在mH和mT之间没有元素，直接添加
                mH = head;
                mT = head;
            } else {
                //5.2、说明现在mH和mT之间有元素
                mT.next = head;
                mT = head;
            }

        }
        //6、继续看下一个元素
        head = next;
    }

    //7、开始连起来，不用管右区域，只关心左中区域
    if(sH != null){
        //7.1、左有中无
        if(eH == null){
            sT.next = mH;
        }else{
            //7.2、左有中有
            sT.next = eH;
            eT.next = mH;
        }
        return sH;
    } else {
        //7.3、左无中无
        if(eH == null){
            return mH;
        }else {
            //7.4、左无中有
            eT.next = mH;
            return eH;
        }
    }
    //        if (sT != null) { // 如果有小于区域
    //            sT.next = eH;
    //            eT = eT == null ? sT : eT; // 下一步，谁去连大于区域的头，谁就变成eT
    //        }
    //        // 下一步，一定是需要用eT 去接 大于区域的头
    //        // 有等于区域，eT -> 等于区域的尾结点
    //        // 无等于区域，eT -> 小于区域的尾结点
    //        // eT 尽量不为空的尾巴节点
    //        if (eT != null) { // 如果小于区域和等于区域，不是都没有
    //            eT.next = mH;
    //        }
    //        return sH != null ? sH : (eH != null ? eH : mH);
}
```

#### 4）复制带随机指针的链表

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

```java
public Node copyRandomList(Node head) {
    if(head == null){
        return null;
    }
    //1、先在第一个节点和第二个节点之间添加第一个节点的克隆，后面以此类推
    Node cur = head;    //记录老链表的当前节点
    Node next = null;   //记录老链表的下一个节点
    while(cur != null){
        next = cur.next;
        cur.next = new Node(cur.val);
        cur.next.next = next;
        cur = next;
    }

    //2、然后根据老节点的random找到新节点的random
    cur = head;
    Node copy = null;
    while(cur != null){
        next = cur.next.next;
        copy = cur.next;
        copy.random = cur.random == null ? null : cur.random.next;  //注意空指针问题
        cur = next;
    }

    //3、分离老链表和新链表，即更新老链表的next和新链表的next
    cur = head;
    Node res = cur.next;
    while(cur != null){
        next = cur.next.next;
        copy = cur.next;
        cur.next = next;
        copy.next = cur.next == null ? null : next.next;    //注意空指针问题
        cur = next;
    }
    return res;

}
```

### 10、class10

#### 1）两个单链表相交的一系列问题，难

题目：给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null。要求：如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。

```java
//如果两个链表相交，请返回相交的第一个节点。如果不相交，返回null
public static Node getIntersectNode(Node head1, Node head2) {
    //若某个链表为null，肯定不相交
    if (head1 == null || head2 == null) {
        return null;
    }
    //1、获取两个链表的入环节点，若无环返回null
    Node loop1 = getLoopNode(head1);
    Node loop2 = getLoopNode(head2);
    //2、两个无环节点，求相交的第一个节点
    if (loop1 == null && loop2 == null) {
        return noLoop(head1, head2);
    }
    //3、两个有环节点，求相交的第一个节点
    if (loop1 != null && loop2 != null) {
        return bothLoop(head1, loop1, head2, loop2);
    }
    //4、一个有环和一个无环的链表一定不会相交
    return null;
}

// 利用快慢指针找到链表第一个入环节点，如果无环，返回null
public static Node getLoopNode(Node head) {
    //先将0，1,2节点的情况写出来，防止后面fast为空
    if (head == null || head.next == null || head.next.next == null) {
        return null;
    }
    //1、定义快慢指针，一直遍历到两个指针指向同一个位置
    Node slow = head.next; // n1 -> slow
    Node fast = head.next.next; // n2 -> fast
    while (slow != fast) {
        if (fast.next == null || fast.next.next == null) {
            //若存在null说明链表肯定无环
            return null;
        }
        fast = fast.next.next;
        slow = slow.next;
    }
    //2、让快指针回到头节点位置，慢指针位置不变。让快指针也一次走一个节点，两个指针相遇的位置就是第一个入环节点的位置
    fast = head; // n2 -> walk again from head
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }
    return slow;
}

// 1、两个无环的链表可能相交
// 如果两个链表都无环，返回第一个相交节点，如果不相交，返回null
public static Node noLoop(Node head1, Node head2) {
    //如果两个链表其中一个为null，肯定不相交
    if (head1 == null || head2 == null) {
        return null;
    }
    //1、先统计一下两个链表的长度。为了后面把长部分走完，再一起走相同的部分，然后找到第一个相交节点
    Node cur1 = head1;
    Node cur2 = head2;
    int len1 = 0;
    int len2 = 0;
    while (cur1.next != null) {
        len1++;
        cur1 = cur1.next;
    }
    while (cur2.next != null) {
        len2++;
        cur2 = cur2.next;
    }
    //2、如果两个链表的最后一个节点不是同一个，说明他俩肯定没相交
    if (cur1 != cur2) {
        return null;
    }
    //3、让cur1指向长链表的头结点，cur2指向另一个链表的头节点
    cur1 = len1 > len2 ? head1 : head2; // 谁长，谁的头变成cur1
    cur2 = cur1 == head1 ? head2 : head1; // 谁短，谁的头变成cur2
    //4、先让长链表把长的那部分走完
    int n = Math.abs(len1 - len2);
    while (n != 0) {
        n--;
        cur1 = cur1.next;
    }
    //5、然后长链表和短链表再各自走完后面的部分，此时他俩后面的部分长度相等。直到走到他俩相交的第一个节点
    while (cur1 != cur2) {
        cur1 = cur1.next;
        cur2 = cur2.next;
    }
    return cur1;
}

// 2、一个有环一个无环的链表一定不会相交

// 3、两个有环的链表可能相交
// 两个有环链表，返回第一个相交节点，如果不想交返回null
// 两个有环链表可能有3种情况：
//  1.两个链表不相交。loop1 != loop2
//  2.两个链表相交之后才进入入环节点   loop1 == loop2  相交的节点在loop1前面
//  3.先进入入环节点，在环的途中两个节点相交 loop1 != loop2。loop1或者loop2都可作为第一个相交节点
public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
    Node cur1 = null;
    Node cur2 = null;
    if (loop1 == loop2) {
        //1、loop1 == loop2，两个链表相交之后才进入入环节点，相交的节点在loop1前面
        //方法和求两个无环节点的第一个相交节点类似，只是这次只需遍历里到loop1即可，之前是遍历到null
        cur1 = head1;
        cur2 = head2;
        //1.1、先统计一下两个链表从头节点到loop1的长度
        int len1 = 0;
        int len2 = 0;
        while (cur1 != loop1) {
            len1++;
            cur1 = cur1.next;
        }
        while (cur2 != loop2) {
            len2++;
            cur2 = cur2.next;
        }
        //1.2、cur1指向长链表，cur2指向短链表
        cur1 = len1 > len2 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        //1.3、让长链表先把长的那部分走完
        int n = Math.abs(len1 - len2);
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        //1.4、长短链表一块遍历，直到第一个交点
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    } else {
        //2、loop1 != loop2，开始从其中一个链表的入环节点开始遍历
        cur1 = loop1.next;
        while (cur1 != loop1) {
            //2.1、准备开始从loop1遍历一圈
            if (cur1 == loop2) {
                //2.2、若在遍历一圈的过程中找到了loop2，说明是先进入入环节点，在环的途中两个节点相交
                return loop2;  //返回loop1或loop2都可以。返回loop1是相对于loop2链表，返回loop2是相对于loop1链表
            }
            cur1 = cur1.next;
        }
        //2.3、此时遍历了一圈，都没有找到loop2，说明两个链表不相交，是两个独立的有环链表
        return null;
    }
}
```

#### 2）递归方式实现二叉树的先序、中序、后序遍历

```java
// 先序遍历
public static void pre(Node head) {
    if (head == null) {
        return;
    }
    System.out.println(head.value);
    pre(head.left);
    pre(head.right);
}

//中序
public static void in(Node head) {
    if (head == null) {
        return;
    }
    in(head.left);
    System.out.println(head.value);
    in(head.right);
}

//后序
public static void pos(Node head) {
    if (head == null) {
        return;
    }
    pos(head.left);
    pos(head.right);
    System.out.println(head.value);
}
```

#### 3）非递归方式实现二叉树的先序、中序、后序遍历

```java
//先序
//确保一个节点的右孩子先进栈左孩子后进栈，这样弹出的时候就能先弹出左孩子再弹出右孩子
public static void pre(Node head) {
    System.out.print("pre-order: ");
    if (head != null) {
        Stack<Node> stack = new Stack<Node>();
        //1、根节点进栈
        stack.add(head);
        while (!stack.isEmpty()) {
            //2、只要栈中有元素就弹出
            head = stack.pop();
            //3、弹出这个节点后，先将这个节点的右孩子进栈，再将这个节点的左孩子进栈
            //这样弹出的时候就能保证 根->左->右 这个顺序了
            System.out.print(head.value + " ");
            if (head.right != null) {
                stack.push(head.right);
            }
            if (head.left != null) {
                stack.push(head.left);
            }
        }
    }
    System.out.println();
}

//中序
public static void in(Node head) {
    System.out.print("in-order: ");
    if(head != null){
        Stack<Node> stack = new Stack<>();
        //1、先将根节点一直遍历左孩子到底并将其都压入栈中
        stack.push(head);
        while(head.left != null){
            head = head.left;
            stack.push(head);
        }
        while(!stack.isEmpty()){
            //2、弹出元素栈顶元素并打印
            head = stack.pop();
            System.out.print(head.value + " ");
            //3、然后将弹出元素的右孩子一直遍历它的左孩子到底并将其都压入栈中。这样从栈弹出的顺序就是 左根右
            if(head.right != null){
                head = head.right;
                stack.push(head);
                while(head.left != null){
                    head = head.left;
                    stack.push(head);
                }
            }
        }

    }
    System.out.println();
}

//后序1，使用两个栈
public static void pos1(Node head) {
    System.out.print("pos-order: ");
    if (head != null) {
        Stack<Node> s1 = new Stack<Node>();
        Stack<Node> s2 = new Stack<Node>();
        //1、根节点进栈
        s1.push(head);
        while (!s1.isEmpty()) {
            //2、只要栈中有元素就弹出，弹出不是打印，而是放入另一个栈
            head = s1.pop();
            s2.push(head);
            //3、弹出这个节点后，先将这个节点的左孩子进栈，再将这个节点的右孩子进栈
            //这样弹出的时候就能保证 根->右->左 这个顺序了
            if (head.left != null) {
                s1.push(head.left);
            }
            if (head.right != null) {
                s1.push(head.right);
            }
        }
        //4、再弹出另一个栈，因为进这个栈时是根右左，弹出时就是左右根了
        while (!s2.isEmpty()) {
            System.out.print(s2.pop().value + " ");
        }
    }
    System.out.println();
}

//后序2，使用一个栈，难
public static void pos2(Node h) {
    System.out.print("pos-order: ");
    if (h != null) {
        Stack<Node> stack = new Stack<Node>();
        stack.push(h);
        Node c = null;
        while (!stack.isEmpty()) {
            c = stack.peek();
            if (c.left != null && h != c.left && h != c.right) {
                stack.push(c.left);
            } else if (c.right != null && h != c.right) {
                stack.push(c.right);
            } else {
                System.out.print(stack.pop().value + " ");
                h = c;
            }
        }
    }
    System.out.println();
}
```

### 11、class11--二叉树题目

#### 1）层次遍历二叉树

```java
//层次遍历利用队列
public static void level(Node head) {
    if (head == null) {
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    //1、先将根节点入队列
    queue.add(head);
    while (!queue.isEmpty()) {
        //2、弹出队列元素
        Node cur = queue.poll();
        System.out.println(cur.value);
        //3、弹出一个元素后，如果有的话，将它左孩子和右孩子依次进入队列
        if (cur.left != null) {
            queue.add(cur.left);
        }
        if (cur.right != null) {
            queue.add(cur.right);
        }
    }
}
```

#### 2）二叉树的序列化和反序列化

```java
//先序序列化
public static Queue<String> preSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    pres(head, ans);
    return ans;
}

public static void pres(Node head, Queue<String> ans) {
    if (head == null) {
        ans.add(null);
    } else {
        ans.add(String.valueOf(head.value));
        pres(head.left, ans);
        pres(head.right, ans);
    }
}

//中序序列化
public static Queue<String> inSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    ins(head, ans);
    return ans;
}

public static void ins(Node head, Queue<String> ans) {
    if (head == null) {
        ans.add(null);
    } else {
        ins(head.left, ans);
        ans.add(String.valueOf(head.value));
        ins(head.right, ans);
    }
}

//后序序列化
public static Queue<String> posSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    poss(head, ans);
    return ans;
}

public static void poss(Node head, Queue<String> ans) {
    if (head == null) {
        ans.add(null);
    } else {
        poss(head.left, ans);
        poss(head.right, ans);
        ans.add(String.valueOf(head.value));
    }
}

//先序反序列化
public static Node buildByPreQueue(Queue<String> prelist) {
    if (prelist == null || prelist.size() == 0) {
        return null;
    }
    return preb(prelist);
}

public static Node preb(Queue<String> prelist) {
    String value = prelist.poll();
    if (value == null) {
        return null;
    }
    Node head = new Node(Integer.valueOf(value));
    head.left = preb(prelist);
    head.right = preb(prelist);
    return head;
}

//后序反序列化
public static Node buildByPosQueue(Queue<String> poslist) {
    if (poslist == null || poslist.size() == 0) {
        return null;
    }
    // 左右中  ->  stack(中右左)
    Stack<String> stack = new Stack<>();
    while (!poslist.isEmpty()) {
        stack.push(poslist.poll());
    }
    return posb(stack);
}

public static Node posb(Stack<String> posstack) {
    String value = posstack.pop();
    if (value == null) {
        return null;
    }
    Node head = new Node(Integer.valueOf(value));
    head.right = posb(posstack);
    head.left = posb(posstack);
    return head;
}

//层次序列化--利用队列
public static Queue<String> levelSerial(Node head) {
    Queue<String> ans = new LinkedList<>();
    if (head == null) {
        ans.add(null);
    } else {
        ans.add(String.valueOf(head.value));
        Queue<Node> queue = new LinkedList<Node>();
        queue.add(head);
        while (!queue.isEmpty()) {
            head = queue.poll(); // head 父   子
            if (head.left != null) {
                ans.add(String.valueOf(head.left.value));
                queue.add(head.left);
            } else {
                ans.add(null);
            }
            if (head.right != null) {
                ans.add(String.valueOf(head.right.value));
                queue.add(head.right);
            } else {
                ans.add(null);
            }
        }
    }
    return ans;
}

//层次反序列化--利用队列
public static Node buildByLevelQueue(Queue<String> levelList) {
    if (levelList == null || levelList.size() == 0) {
        return null;
    }
    Node head = generateNode(levelList.poll());
    Queue<Node> queue = new LinkedList<Node>();
    if (head != null) {
        queue.add(head);
    }
    Node node = null;
    while (!queue.isEmpty()) {
        node = queue.poll();
        node.left = generateNode(levelList.poll());
        node.right = generateNode(levelList.poll());
        if (node.left != null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
    return head;
}

public static Node generateNode(String val) {
    if (val == null) {
        return null;
    }
    return new Node(Integer.valueOf(val));
}
```

#### 3）将N叉树编码为二叉树

将N叉树某个节点的所有孩子 在转为二叉树时都遍历到这个节点的左数一直往右遍历，这样转换后保证唯一，转换后的二叉树所有节点的右孩子都是null

```java
// 多叉树结构
public static class Node {
    public int val;
    public List<Node> children;

    public Node() {
    }

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, List<Node> _children) {
        val = _val;
        children = _children;
    }
};

// 二叉树结构
public static class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}

// 只提交这个类即可
class Codec {
    // 编码为二叉树
    public TreeNode encode(Node root) {
        if (root == null) {
            return null;
        }
        //1、将多叉树的根节点放到二叉树的根节点上
        TreeNode head = new TreeNode(root.val);
        //2、递归调用将多叉树的根节点的孩子放到二叉树的左孩子一直往右遍历
        head.left = en(root.children);
        //二叉树的所有节点的右孩子一直为null
        return head;
    }

    private TreeNode en(List<Node> children) {
        TreeNode head = null;
        TreeNode cur = null;
        for (Node child : children) {
            TreeNode tNode = new TreeNode(child.val);
            if (head == null) {
                //1、head指向第一个孩子。整个for循环只执行一次，最终返回head
                head = tNode;
            } else {
                //2、将传来的所有孩子一直往右遍历
                cur.right = tNode;
            }
            cur = tNode;
            //3、这些孩子中也有孩子，递归调用将它们的孩子放到二叉树的左孩子一直往右遍历
            cur.left = en(child.children);
        }
        return head;
    }

    // 解码为多叉树
    public Node decode(TreeNode root) {
        if (root == null) {
            return null;
        }
        return new Node(root.val, de(root.left));
    }

    //生成多叉树传入节点的所有孩子
    public List<Node> de(TreeNode root) {
        List<Node> children = new ArrayList<>();
        //从根节点开始遍历
        while (root != null) {
            //1、二叉树的节点的左孩子是多叉树节点的第一个孩子
            Node cur = new Node(root.val, de(root.left));
            children.add(cur);
            //2、然后二叉树节点左孩子一直向右遍历，都是原节点的孩子们。
            root = root.right;
        }
        return children;
    }

}
```

#### 4）求二叉树最宽的层有多少节点

```java
public static int maxWidthNoMap(Node head) {
        if (head == null) {
            return 0;
        }
        Queue<Node> queue = new LinkedList<>();
        //1、根节点入队列
        queue.add(head);
        Node curEnd = head; // 当前层，最右节点是谁
        Node nextEnd = null; // 下一层，最右节点是谁
        int max = 0;           //最宽层的节点数
        int curLevelNodes = 0; // 当前层的节点数
        while (!queue.isEmpty()) {
            //2、弹出队列元素，并检查是否有左右孩子。若有，将它们依次设置为下一层的最右节点，随时记录
            Node cur = queue.poll();
            if (cur.left != null) {
                queue.add(cur.left);
                //为下一层做准备
                nextEnd = cur.left;
            }
            if (cur.right != null) {
                queue.add(cur.right);
                //为下一层做准备
                nextEnd = cur.right;
            }
            //3、弹出元素后，当前层节点数+1
            curLevelNodes++;
            //4、检验该节点是否为当前层最后一个节点。若是开始准备下一层，若不是继续弹出这层后面的节点
            if (cur == curEnd) {
                //5、当前层节点数与max比较
                max = Math.max(max, curLevelNodes);
                //6、为下一层做准备，下一层节点置为0，下一层的curEnd置为之前记录好的nextEnd
                curLevelNodes = 0;
                curEnd = nextEnd;
            }
        }
        return max;
    }
```

#### 5）在二叉树中找到一个节点的后继节点

```java
public static Node getSuccessorNode(Node node) {
    if (node == null) {
        return null;
    }
    //1、该节点有右子树，它右子树的最左节点就是该节点的后继节点
    if (node.right != null) {
        //指针指向它的右孩子，然后开始一直向左遍历
        node = node.right;
        while(node.left != null){
            node = node.left;
        }
        return node;
    } else { 
        //2、该节点无右子树，去找它爹
        // 该节点若作为它爹的左孩子，它爹就是该节点的后继节点；
        // 该节点若作为它爹的右孩子，那就找它爹的爹，一直往上遍历直到某个节点作为它爹的左孩子，这个爹即为所求。若到根节点都没找到，说明该节点没有后继节点
        Node parent = node.parent;
        while (parent != null && parent.right == node) { //parent为null说明遍历到根节点了
            // 当前节点若是它父亲节点右孩子，就一直往上遍历
            node = parent;
            parent = node.parent;
        }
        return parent;
    }
}
```

#### 6）附加题

题目：请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2次，压出折痕后展开，此时有3条折痕，从上到下依次是下折痕、下折痕和上折痕。

给定一个输入参数N，代表纸条都从下边向上方连续对折N次。请从上到下打印所有折痕的方向。

例：N=1时，打印：down；N=2时，打印：down down up

思路：转换成中序遍历二叉树问题

```java
public static void printAllFolds(int N) {
    //打印第一层第一个节点的状态，第一个节点为凹
    process(1, N, true);
    System.out.println();
}
//中序遍历这N层的节点状态。i表示当前节点在第i层
public static void process(int i, int N, boolean down) {
    //检验该层是否超出N了
    if (i > N) {
        return;
    }
    //1、先打印该节点下一层的左孩子，左孩子为凹
    process(i + 1, N, true);
    //2、打印节点
    System.out.print(down ? "凹 " : "凸 ");
    //3、最后打印该节点下一层的右孩子，右孩子为凸
    process(i + 1, N, false);
}
```

### 12、class12--二叉树题目

#### 1）判断二叉树是否是完全二叉树

```java
//1、非递归套路
public static boolean isCBT1(Node head) {
    if (head == null) {
        return true;
    }
    LinkedList<Node> queue = new LinkedList<>();
    // 是否遇到过左右两个孩子不双全的节点
    boolean leaf = false;
    Node l = null;
    Node r = null;
    queue.add(head);
    while (!queue.isEmpty()) {
        head = queue.poll();
        l = head.left;
        r = head.right;
        if (  //1、遇到了不双全的节点之后，leaf置为true，又发现下一个节点不是叶节点，不满足完全二叉树。遇到了不双全的节点，后面的节点应该都是叶子节点
            (leaf && (l != null || r != null))
            ||
            //2、某个节点有右孩子没有左孩子，不满足完全二叉树
            (l == null && r != null)
        ) {
            return false;
        }
        if (l != null) {
            queue.add(l);
        }
        if (r != null) {
            queue.add(r);
        }
        if (l == null || r == null) {
            //3、该节点是不双全的，leaf置为true。之后判断后面的节点是否为叶子节点
            leaf = true;
        }
    }
    return true;
}

//2、递归套路
public static boolean isCBT2(Node head){
    return process(head).isCBT;
}
//封装指定节点构成树的信息
public static class Info{
    public boolean isFull; //该节点构成的树是否是满二叉树
    public boolean isCBT;  //该节点构成的树是否是完全二叉树
    public int height; //该节点构成的树的高度
    public Info(boolean iF,boolean iC,int h){
        isFull = iF;
        isCBT = iC;
        height = h;
    }
}
public static Info process(Node x){
    if(x == null){
        return new Info(true,true,0);
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    ////这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height,rightInfo.height) + 1;
    //当左右树为满二叉树，并且左右树的高等相等时，该树才是满二叉树
    boolean isFull = leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height;

    //该二叉树是否是完全二叉树，只有4种可能
    boolean isCBT = false;
    if(isFull){
        //1、这棵树是满二叉树
        isCBT = true;
    }else if(leftInfo.isCBT && rightInfo.isFull && leftInfo.height == rightInfo.height + 1){
        //2、左树是完全二叉树，右树是满二叉树，且左树高度 = 右树高度 + 1
        isCBT = true;
    }else if(leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height + 1){
        //3、左树是满二叉树，右树是满二叉树，且左树高度 = 右树高度 + 1
        isCBT = true;
    }else if(leftInfo.isFull && rightInfo.isCBT && leftInfo.height == rightInfo.height){
        //4、左树是满二叉树，右树是完全二叉树，且左树高度 = 右树高度
        isCBT = true;
    }

    return new Info(isFull,isCBT,height);
}
```

#### 2）判断二叉树是否是搜索二叉树

搜索二叉树的条件：
	1、每个节点的左树和右树都是搜索二叉树
	2、每个节点左树的最大值 < 该节点，右树的最小值 > 该节点

```java
//存放某个节点构成树中的最大值和最小值以及是否是搜索二叉树
public static class Info {
    public boolean isBST;
    public int max;
    public int min;

    public Info(boolean i,int ma,int mi){
        isBST = i;
        max = ma;
        min = mi;
    }
}

//主函数，判断二叉树是否是搜索二叉树
public static boolean isBST2(Node head){
    if(head == null){
        return true;
    }
    return process(head).isBST;
}

//返回指定节点的树的信息
public static Info process(Node x){
    if(x == null){
        return null;
    }
    //获取该节点左右树的信息
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //先设置该节点的构成树的最大值和最小值，值都先设置为该节点，然后和左右树的去比较
    //这里其实没太大用，主要用于递归传递信息
    int max = x.value;
    int min = x.value;
    if(leftInfo != null){
        max = Math.max(leftInfo.max, max);
        min = Math.min(leftInfo.min,min);
    }
    if(rightInfo != null){
        max = Math.max(rightInfo.max, max);
        min = Math.min(rightInfo.min,min);
    }

    boolean isBST = true;
    //1、检验该节点的左右树是否是搜索二叉树
    if(leftInfo != null && !leftInfo.isBST || rightInfo != null && !rightInfo.isBST){
        isBST = false;
    }

    //2、检验该节点的左树的最大值是否 < 该节点，右树的最小值是否 > 该节点
    if(leftInfo != null && leftInfo.max >= x.value || rightInfo != null && rightInfo.min <= x.value){
        isBST = false;
    }
    return new Info(isBST,max,min);
}
```

#### 3）判断二叉树是否是平衡二叉树

 平衡二叉树的条件：
      1、每个节点的左树和右树都是平衡二叉树
      2、每个节点左右树的高度之差<2

```java
//存放某个节点构成树的高度以及是否是平衡二叉树
public static class Info{
    public boolean isBalanced;
    public int height;

    public Info(boolean i,int h){
        isBalanced = i;
        height = h;
    }
}
//主函数，判断二叉树是否是平衡二叉树
public static boolean isBalanced2(Node head){
    return process(head).isBalanced;
}

//返回指定节点的树的信息
public static Info process(Node x){
    if(x == null){
        return new Info(true,0);
    }
    //获取左右子树的信息
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //该节点树的高度
    //这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    boolean isBalanced = true;
    //1、要满足左树和右树都是平衡二叉树
    if(!leftInfo.isBalanced || !rightInfo.isBalanced){
        isBalanced = false;
    }
    //2、该节点左右树的高度之差<2。满足这两条该节点的树才是平衡二叉树
    if(Math.abs(leftInfo.height - rightInfo.height) > 1){
        isBalanced = false;
    }

    return new Info(isBalanced,height);
}
```

#### 4）二叉树节点间的最大距离

题目：给定一棵二叉树的头节点head，任何两个节点之间都存在距离，返回整颗二叉树的最大距离

最大距离只有如下可能：
      1、当最大距离不经过根节点时，最大距离 = 根节点的左子树最大距离 或者 根节点的右子树最大距离
      2、当最大距离经过根节点时，最大距离 = 根节点左子树的高度 + 根节点右子树的高度 + 1

```java
//存放某个节点构成树的节点间最大距离 和 这棵树的高度
public static class Info{
    public int maxDistance;
    public int height;
    public Info(int md,int h){
        maxDistance = md;
        height = h;
    }
}
//主函数，返回二叉树节点间的最大距离
public static int maxDistance2(Node head){
    return process(head).maxDistance;
}
//返回指定节点的树的信息
public static Info process(Node x){
    if(x == null){
        return new Info(0,0);
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    //1、最大距离不经过x节点，最大距离 = 根节点的左子树最大距离 或者 根节点的右子树最大距离
    int maxDistance = Math.max(leftInfo.maxDistance, rightInfo.maxDistance);
    //2、最大距离经过x节点，最大距离 = 根节点左子树的高度 + 根节点右子树的高度 + 1
    //maxDistance取3种结果中较大的那一个
    maxDistance = Math.max(maxDistance, leftInfo.height + rightInfo.height + 1);

    return new Info(maxDistance,height);
}
```

#### 5）判断二叉树是否是满二叉树

```java
//存放某个节点构成树是否为满树 和 这棵树的高度
public static class Info2 {
    public boolean isFull;
    public int height;

    public Info2(boolean f, int h) {
        isFull = f;
        height = h;
    }
}
//主函数，判断二叉树是否是满二叉树
public static boolean isFull2(Node head) {
    if (head == null) {
        return true;
    }
    return process2(head).isFull;
}
//返回指定节点的树的信息
public static Info2 process2(Node h) {
    if (h == null) {
        return new Info2(true, 0);
    }
    Info2 leftInfo = process2(h.left);
    Info2 rightInfo = process2(h.right);
    //这里其实没太大用，主要用于递归传递信息
    int height = Math.max(leftInfo.height, rightInfo.height) + 1;
    //该节点构成树是否为满二叉树的条件：左右子树都是满二叉树并且左右子树高度相等
    boolean isFull = leftInfo.isFull && rightInfo.isFull && leftInfo.height == rightInfo.height;
    return new Info2(isFull, height);
}
```

#### 6）求二叉树中最大搜索二叉子树的节点个数

题目：给定一棵二叉树的头节点head，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的节点个数。这道题说明整棵树不一定是搜索二叉树

```java
//节点构成树的相关信息
public static class Info {
    public int maxBSTSubtreeSize;  //当前节点构成树的最大搜索二叉子树的节点个数
    public int size; //当前节点构成树的所有节点个数。
    //注意：当 maxBSTSubtreeSize == size时，说明该节点构成树是搜索二叉树，这里我们不用单定义另一个变量isBST了
    public int max; //当前节点构成树的节点数值的最大值
    public int min; //当前节点构成树的节点数值的最小值

    public Info(int ms,int s,int ma,int mi){
        maxBSTSubtreeSize = ms;
        size = s;
        max = ma;
        min = mi;
    }
}
//主函数，返回二叉树中的最大搜索二叉子树的节点个数
public static int largestBSTSubtree(TreeNode head) {
    if(head == null){
        return 0;
    }
    return process(head).maxBSTSubtreeSize;
}
//返回指定节点构成树的信息
public static Info process(TreeNode x) {
    if (x == null) {
        //因为涉及到max和min，这里返回null而不返回对象，后面的分析过程中要注意空指针异常
        return null;
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    //这里其实没太大用，主要用于递归传递信息
    int size = (leftInfo == null ? 0 : leftInfo.size) + (rightInfo == null ? 0 : rightInfo.size) + 1;
    int max = x.val;
    int min = x.val;
    if (leftInfo != null) {
        max = Math.max(max,leftInfo.max);
        min = Math.min(min,leftInfo.min);
    }
    if (rightInfo != null) {
        max = Math.max(max,rightInfo.max);
        min = Math.min(min,rightInfo.min);
    }
    //该节点构成树的maxBSTSubtreeSize只有3种可能
    //1、整棵树不是搜索二叉树，取左树的maxBSTSubtreeSize
    int p1 = -1;  //给个默认值-1，如果左树不存在，后面3种可能取最大时，-1会被舍弃
    if(leftInfo != null){
        p1 = leftInfo.maxBSTSubtreeSize;
    }
    //2、整棵树不是搜索二叉树，取右树的maxBSTSubtreeSize
    int p2 = -1;
    if(rightInfo != null){
        p2 = rightInfo.maxBSTSubtreeSize;
    }
    //3、整棵树是搜索二叉树
    int p3 = -1;
    //3.1、先判断左右子树是否是搜索二叉树
    boolean leftIsBST = leftInfo == null ? true : (leftInfo.maxBSTSubtreeSize == leftInfo.size);
    boolean rightIsBST = rightInfo == null ? true : (rightInfo.maxBSTSubtreeSize == rightInfo.size);
    if(leftIsBST && rightIsBST){
        //3.2、然后判断该节点的左树的最大值是否 < 该节点，右树的最小值是否 > 该节点
        boolean leftMaxLessX = leftInfo == null ? true : (leftInfo.max < x.val);
        boolean rightMinMoreX = rightInfo == null ? true : (x.val < rightInfo.min);
        if(leftMaxLessX && rightMinMoreX){
            //这样这棵树才是搜索二叉树
            int leftSize = leftInfo == null ? 0 : leftInfo.size;
            int rightSize = rightInfo == null ? 0 : rightInfo.size;
            p3 = leftSize + rightSize + 1;
        }

    }
    //4、该节点构成树的maxBSTSubtreeSize是上面3种可能的最大值
    int maxBSTSubtreeSize = Math.max(Math.max(p1,p2),p3);
    return new Info(maxBSTSubtreeSize, size, max, min);
}
```

### 13、class13--二叉树题目

#### 1）找到二叉树中的最大搜索二叉子树并返回头节点

题目：给定一棵二叉树的头节点head，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵子树的头节点。这道题说明整棵树不一定是搜索二叉树

```java
public static Node maxSubBSTHead2(Node head) {
    if(head == null){
        return null;
    }
    return process(head).maxSubBSTHead;
}
public static class Info{
    public Node maxSubBSTHead;   //该节点构成树中的最大搜索二叉子树的节点
    public int maxSubBSTSize;    //该节点构成树中的最大搜索二叉子树的节点个数
    public int max;             //该节点构成树的节点数值的最大值
    public int min;             //该节点构成树的节点数值的最小值
    public Info(Node mh,int ms,int ma,int mi){
        maxSubBSTHead = mh;
        maxSubBSTSize = ms;
        max = ma;
        min = mi;
    }
}
public static Info process(Node x){
    if(x == null){
        return null;
    }
    Info leftInfo = process(x.left);
    Info rightInfo = process(x.right);
    int max = x.value;
    int min = x.value;
    int maxSubBSTSize = 0;
    Node maxSubBSTHead = null;
    if(leftInfo != null){
        max = Math.max(max, leftInfo.max);
        min = Math.min(min, leftInfo.min);
        //1、先把左树的maxSubBSTHead作为整棵树的maxSubBSTHead
        maxSubBSTHead = leftInfo.maxSubBSTHead;
        maxSubBSTSize = leftInfo.maxSubBSTSize;
    }
    if(rightInfo != null){
        max = Math.max(max, rightInfo.max);
        min = Math.min(min, rightInfo.min);
        if(rightInfo.maxSubBSTSize > maxSubBSTSize){
            //2、若右树的maxSubBSTSize大于左树，就先把右树的maxSubBSTHead作为整棵树的maxSubBSTHead
            maxSubBSTHead = rightInfo.maxSubBSTHead;
            maxSubBSTSize = rightInfo.maxSubBSTSize;
        }
    }
    //3、假如整棵树是搜索二叉树
    boolean leftIsBST = leftInfo == null ? true : leftInfo.maxSubBSTHead == x.left;
    boolean rightIsBST = rightInfo == null ? true : rightInfo.maxSubBSTHead == x.right;
    //3.1、确保左右树都是搜索二叉树
    if(leftIsBST && rightIsBST){
        //3.2、然后判断该节点的左树的最大值是否 < 该节点，右树的最小值是否 > 该节点
        boolean leftMaxLessX = leftInfo == null ? true : (leftInfo.max < x.value);
        boolean rightMinMoreX = rightInfo == null ? true : (rightInfo.min > x.value);
        if(leftMaxLessX && rightMinMoreX){
            //这样这棵树才是搜索二叉树
            int leftSize = leftInfo == null ? 0 : leftInfo.maxSubBSTSize;
            int rightSize = rightInfo == null ? 0 : rightInfo.maxSubBSTSize;
            maxSubBSTSize = leftSize + rightSize + 1;
            maxSubBSTHead = x;
        }
    }
    return new Info(maxSubBSTHead,maxSubBSTSize,max,min);
}
```



#### 2）在二叉树中找到两个节点的最近公共祖先

题目：给定一棵二叉树的头节点head，和另外两个节点a和b。返回a和b的最低公共祖先

在某个节点构成的树中找到了a和b，才有可能找到最近公共祖先，然后去看他的左右子树是否找到了，若找到，即为所求，若没找到，这个节点就是所有

```java
public static Node lowestAncestor2(Node head, Node a, Node b){
    return process(head,a,b).ans;
}
public static class Info{
    public boolean findA;  //在该节点构成树中找到了a
    public boolean findB;  //在该节点构成树中找到了b
    public Node ans;       //在该节点构成树中找到了最低公共祖先
    public Info(boolean fa,boolean fb,Node a){
        findA = fa;
        findB = fb;
        ans = a;
    }
}
public static Info process(Node x,Node a,Node b){
    if(x == null){
        return new Info(false,false,null);
    }
    Info leftInfo = process(x.left, a, b);
    Info rightInfo = process(x.right, a, b);
    //当前节点为a，或者在左树右树中找到了a，说明在该节点构成树中找到了a
    boolean findA = (x == a) || leftInfo.findA || rightInfo.findA;
    //当前节点为b，或者在左树右树中找到了b，说明在该节点构成树中找到了b
    boolean findB = (x == b) || leftInfo.findB || rightInfo.findB;
    Node ans = null;
    //在这棵树中只有找到了a和b，这棵树中才存在最低公共祖先
    if(findA && findB){
        if(leftInfo.ans != null){
            //1、在左树找到了答案
            ans = leftInfo.ans;
        }else if(rightInfo.ans != null){
            //2、在右树找到了答案
            ans = rightInfo.ans;
        }else{
            //3、左右树都没找到答案，并且在这颗树中已经找到了a和b，那就说明x就是最低公共祖先
            ans = x;
        }
    }
    return new Info(findA,findB,ans);
}
```

#### 3）派对的最大快乐值

题目：公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看作是一棵标准的、没有环的多叉树。树的头节点是公司唯一的老板，除老板外，每个员工都有唯一的直接上级。叶节点是没有任何下属的基层员工，除基层员工外，每个员工都有一个或多个直接下级。这个公司现在要办party，你可以决定哪些员工来，哪些员工不来。但是要遵循如下规则：1、如果某个员工来了，那么这员工的所有直接下级都不能来。2、派对的整体快乐值是所有到场员工快乐值的累加。3、你的目标是让派对的整体快乐值尽量大。

给定一个头节点boss，请返回派对的最大快乐值。

```java
public static int maxHappy2(Employee head){
    //取boss来或者不来中快乐值较大的
    return Math.max(process(head).yes,process(head).no);
}
public static class Info{
    public int yes;  //该节点来的时候的最大快乐值
    public int no;   //该节点不来的时候的最大快乐值
    public Info(int y,int n){
        yes = y;
        no = n;
    }
}
public static Info process(Employee x){
    if(x == null){
        return new Info(0,0);
    }
    int yes = x.happy;
    int no = 0;
    for (Employee e : x.nexts) {
        Info info = process(e);
        //1、当前节点来，它的直接下级一定不来。当前节点来时的最大快乐值 = 所有直接下级不来时的最大快乐值
        yes += info.no;
        //2、当前节点不来，它的直接下级可能来可能不来。当前节点来时的最大快乐值 = max（所有直接下级不来时的最大快乐值，所有直接下级来时的最大快乐值）
        no += Math.max(info.yes, info.no);
    }
    return new Info(yes,no);
}
```

### 14、class14--贪心算法题目

贪心算法类的题目一般用到排序和堆

#### 1）拼接所有字符串产生字典顺序最小的字符串

题目：给定一个由字符串组成的数组strs，必须把所有的字符串拼接起来，返回所有可能的拼接结果中，字典序最小的结果

贪心策略：要满足字符串拼接的字典序 a+b <= b+a

```java
public static class MyComparator implements Comparator<String> {
    @Override
    public int compare(String a, String b) {
        //比较器规则：字符串拼接 a+b <= b+a
        return (a + b).compareTo(b + a);
    }
}

public static String lowestString2(String[] strs) {
    if (strs == null || strs.length == 0) {
        return "";
    }
    Arrays.sort(strs, new MyComparator());
    String res = "";
    for (int i = 0; i < strs.length; i++) {
        res += strs[i];
    }
    return res;
}
```

#### 2）贪心算法题目二

题目：一些项目要占用一个会议室宣讲，会议室不能同时容纳两个项目的宣讲。给你每一个项目开始的时间和结束的时间，你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回最多的宣讲场次

贪心策略：每一次都选结束时间最早的

```java
//比较器：会议结束时间早的排在前面
public static class ProgramComparator implements Comparator<Program> {
    @Override
    public int compare(Program o1, Program o2) {
        return o1.end - o2.end;
    }

}
// 会议的开始时间和结束时间，都是数值，不会 < 0
public static int bestArrange2(Program[] programs) {
    Arrays.sort(programs, new ProgramComparator());
    int timeLine = 0;
    int result = 0;
    //1、依次遍历每一个会议，结束时间早的会议先遍历
    for (int i = 0; i < programs.length; i++) {
        if (timeLine <= programs[i].start) {
            //2、当前会议的开始时间 >= 上一个会议结束时间，这个会议才能加入
            result++;
            timeLine = programs[i].end;
        }
    }
    return result;
}
```

#### 3）分金条的最小花费

题目：一块金条切成两半，是需要花费和长度数值一样的铜板的。比如长度为20的金条，不管怎么切，都要花费20个铜板，一群人想整分整块金条，怎么分最省铜板？例如，给定数组[10,20,30]，代表一共三个人，整块金条长度为60，金条要分成10,20,30三个部分。如果先把60的金条分成10和50，花费60,；再把长度为50的金条分成20和30，花费50；一共花费110铜板。但如果先把长度60的金条分成30和30，花费60；再把长度为30的金条分成10和20，花费30；一共花费90铜板。输入一个数组，返回分割的最小代价

贪心策略：利用哈夫曼编码思想来切金条

```java
public static int lessMoney2(int[] arr) {
    //1、用小根堆来存放数组元素，从小到大排序
    PriorityQueue<Integer> pQ = new PriorityQueue<>();
    for (int i = 0; i < arr.length; i++) {
        pQ.add(arr[i]);
    }
    int sum = 0;
    int cur = 0;
    while (pQ.size() > 1) {
        //2、只要小根堆中元素超过1个，就弹出前两个，然后相加后再放回小根堆里，自动重新排序
        cur = pQ.poll() + pQ.poll();
        sum += cur;
        pQ.add(cur);
    }
    return sum;
}
```

#### 4）做项目的最大收益问题 IPO

题目：输入：正数数组costs、正数数组profits、正数K、正数M。costs[i]表示i号项目的花费，profits[i]表示i号项目在扣除花费之后还能挣到的钱（利润），K表示你只能串行地最多做k个项目，M表示你初始的资金。说明：每做完一个项目，马上获得的收益，可以支持你去做下一个项目。不能并行的做项目。输出：你最后获得的最大钱数。

贪心策略：小根堆，项目花费小的放前面；大根堆，纯利润高的放前面

```java
//项目类
public static class Program{
    public int p;  //纯利润
    public int c;  //项目的花费
    public Program(int p,int c){
        this.p = p;
        this.c = c;
    }
}
//比较器，项目花费小的放前面
public static class MinCostComparator implements Comparator<Program>{
    @Override
    public int compare(Program p1,Program p2){
        return p1.c - p2.c;
    }
}
//比较器，纯利润高的放前面
public static class MaxProfitComparator implements Comparator<Program>{
    @Override
    public int compare(Program p1,Program p2){
        return p2.p - p1.p;
    }
}
public static int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {
    //小根堆，项目花费小的放前面
    //也可以用排好序的数组来存放
    PriorityQueue<Program> minCostQ = new PriorityQueue<>(new MinCostComparator());
    //大根堆，纯利润高的放前面
    PriorityQueue<Program> maxProfitQ = new PriorityQueue<>(new MaxProfitComparator());
    //1、现将所有项目放进小根堆，自动按项目花费排序，小的放上面
    for(int i = 0; i < profits.length; i++){
        minCostQ.add(new Program(profits[i],capital[i]));
    }
    //2、开始进行选择项目，最多选k个
    for(int i = 0; i < k;i++){
        while(!minCostQ.isEmpty() && minCostQ.peek().c <= w){
            //3、将小跟堆中所有项目花费<=k的全部放到大根堆中
            maxProfitQ.add(minCostQ.poll());
        }
        //4、注意若经过调整后，大根堆仍然没有元素，说明没有符合条件的项目了，返回之前的最终资本
        if(maxProfitQ.isEmpty()){
            return w;
        }
        //5、最终资本=大根堆顶部即利润最高的项目 + 之前的资本
        w += maxProfitQ.poll().p;
    }
    return w;
}
```

#### 5）贪心算法题目五

题目：给定一个字符串str，只由' X '和' . '两种字符构成。' X '表示墙，不能放灯，也不需要点亮；' . '表示居民点，可以放灯，需要点亮。如果灯放在i位置，可以让i-1，i和i+1三个位置被点亮。返回如果点亮str中所有需要点亮的位置，至少需要几盏灯。

贪心策略：i，i+1，i+2是点时，灯放在i+1处。（这题贪心策略不太明显。。）

```java
public static int minLight2(String road) {
    char[] str = road.toCharArray();
    int i = 0;
    int light = 0;
    while (i < str.length) {
        //1、如果i位置是X不用放灯，去看下一个位置
        if (str[i] == 'X') {
            i++;
        } else {
            //2、i位置是点，无论越界，i+1,i+2上是点还是X，都要放灯
            light++;
            if (i + 1 == str.length) {
                //下一个位置越界，结束循环
                break;
            } else {
                if (str[i + 1] == 'X') {
                    //3、i位置是点，i+1位置是X，i上放灯，然后去看i+2位置
                    i = i + 2;
                } else {
                    //4、i位置是点，i+1位置是点，无论i+2是点还是X，i+1位置都要放灯(i+2是X时，i+1和i哪里放灯都行)，然后去看i+3位置
                    i = i + 3;
                }
            }
        }
    }
    return light;
}
```

### 15、class15--并查集题目

#### 1）省份数量

题目：有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。省份是一组直接或间接相连的城市，组内不含其他没有相连的城市。给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。返回矩阵中 省份 的数量

```java
public static int findCircleNum(int[][] isConnected) {
    int N = isConnected.length;
    UnionFind unionFind = new UnionFind(N);
    //因为矩阵是对称的，所以只需关注上三角形
    for(int i = 0; i < N; i++){
        for(int j = i+1; j < N; j++){
            if(isConnected[i][j] == 1){
                //i，j直接相连，将两个集合合并
                unionFind.union(i,j);
            }
        }
    }
    return unionFind.sets();
}

public static class UnionFind{
    //parent[i] = k   -->  i的父亲是k
    private int[] parent; 
    //size[i] = k ： 如果i是代表节点，size[i]才有意义，否则无意义
    //i所在的集合大小是多少
    private int[] size;   
    //辅助结构，用来find过程中的路径压缩
    private int[] help;
    //一共有多少个集合
    private int sets;

    public int sets(){
        return sets;
    }

    public UnionFind(int N){
        parent = new int[N];
        size = new int[N];
        help = new int[N];
        sets = N;
        //初始化：将所有节点的父节点都设置为自己，并将所有集合的大小设置为1
        for(int i = 0; i < N; i++){
            parent[i] = i;
            size[i] = 1;
        }
    }

    //从i开始一直往上，往上到不能再往上，返回代表节点
    //这个过程要做路径压缩，即把沿途上的节点父节点都改成顶端的代表节点
    public int find(int i){
        int hi = 0;
        //1、检查节点，找到代表节点
        while(i != parent[i]){
            //1.1、将沿途节点存放到help数组
            help[hi] = i;
            hi++;
            //1.2、检查上一个节点
            i = parent[i];
        }
        //2、路径压缩
        for(hi--; hi >=0; hi--){
            parent[help[hi]] = i;
        }
        return i;
    }

    //两个集合合并，小的合在大的上
    public void union(int i,int j){
        int f1 = find(i);
        int f2 = find(j);
        if(f1 != f2){
            if(size[f1] >= size[f2]){
                parent[f2] = f1;
                size[f1] += size[f2];
                size[f2] = 0;
            } else{
                parent[f1] = f2;
                size[f2] += size[f1];
                size[f1] = 0;
            }
            sets--;
        }
    }
}
```

#### 2）岛屿数量

题目：给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

```java
public static int numIslands(char[][] grid) {
    int row = grid.length;
    int col = grid[0].length;
    UnionFind uf = new UnionFind(grid);

    //检查某个节点的左边和上边就能都检查完

    //先判断第一行
    for(int i = 1;i < col; i++){
        if(grid[0][i] == '1' && grid[0][i-1] == '1'){
            //检查当前节点和左边节点
            uf.union(0,i-1,0,i);
        }
    }
    //再判断第一列
    for(int j = 1; j < row; j++){
        if(grid[j][0] == '1' && grid[j-1][0] == '1'){
            //检查当前节点和上边节点
            uf.union(j-1,0,j,0);
        }
    }
    //先判断玩第一行和第一列，避免边界讨论
    //判断剩下部分
    for(int i = 1; i < row; i++){
        for(int j = 1; j < col; j++){
            if(grid[i][j] == '1'){
                //检查当前节点和左边节点
                if(grid[i][j-1] == '1'){
                    uf.union(i,j,i,j-1);
                }
                //检查当前节点和上边节点
                if(grid[i-1][j] == '1'){
                    uf.union(i,j,i-1,j);
                }
            }
        }
    }

    return uf.sets();

}

public static class UnionFind{
    private int[] parent;   //每个节点的代表节点
    private int[] size;     //这个集合的大小
    private int[] help;     //路径压缩时用的辅助数组
    private int sets;       //集合的数量
    private int col;        //二维数组的列数

    public UnionFind(char[][] grid){
        sets = 0;
        col = grid[0].length;
        int row = grid.length;
        int len = row * col;
        parent = new int[len];
        size = new int[len];
        help = new int[len];
        for(int r = 0; r < row; r++){
            for(int c = 0; c < col; c++){
                if(grid[r][c] == '1'){
                    int i = index(r,c);
                    parent[i] = i;
                    size[i] = 1;
                    sets++;
                }
            }
        }
    }

    //将二维数组的下标转成一维数组下标
    public int index(int r,int c){
        return r*col + c;
    }

    //并
    public void union(int r1,int c1,int r2,int c2){
        int i1 = index(r1,c1);
        int i2 = index(r2,c2);
        int f1 = find(i1);
        int f2 = find(i2);
        if(f1 != f2){
            if(size[f1] >= size[f2]){
                parent[f2] = f1;
                size[f1] += size[f2];
                size[f2] = 0;
            }else {
                parent[f1] = f2;
                size[f2] += size[f1];
                size[f1] = 0;
            }
            sets--;
        }
    }

    //查
    public int find(int i){
        int hi = 0;
        while(i != parent[i]){
            //检查上一个点
            i = parent[i];
            //记录沿途的点
            help[hi++] = i;
        }
        //路径压缩
        for(hi--; hi >= 0; hi--){
            parent[help[hi]] = i;
        }
        return i;
    }

    //集
    public int sets(){
        return this.sets;
    }

} 
```

### 16、class16--图

#### 1）图的宽度优先遍历（BFS）

```java
public static void bfs(Node start) {
    if (start == null) {
        return;
    }
    Queue<Node> queue = new LinkedList<>();
    HashSet<Node> set = new HashSet<>();    //用来防止重复节点继续入队列
    queue.add(start);
    set.add(start);
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        System.out.println(cur.value);
        for (Node next : cur.nexts) {
            if (!set.contains(next)) {
                //set里面没有才能进队列
                set.add(next);
                queue.add(next);
            }
        }
    }
}
```

#### 2）图的深度优先遍历（DFS）

```java
public static void dfs(Node start) {
    if (start == null) {
        return;
    }
    Stack<Node> stack = new Stack<>();      //栈里面存的是目前的整条路径
    HashSet<Node> set = new HashSet<>();    //用来记录已经打印过的节点，避免重复打印
    stack.add(start);
    set.add(start);
    //压入栈就打印
    System.out.println(start.value);
    while (!stack.isEmpty()) {
        //准备遍历当前弹出节点的所有邻接节点
        Node cur = stack.pop();
        for (Node next : cur.nexts) {
            if (!set.contains(next)) {
                //只要set集合中没有记录该邻接节点，就将当前节点和该邻接节点压入栈，并且结束循环不去检查其他邻接节点了
                stack.push(cur);
                stack.push(next);
                set.add(next);
                //压入栈就打印
                System.out.println(next.value);
                break;
            }
        }
    }
}
```

#### 3）图的拓扑排序

返回入度为0的点，然后将这个点和相关边删除，再返回入度为0的点，依次类推，形成拓扑排序。

注意：拓扑排序一般不唯一

```java
public static List<Node> sortedTopology(Graph graph) {
    // key->某个节点  value->这个节点的入度
    HashMap<Node, Integer> inMap = new HashMap<>();
    // 只有入度为0的点，才进入这个队列
    Queue<Node> zeroInQueue = new LinkedList<>();

    for (Node node : graph.nodes.values()) {
        //1、将所有节点和入度信息存入inMap
        inMap.put(node, node.in);
        if (node.in == 0) {
            //2、若节点入度为0，存入队列
            zeroInQueue.add(node);
        }
    }
    List<Node> result = new ArrayList<>();
    while (!zeroInQueue.isEmpty()) {
        //3、弹出队列第一个节点，并加入result
        Node cur = zeroInQueue.poll();
        result.add(cur);
        //4、删除该节点，就是把它所有邻接节点的入度都减1
        for (Node next : cur.nexts) {
            //邻接节点入度减1
            inMap.put(next, inMap.get(next) - 1);
            if (inMap.get(next) == 0) {
                zeroInQueue.add(next);
            }
        }
    }
    return result;
}
```

#### 4）最小生成树算法Kruskal

1、总是从权值最小的边开始考虑，依次考察权值依次变大的边。

2、当前的边要么进入最小生成树的集合，要么丢弃。

3、如果当前的边进入最小生成树的集合中不会形成环，就要当前边。

4、如果会形成环，就不要当前边。

5、考察完所有边之后，最小生成树的集合也得到了。

```java
//并查集
public static class UnionFind {
    // key 某一个节点， value key节点往上的节点
    private HashMap<Node, Node> fatherMap;
    // key 某一个集合的代表节点, value key所在集合的节点个数
    private HashMap<Node, Integer> sizeMap;

    public UnionFind() {
        fatherMap = new HashMap<Node, Node>();
        sizeMap = new HashMap<Node, Integer>();
    }
	
    //使所有节点各自成为集合
    public void makeSets(Collection<Node> nodes) {
        fatherMap.clear();
        sizeMap.clear();
        for (Node node : nodes) {
            fatherMap.put(node, node);
            sizeMap.put(node, 1);
        }
    }

    private Node findFather(Node n) {
        Stack<Node> path = new Stack<>();
        while(n != fatherMap.get(n)) {
            path.add(n);
            n = fatherMap.get(n);
        }
        while(!path.isEmpty()) {
            fatherMap.put(path.pop(), n);
        }
        return n;
    }

    public boolean isSameSet(Node a, Node b) {
        return findFather(a) == findFather(b);
    }

    public void union(Node a, Node b) {
        if (a == null || b == null) {
            return;
        }
        Node aDai = findFather(a);
        Node bDai = findFather(b);
        if (aDai != bDai) {
            int aSetSize = sizeMap.get(aDai);
            int bSetSize = sizeMap.get(bDai);
            if (aSetSize <= bSetSize) {
                fatherMap.put(aDai, bDai);
                sizeMap.put(bDai, aSetSize + bSetSize);
                sizeMap.remove(aDai);
            } else {
                fatherMap.put(bDai, aDai);
                sizeMap.put(aDai, aSetSize + bSetSize);
                sizeMap.remove(bDai);
            }
        }
    }
}
//边权重从小到大排序
public static class EdgeComparator implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight - o2.weight;
    }
}

public static Set<Edge> kruskalMST(Graph graph) {
    //1、将所有节点先各自称为集合
    UnionFind unionFind = new UnionFind();
    unionFind.makeSets(graph.nodes.values());
    //2、小根堆存入所有边，边的权重由小到大排序
    PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
    for (Edge edge : graph.edges) { // M 条边
        priorityQueue.add(edge);  // O(logM)
    }
    //用于收集最后最小生成树的边
    Set<Edge> result = new HashSet<>();
    while (!priorityQueue.isEmpty()) { // M 条边
        //3、按权重从小到大弹出边
        Edge edge = priorityQueue.poll(); // O(logM)
        if (!unionFind.isSameSet(edge.from, edge.to)) { // O(1)
            //4、只要这条边的from和to不是一个集合，就不会形成环。
            // 边集合加入这条边，合并两个节点
            result.add(edge);
            unionFind.union(edge.from, edge.to);
        }
    }
    return result;
}
```

#### 5）最小生成树算法Prim

1、可以从任意节点出发来寻找最小生成树

2、某个点加入到被选取的点中后，解锁这个点出发的所有新的边

3、在所有解锁的边中选最小的边，然后看着这个边会不会形成环

4、如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3

5、如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2

6、当所有点都被选取，最小生成树就得到了

```java
//边权重从小到大排序
public static class EdgeComparator implements Comparator<Edge> {
    @Override
    public int compare(Edge o1, Edge o2) {
        return o1.weight - o2.weight;
    }
}   
public static Set<Edge> primMST(Graph graph) {
    // 解锁的边进入小根堆
    PriorityQueue<Edge> priorityQueue = new PriorityQueue<>(new EdgeComparator());
    // 哪些点被解锁出来了
    HashSet<Node> nodeSet = new HashSet<>();
    // 依次挑选的的边在result里
    Set<Edge> result = new HashSet<>();
    // 随便挑了一个点，node 是开始点
    for (Node node : graph.nodes.values()) {
        if (!nodeSet.contains(node)) {
            //1、这个点被解锁了
            nodeSet.add(node);
            for (Edge edge : node.edges) { 
                //2、解锁这个点相连的边，按边的权重放入小根堆中
                priorityQueue.add(edge);
            }
            while (!priorityQueue.isEmpty()) {
                //3、弹出解锁的边中权重最小的
                Edge edge = priorityQueue.poll();
                //4、检查这条边的to节点
                Node toNode = edge.to; 
                if (!nodeSet.contains(toNode)) { // 点集合中没有，说明这是新的点
                    //5、这个点被解锁了，这条边加入result集合
                    nodeSet.add(toNode);
                    result.add(edge);
                    for (Edge nextEdge : toNode.edges) {
                        //6、解锁这个点相连的边
                        priorityQueue.add(nextEdge);
                    }
                }
            }
        }
        // break;
    }
    return result;
}
```

#### 6）从一个顶点到其余各顶点的最短路径算法Dijkstra

```java
public static HashMap<Node, Integer> dijkstra1(Node from) {
    //存放from节点到其他节点的距离(以下简称距离)
    HashMap<Node, Integer> distanceMap = new HashMap<>();
    distanceMap.put(from, 0);
    // 存放已经确定最短路径的节点
    HashSet<Node> selectedNodes = new HashSet<>();
    //1、先获取没有确定最短路径节点中距离最小的节点
    Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
    while (minNode != null) {
        //2、获取当前map中记录的距离
        int distance = distanceMap.get(minNode);
        for (Edge edge : minNode.edges) {
            //3、考察这个节点的所有边的to节点
            Node toNode = edge.to;
            if (!distanceMap.containsKey(toNode)) {
                //4、若to节点在map中没有数据，说明距离是正无穷，给to节点赋新值distance + edge.weight
                distanceMap.put(toNode, distance + edge.weight);
            } else { // toNode
                //5、若to节点在map中有数据，to节点距离取 map中数据和这次数据distance + edge.weight的较小值
                distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));
            }
        }
        //6、这个节点minNode已经确定，以后不在考虑，准备下一个没有确定最短路径节点中距离最小的节点
        selectedNodes.add(minNode);
        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);
    }
    return distanceMap;
}

public static Node getMinDistanceAndUnselectedNode(HashMap<Node, Integer> distanceMap, HashSet<Node> touchedNodes) {
    Node minNode = null;
    int minDistance = Integer.MAX_VALUE;
    for (Entry<Node, Integer> entry : distanceMap.entrySet()) {
        Node node = entry.getKey();
        int distance = entry.getValue();
        if (!touchedNodes.contains(node) && distance < minDistance) {
            minNode = node;
            minDistance = distance;
        }
    }
    return minNode;
}
```

#### 7）从一个顶点到其余各顶点的最短路径算法Dijkstra--加强堆

```java
public static class NodeRecord {
    public Node node;
    public int distance;

    public NodeRecord(Node node, int distance) {
        this.node = node;
        this.distance = distance;
    }
}

public static class NodeHeap {
    private Node[] nodes; // 实际的堆结构
    // key 某一个node， value 上面堆中的位置
    private HashMap<Node, Integer> heapIndexMap;
    // key 某一个节点， value 从源节点出发到该节点的目前最小距离
    private HashMap<Node, Integer> distanceMap;
    private int size; // 堆上有多少个点

    public NodeHeap(int size) {
        nodes = new Node[size];
        heapIndexMap = new HashMap<>();
        distanceMap = new HashMap<>();
        size = 0;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    // 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance
    // 判断要不要更新，如果需要的话，就更新
    public void addOrUpdateOrIgnore(Node node, int distance) {
        //update
        if (inHeap(node)) {
            distanceMap.put(node, Math.min(distanceMap.get(node), distance));
            insertHeapify(heapIndexMap.get(node));
        }
        //add
        if (!isEntered(node)) {
            nodes[size] = node;
            heapIndexMap.put(node, size);
            distanceMap.put(node, distance);
            insertHeapify(size++);
        }
    }

    public NodeRecord pop() {
        NodeRecord nodeRecord = new NodeRecord(nodes[0], distanceMap.get(nodes[0]));
        //将堆顶元素与堆最后一个元素交换位置，然后删除最后一个元素，再进行heapify，实现堆顶元素弹出
        swap(0, size - 1);
        heapIndexMap.put(nodes[size - 1], -1);
        distanceMap.remove(nodes[size - 1]);
        // free C++同学还要把原本堆顶节点析构，对java同学不必
        nodes[size - 1] = null;
        heapify(0, --size);
        return nodeRecord;
    }

    //将index上的数进行向上调整
    private void insertHeapify(int index) {
        while (distanceMap.get(nodes[index]) < distanceMap.get(nodes[(index - 1) / 2])) {
            swap(index, (index - 1) / 2);
            index = (index - 1) / 2;
        }
    }

    //将index上的数进行向下调整
    private void heapify(int index, int size) {
        int left = index * 2 + 1;
        while (left < size) {
            //选左右孩子中较小的
            int smallest = left + 1 < size && distanceMap.get(nodes[left + 1]) < distanceMap.get(nodes[left])
                ? left + 1
                : left;
            //选孩子和爹中较小的
            smallest = distanceMap.get(nodes[smallest]) < distanceMap.get(nodes[index]) ? smallest : index;
            if (smallest == index) {
                break;
            }
            swap(smallest, index);
            index = smallest;
            left = index * 2 + 1;
        }
    }

    private boolean isEntered(Node node) {
        //只要反向索引表中有数据，不管是-1还是其他的，说明这个节点已经进入过堆了
        return heapIndexMap.containsKey(node);
    }

    private boolean inHeap(Node node) {
        //若反向索引表中的值为-1，说明不在堆中，已经弹出了
        return isEntered(node) && heapIndexMap.get(node) != -1;
    }

    private void swap(int index1, int index2) {
        heapIndexMap.put(nodes[index1], index2);
        heapIndexMap.put(nodes[index2], index1);
        Node tmp = nodes[index1];
        nodes[index1] = nodes[index2];
        nodes[index2] = tmp;
    }
}

// 改进后的dijkstra算法
// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回
public static HashMap<Node, Integer> dijkstra2(Node head, int size) {
    NodeHeap nodeHeap = new NodeHeap(size); //加强堆
    //1、将head节点添加到加强堆中
    nodeHeap.addOrUpdateOrIgnore(head, 0);
    HashMap<Node, Integer> result = new HashMap<>(); //用于收集最后的结果
    while (!nodeHeap.isEmpty()) {
        //2、弹出加强堆中的节点，它的距离是最小的
        NodeRecord record = nodeHeap.pop();
        Node cur = record.node;
        int distance = record.distance;
        for (Edge edge : cur.edges) {
            //3、处理这个节点的所有边的to节点
            //若加强堆中没有，add。若此时的距离edge.weight + distance < 加强堆中的距离，update。若此时距离 >=加强堆中距离，ignore
            nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);
        }
        //4、该节点处理完成，以后不在讨论，放入到结果集
        result.put(cur, distance);
    }
    return result;
}
```

### 17、class17--暴力递归

#### 1）汉诺塔问题

```java
public static void hanoi2(int n) {
    if (n > 0) {
        func(n, "left", "right", "mid");
    }
}

public static void func(int N, String left, String right, String mid) {
    if (N == 1) {
        // base case，只有一个圆盘时，只需将它从左转移到右边
        System.out.println("Move 1 from " + left + " to " + right);
    } else {
        //1、将左边的n-1个圆盘借助right放到mid上
        func(N - 1, left, mid, right);
        //2、将左边最后一个圆盘从left放到right上
        System.out.println("Move " + N + " from " + left + " to " + right);
        //3、将mid上放好的n-1个圆盘借助left放到right上
        func(N - 1, mid, right, left);
    }
}
```

#### 2）打印一个字符串的全部子序列

```java
public static List<String> subs(String s) {
    char[] str = s.toCharArray();
    String path = "";
    List<String> ans = new ArrayList<>();
    process1(str, 0, ans, path);
    return ans;
}

	/**
     * 递归过程
     * @param str   固定参数，给定初始的字符串
     * @param index 来到了str[index]字符，index是当前位置
     * @param ans   将index及以后的所有生成的子序列放到ans里
     * @param path   path存放的是str[0..index-1]上的决定
     */
public static void process1(char[] str, int index, List<String> ans, String path) {
    if (index == str.length) {
        //若index越界，path就是最终结果
        ans.add(path);
        return;
    }
    //每个字符只有两个可能
    //1、不要index位置的字符
    process1(str, index + 1, ans, path);
    //2、要index位置的字符
    process1(str, index + 1, ans, path + String.valueOf(str[index]));
}
```

#### 3）打印一个字符串的全部排列

```java
public static List<String> permutation2(String s) {
    List<String> ans = new ArrayList<>();
    if (s == null || s.length() == 0) {
        return ans;
    }
    char[] str = s.toCharArray();
    g1(str, 0, ans);
    return ans;
}
//将str的所有字符从index开始全排列放到ans中
public static void g1(char[] str, int index, List<String> ans) {
    if (index == str.length) {
        //index越界，表示调整好了一种可能，将调整好的str放入ans中
        ans.add(String.valueOf(str));
    } else {
        for (int i = index; i < str.length; i++) {
            //1、将index上的字符与i上的字符互换。这样确保每个字符都有在index位置的情况
            swap(str, index, i);
            //2、将str的所有字符从index+1开始全排列放到ans中
            g1(str, index + 1, ans);
            //3、恢复现场。准备原index上的字符与i++上的字符互换
            //如果不恢复现场，一定会出现重复遗漏现象
            swap(str, index, i);
        }
    }
}
```

#### 4）使用递归函数逆序栈

给你一个栈，请你逆序这个栈，不能申请额外的数据结构，只能使用递归函数

思想：拿出一个元素，剩余元素递归，再把拿出的元素放到最后的位置

```java
//将栈中元素翻转
public static void reverse(Stack<Integer> stack){
    if(stack.isEmpty()){
        return;
    }
    //1、获取栈底元素
    int last = f(stack);
    //2、将栈中剩余元素翻转
    reverse(stack);
    //3、在将栈底元素放回栈顶
    stack.push(last);
}
//将栈底元素移除并返回
//递归过程中到最后一层才知道栈底元素last，然后一层一层返回，这样每层都知道last了。然后将每层弹出的栈顶元素result在放回去
public static int f(Stack<Integer> stack) {
    //1、弹出栈顶元素
    int result = stack.pop();
    if(stack.isEmpty()){
        //弹出元素后栈为空，说明这个元素是栈底元素，返回
        return result;
    } else{
        //2、获取此时栈底元素
        int last = f(stack);
        //3、将之前弹出的元素再放回栈中
        stack.push(result);
        return last;
    }
}
```

### 18、class18--从暴力递归到动态规划1

#### 1）机器人达到指定位置方法数

题目：假设有排成一行的N个位置，记为1~N，N一定大于或等于2，开始时机器人在其中的M位置上（M一定是1~N中的一个），如果机器人来到1位置，那么下一步只能往右来到2位置；如果机器人来到N位置，那么下一步只能往左来到N-1位置；如果机器人来到中间位置，那么下一步可以往左走或者往右走；规定机器人必须走K步，最终能来到P位置（P也是1~N中的一个）的方法有多少种。给定四个参数N、M、K、P，返回方法数

```java
//1、暴力递归
public static int ways1(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
        return -1;
    }
    return process1(start, K, aim, N);
}

public static int process1(int cur, int rest, int aim, int N) {
    //base case
    if (rest == 0) {
        //若已经走完K步了，cur与aim位置一样，方法数+1，否则为0
        return cur == aim ? 1 : 0;
    }
    if (cur == 1) {
        //1、当前机器人在1位置，它只能往2位置走
        return process1(2, rest - 1, aim, N);
    } else if (cur == N) {
        //2、当前机器人在N位置，它只能往N-1位置走
        return process1(N - 1, rest - 1, aim, N);
    } else {
        //3、当前机器人在中间位置，可以往左走，也可以往右走
        return process1(cur - 1, rest - 1, aim, N) + process1(cur + 1, rest - 1, aim, N);
    }
}

//2、动态规划
public static int ways3(int N, int start, int aim, int K) {
    if (N < 2 || start < 1 || start > N || aim < 1 || aim > N || K < 1) {
        return -1;
    }
    //建立dp表，第0行不参与赋值。行代表当前机器人位置，列代表机器人还剩几步可以走
    int[][] dp = new int[N + 1][K + 1];
    //1、将第一列初始化，只需将dp[aim][0] = 1，其他为0
    dp[aim][0] = 1;
    for (int rest = 1; rest <= K; rest++) {
        //2、处理第一行
        dp[1][rest] = dp[2][rest - 1];
        //3、处理中间行
        for (int cur = 2; cur <= N - 1; cur++) {
            dp[cur][rest] = dp[cur - 1][rest - 1] + dp[cur + 1][rest - 1];
        }
        //4、处理最后一行
        dp[N][rest] = dp[N-1][rest-1];
    }
    //5、返回dp表中的位置dp[start][K]为结果
    return dp[start][K];
}
```

#### 2）排成一条线的纸牌博弈问题

题目：给定一个整型数组arr，代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。

```java
//1、暴力递归
public static int win1(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    //1、先手玩家最终获得的分数
    int first = f1(arr, 0, arr.length - 1);
    //2、后手玩家最终获得的分数
    int second = g1(arr, 0, arr.length - 1);
    return Math.max(first, second);
}
//先手从L到R上选择最优的解
public static int f1(int[] arr, int L, int R) {
    //base case
    if (L == R) {
        return arr[L];
    }
    //1、先手挑最左边的牌后得到最优解
    int p1 = arr[L] + g1(arr, L + 1, R);
    //2、先手挑最右边的牌后得到最优解
    int p2 = arr[R] + g1(arr, L, R - 1);
    //3、先手选两种可能中最优的
    return Math.max(p1, p2);
}
//后手从L到R上选择最优的解
public static int g1(int[] arr, int L, int R) {
    //base case
    if (L == R) {
        return 0;
    }
    //1、先手的玩家先挑走了最左边的牌
    int p1 = f1(arr, L + 1, R);
    //2、先手的玩家先挑走了最右边的牌
    int p2 = f1(arr, L, R - 1);
    //3、后手玩家只能选两种可能中最差的，因为先手玩家一定是给后手剩下最差的
    return Math.min(p1, p2);
}

//2、动态规划
public static int win3(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    int N = arr.length;
    //建立两张dp表相互依赖。行代表L最左边的值，列代表R最右边的值
    int fDp[][] = new int[N][N];
    int gDp[][] = new int[N][N];
    //1、先将f表对角线初始化。g表对角线都是0，默认初始化好了
    for (int i = 0; i < N; i++) {
        fDp[i][i] = arr[i];
    }
    //2、开始从对角线上面一条对角线开始往上面对角线填，两张表交替填写对角线上的值
    for (int col = 1; col < N; col++) {
        int L = 0;
        int R = col;
        while (R < N) {  //列c 比行r 先越界
            //fDp表和gDp表用来替代之前的递归过程
            fDp[L][R] = Math.max(arr[L] + gDp[L + 1][R], arr[R] + gDp[L][R - 1]);
            gDp[L][R] = Math.min(fDp[L + 1][R], fDp[L][R - 1]);
            //准备填写下一个位置两个表的值
            L++;
            R++;
        }
    }
    //3、返回先手最优和后手最优中值较大的数
    return Math.max(fDp[0][N - 1], gDp[0][N - 1]);
}
```

### 19、class19--从暴力递归到动态规划2

#### 1）背包装最大价值问题

题目：给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表i号物品的重量和价值。给定一个正数bag，表示一个载重bag的袋子，你装的物品不能超过这个重量。返回你能装下最多的价值是多少？

```java
/**
     * 1、暴力递归
     *
     * @param w   i号物品的重量，没有负数
     * @param v   i号物品的价值，没有负数
     * @param bag 背包容量，装的物品不能超过这个重量
     * @return 返回不超重情况下，能够得到的最大价值
     */
public static int maxValue(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || w.length == 0) {
        return 0;
    }
    return process(w, v, 0, bag);
}
//此时背包还能装rest重量的物品，返回从index物品开始往后剩下物品的最大价值
//从0到w.length递归调用
public static int process(int[] w, int[] v, int index, int rest) {
    if (index == w.length) {
        return 0;
    }
    //1、不选当前物品
    int p1 = process(w, v, index + 1, rest);
    //2、选当前物品
    //注意：判断选完当前物品后是否超重，若超重，从index开始往后剩下物品的最大价值为0；若不超重，v[index] + 从index+1开始往后剩下物品的最大价值
    int p2 = rest - w[index] < 0 ? 0 : v[index] + process(w, v, index + 1, rest - w[index]);
    //3、返回价值较大的选择
    return Math.max(p1, p2);

}

//2、动态规划
public static int dp(int[] w, int[] v, int bag) {
    if (w == null || v == null || w.length != v.length || w.length == 0) {
        return 0;
    }
    int N = w.length;
    //1、建立dp表，行为当前物品的下标0~index，列为背包的剩余容量0~bag，bag为负数时单独处理
    int[][] dp = new int[N + 1][bag + 1];
    //2、初始化dp表，N行全部为0，已经初始化好了
    //3、填表，从下往上填，因为index行依赖index+1行
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= bag; rest++) {
            //4、不选当前物品
            int p1 = dp[index + 1][rest];
            //5、选当前物品。注意：判断选完当前物品后是否超重
            int p2 = rest - w[index] < 0 ? 0 : v[index] + dp[index + 1][rest - w[index]];
            dp[index][rest] = Math.max(p1, p2);
        }
    }

    //6、返回背包容量为bag，从0号物品开始的最大价值
    return dp[0][bag];

}
```

#### 2）数字字符串转换为字母组合的种数

题目：规定1和数字A对应、2和B对应、...26和Z对应。那么一个数字字符串比如“111”就可以转化为：AAA、KA和AK。给定一个只有数字字符组成的字符串str，返回有多少种转化结果

```java
/**
     * 1、暴力递归
     *
     * @param str str只含有数字字符0~9
     * @return 返回多少种转化方案
     */
public static int number(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    return process(str.toCharArray(), 0);
}
//0~i-1位置已经设置好，设置i位置以及往后的转化方案
public static int process(char[] c, int i) {
    if (i == c.length) {
        //此时所有字符串已经转化好了，转化方案数+1
        return 1;
    }
    if (c[i] == '0') {
        //如果当前字符是0，说明这个方案不行。0只能和10或者20才能符合题意
        return 0;
    }
    //1、选当前一个数字字符来转化。再获取i+1以后的方案数
    int num = process(c, i + 1);
    //2、选两个数字字符来转化。要先判断i+1是否越界以及这两个数字字符是否能转化为字母，再获取i+2以后的方案数
    if (i + 1 < c.length && (c[i] - '0') * 10 + c[i + 1] - '0' <= 26) {
        num += process(c, i + 2);
    }
    return num;
}

//2、动态规划
public static int dp1(String str) {
    if (str == null || str.length() == 0) {
        return 0;
    }
    char[] cs = str.toCharArray();
    int N = cs.length;
    //1、建立dp表。列代表当前字符的位置0~N
    int[] dp = new int[N + 1];
    //2、初始化dp表。0~N-1位置字符串已经设置好了，转化方案数+1
    dp[N] = 1;
    //3、填表
    for (int i = N - 1; i >= 0; i--) {
        //只有当前字符不是0才能继续，否则说明这个方案不行
        if (cs[i] != '0') {
            //4、选当前一个数字字符来转化。再获取i+1以后的方案数
            dp[i] = dp[i + 1];
            //5、选两个数字字符来转化。要先判断i+1是否越界以及这两个数字字符是否能转化为字母，再获取i+2以后的方案数
            if (i + 1 < cs.length && (cs[i] - '0') * 10 + cs[i + 1] - '0' <= 26) {
                dp[i] += dp[i + 2];
            }
        }
    }
    //6、返回从0位置开始的转化方案数
    return dp[0];
}
```

#### 3）贴纸拼词，难

给定一个字符串str，给定一个字符串类型的数组arr，出现的字符都是小写英文，arr每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来，返回需要至少多少张贴纸可以完成整个任务。

例：str=“babac”，arr={“ba”，“c”，“”abcd}。至少需要两张贴纸“ba”和“abcd”，因为使用这两张贴纸，把每一个字符单独剪开，含有2个a，2个b，1个c。是可以拼出str的，所以返回2。

```java
//核心思想：将stickers转化为二维词频表，将target转化为一维词频表
public int minStickers(String[] stickers, String target) {
    int counts[][] = new int[stickers.length][26];
    for(int i = 0; i < stickers.length; i++){
        char[] cs = stickers[i].toCharArray();
        for(char c : cs){
            //stickers转化为二维词频表
            counts[i][c - 'a']++;
        }       
    }
    //傻缓存，存放key所需的最小贴纸数量。（注意：无法列dp表，变量是字符串，没有明确的边界条件，只能用傻缓存优化）
    HashMap<String,Integer> dp = new HashMap<>();
    //先在map中加入key->"",value->0。递归调用一直到底后需要用到
    dp.put("",0);
    int ans = process(counts,target,dp);
    return ans == Integer.MAX_VALUE ? -1 : ans;
}

/**
     * @param stickers   有这些贴纸，二维数组形式
     * @param target          当前目标字符串target
     * @param dp         缓存表
     * @return           返回拼完当前target所需要的最少贴纸数
     */
public static int process(int[][] stickers, String target, HashMap<String, Integer> dp) {
    //map表中有直接用
    //若当前target为null，说明此时不需要贴纸，返回0。主函数已经提前设置好了
    if (dp.containsKey(target)) {
        return dp.get(target);
    }
    //target转化为一维词频表
    int tcounts[] = new int[26];
    char[] cs = target.toCharArray();
    for(char c : cs){
        tcounts[c - 'a']++;
    }

    int min = Integer.MAX_VALUE;
    //1、从第一张贴纸开始尝试，尝试那些包含当前target第一个字符的所有贴纸，然后取最小值
    for(int i = 0; i < stickers.length; i++){
        // 2、当前贴纸包含当前target第一个字符，才进行调整，避免不必要的遍历。
        // 最关键的优化(重要的剪枝!这一步也是贪心!)
        if(stickers[i][cs[0] - 'a'] > 0){
            //用来拼接 target在减去当前贴纸所有能用的字符 后剩下的字符
            StringBuilder builder = new StringBuilder();
            for(int j = 0; j < 26; j++){
                //3、检查26个字符的分布情况。确保这个字符需要贴纸来拼
                if(tcounts[j] > 0){
                    //4、返回用当前贴纸需要几张。即target中的这个字符有多少个
                    int num = tcounts[j] - stickers[i][j];
                    for(int k = 0; k < num; k++){
                        //5、builder装 用这张贴纸后，target还剩下的那些字符
                        builder.append((char)(j+'a'));
                    }
                }
            }
            String rest = builder.toString();
            //6、选择完这张贴纸后，min=剩下的那些字符返回需要的最小贴纸数。min最终会取所有可能中的最小数
            min = Math.min(min, process(stickers, rest, dp));
        }
    }
    //7、若min为maxValue说明无法拼成当前target，返回maxValue，否则返回min + 1，min是剩余字符的最小贴纸数，需要加上当前贴纸+1
    int ans = (min == Integer.MAX_VALUE ? min : min+1);
    //8、记录在傻缓存中
    dp.put(target,ans);
    return ans;
}
```

### 20、class20--从暴力递归到动态规划3

#### 1）最长公共子序列

题目：给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

```java
//1、暴力递归
public static int longestCommonSubsequence1(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
        return 0;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    return process1(str1, str2, str1.length - 1, str2.length - 1);
}

//返回str1从0到i上 和 str2从0到j上 的最长公共子序列
//从str1.length - 1 ~ 0, str2.length - 1 ~ 0的递归调用
public static int process1(char[] str1, char[] str2, int i, int j){
    if(i == 0 && j == 0){
        //1、两个字符串都只剩一个字符了
        return str1[i] == str2[j] ? 1 : 0;
    }else if(i == 0){
        //2、str1只剩一个字符了
        return str1[i] == str2[j] ? 1 : process1(str1,str2,i,j-1);
    }else if(j == 0){
        //3、str2只剩一个字符了
        return str1[i] == str2[j] ? 1 : process1(str1,str2,i-1,j);
    }else{
        //4、两个字符串都不止一个字符
        if(str1[i] == str2[j]){
            //4.1、两个字符串结尾相同
            return 1 + process1(str1,str2,i-1,j-1);
        }else{
            //4.2、两个字符串结尾不同。以下两种可能中较大的一定是对的
            //假设str1[i]不是公共的
            int p1 = process1(str1,str2,i-1,j);
            //假设str2[j]不是公共的
            int p2 = process1(str1,str2,i,j-1);
            return Math.max(p1,p2);
        }
    }
}

//2、动态规划
public static int longestCommonSubsequence2(String s1, String s2) {
    if (s1 == null || s2 == null || s1.length() == 0 || s2.length() == 0) {
        return 0;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    int M = s1.length();
    int N = s2.length();
    //建dp表并初始化
    int[][] dp = new int[M][N];
    //1、两个字符串都只剩一个字符了
    dp[0][0] = str1[0] == str2[0] ? 1 : 0;
    //2、str1只剩一个字符了
    for(int j = 1; j < N; j++){
        dp[0][j] = str1[0] == str2[j] ? 1 : dp[0][j-1];
    }
    //3、str2只剩一个字符了
    for(int i = 1; i < M; i++){
        dp[i][0] = str1[i] == str2[0] ? 1 : dp[i-1][0];
    }
    //4、两个字符串都不止一个字符
    for(int i = 1; i < M; i++){
        for(int j = 1; j < N; j++){
            if(str1[i] == str2[j]){
                //4.1、两个字符串结尾相同
                dp[i][j] = 1 + dp[i-1][j-1];
            }else{
                //4.2、两个字符串结尾不同。以下两种可能中较大的一定是对的
                //假设str1[i]不是公共的
                int p1 = dp[i-1][j];
                //假设str2[j]不是公共的
                int p2 = dp[i][j-1];
                dp[i][j] = Math.max(p1,p2);
            }
        }
    }
    return dp[M-1][N-1];
}
```

#### 2）最长回文子序列

题目：给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列

```java
//1、暴力递归
public static int lpsl1(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    return process(str, 0, s.length() - 1);
}

//返回str在L到R上的最长回文子序列
public static int process(char[] str, int L, int R) {
    if (L == R) {
        //1、当前字符串只剩一个字符了
        return 1;
    } else if (L == R - 1) {
        //2、当前字符串只剩两个字符了
        return str[L] == str[R] ? 2 : 1;
    } else {
        //3、当前字符串不止两个
        if (str[L] == str[R]) {
            //3.1、L上的字符和R上的字符一样
            return 2 + process(str, L + 1, R - 1);
        } else {
            //3.2、L上的字符和R上的字符不一样。以下两种可能中值较大的一定是对的
            //假设L上的字符不是回文子序列的一部分
            int p1 = process(str, L + 1, R);
            //假设R上的字符不是回文子序列的一部分
            int p2 = process(str, L, R - 1);
            return Math.max(p1, p2);
        }
    }
}

//2、动态规划
public static int lpsl2(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    int N = str.length;
    //建表，填表，dp表只需填上三角形即可
    int[][] dp = new int[N][N];
    //先将右下角最后一个元素赋值，避免赋值第二条对角线时越界
    dp[N - 1][N - 1] = 1;
    for (int i = 0; i < N - 1; i++) {
        //1、当前字符串只剩一个字符了
        dp[i][i] = 1;
        //2、当前字符串只剩两个字符了
        dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
    }
    //3、当前字符串不止两个，从N-3行开始往上填(N-1行和N-2行填完了)，每一行再从左往右填。
    for (int L = N - 3; L >= 0; L--) {
        for (int R = L + 2; R < N; R++) {
            if (str[L] == str[R]) {
                //3.1、L上的字符和R上的字符一样
                dp[L][R] = 2 + dp[L + 1][R - 1];
            } else {
                //3.2、L上的字符和R上的字符不一样。以下两种可能中值较大的一定是对的
                //假设L上的字符不是回文子序列的一部分
                int p1 = dp[L + 1][R];
                //假设R上的字符不是回文子序列的一部分
                int p2 = dp[L][R - 1];
                dp[L][R] = Math.max(p1, p2);
            }
        }
    }
    //4、返回从0到N-1上的最长回文子序列
    return dp[0][N - 1];
}
```

#### 3）马走棋盘问题

题目：请自行搜索或者想象一个象棋的棋盘，然后把整个棋盘放入第一象限，棋盘的最左下角是(0,0)位置，那么整个棋盘就是横坐标上9条线，纵坐标上10条线的区域。给你三个参数x,y,k，返回“马”从(0,0)位置出发，必须走k步，最后落在(x,y)上的方法数有多少种

```java
//1、暴力递归
public static int jump(int x, int y, int k) {
    //x-> 0~9  y-> 0~8
    //目的地越界 返回0
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    return process(0, 0, k, x, y);
}
//当前马在(a,b)位置，目的地是(x,y)位置，还剩rest步可以走
public static int process(int a, int b, int rest, int x, int y) {
    //1、当前位置已经越界
    if (a < 0 || a > 9 || b < 0 || b > 8) {
        return 0;
    }
    //2、所有步数已经走完。第0层只有(x,y)这个点为1，剩下的点都为0
    if (rest == 0) {
        return (a == x && b == y) ? 1 : 0;
    }
    //3、马走日，所以马只有8种走法。将这8中走法累加，其中无效的为0
    int num = process(a + 2, b + 1, rest - 1, x, y);
    num += process(a + 1, b + 2, rest - 1, x, y);
    num += process(a - 1, b + 2, rest - 1, x, y);
    num += process(a - 2, b + 1, rest - 1, x, y);
    num += process(a + 2, b - 1, rest - 1, x, y);
    num += process(a + 1, b - 2, rest - 1, x, y);
    num += process(a - 1, b - 2, rest - 1, x, y);
    num += process(a - 2, b - 1, rest - 1, x, y);

    return num;
}

//2、动态规划
public static int dp(int x, int y, int k) {
    //(x,y)是目的地。x-> 0~9  y-> 0~8
    //目的地越界 返回0
    if (x < 0 || x > 9 || y < 0 || y > 8) {
        return 0;
    }
    //建表，行是马此时的横坐标，列是马此时的纵坐标，高是马剩余可用的步数
    int[][][] dp = new int[10][9][k + 1];
    //1、所有步数已经走完。第0层只有(x,y)这个点为1，剩下的点都为0
    dp[x][y][0] = 1;
    //2、马走日，所以马只有8种走法。将这8中走法累加，其中无效的为0
    for (int rest = 1; rest <= k; rest++) {
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 9; j++) {
                //对于越界的那些点，没法一一赋值，建一个方法getDp()用来获取dp表中当前位置的信息
                dp[i][j][rest] = getDp(dp, i + 2, j + 1, rest - 1);
                dp[i][j][rest] += getDp(dp, i + 1, j + 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 1, j + 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 2, j + 1, rest - 1);
                dp[i][j][rest] += getDp(dp, i + 2, j - 1, rest - 1);
                dp[i][j][rest] += getDp(dp, i + 1, j - 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 1, j - 2, rest - 1);
                dp[i][j][rest] += getDp(dp, i - 2, j - 1, rest - 1);
            }
        }
    }
    //3、返回马从(0,0)走k步到(x,y)的方法数
    return dp[0][0][k];
}
//获取dp表中当前位置的信息，若当前位置越界返回0
public static int getDp(int[][][] dp, int a, int b, int rest) {
    //若当前位置已经越界，返回0
    if (a < 0 || a > 9 || b < 0 || b > 8) {
        return 0;
    }
    //若不越界，返回dp表中值
    return dp[a][b][rest];
}
```

#### 4）喝咖啡问题，难

题目：给定一个数组arr，arr[i]代表第i号咖啡机泡一杯咖啡的时间，给定一个正数N，表示N个人等着咖啡机泡咖啡，每台咖啡机只能轮流泡咖啡，只有一台洗咖啡机，一次只能洗一个杯子，时间消耗a，洗完才能洗下一杯，每个咖啡杯也可以自己挥发干净，时间消耗b，咖啡杯可以并行挥发。假设所有人拿到咖啡之后立刻喝干净，返回从开始等到所有咖啡机变干净的最短时间。三个参数：int[] arr、int N、int a、int b。

核心思想：首先求出每个人喝完咖啡的最优时间，即每个杯子可以开始洗的时间(小根堆)，再求出所有杯子变干净的最优时间(动态规划)

```java
//咖啡机信息
public static class Machine {
    public int timePoint;          //这个咖啡机可以开始冲咖啡的时间点
    public int workTime;           //这个咖啡机冲一杯咖啡所需要的时间

    //(1,3)代表1这个时间点可以开始冲咖啡，冲咖啡需要3
    public Machine(int t, int w) {
        timePoint = t;
        workTime = w;
    }
}
//比较器，冲完一杯咖啡时间点最早的排在前面
public static class MachineComparator implements Comparator<Machine> {
    @Override
    public int compare(Machine o1, Machine o2) {
        return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
    }
}

//1、暴力递归
public static int minTime1(int[] arr, int n, int a, int b) {
    PriorityQueue<Machine> heap = new PriorityQueue<Machine>(new MachineComparator());
    for (int i = 0; i < arr.length; i++) {
        //初始化小根堆，此时每台咖啡机都可以使用
        heap.add(new Machine(0, arr[i]));
    }
    //drink[i]代表第i号人喝完咖啡的时间，即第i号杯子可以开始洗的时间。利用小根堆，这个时间是最优的
    int[] drinks = new int[n];
    for (int i = 0; i < n; i++) {
        //选择最合适的咖啡机
        Machine cur = heap.poll();
        //更新这台咖啡机下一次可以冲咖啡的时间
        cur.timePoint += cur.workTime;
        heap.add(cur);
        //第i个人喝完咖啡的时间点，即第i号杯子可以开始洗的时间
        drinks[i] = cur.timePoint;
    }
    //从第0号杯子开始洗，此时洗咖啡机free=0,可以开始洗
    return bestTime(drinks, a, b, 0, 0);
}
/**
     * 洗完index及剩下杯子最早的结束时间
     *
     * @param drinks 所有杯子可以开始洗的时间
     * @param wash   单杯洗干净的时间（串行）
     * @param air    挥发干净的时间(并行)
     * @param index  第几号杯子
     * @param free   洗咖啡机什么时候可用
     * @return drinks[index.....]所有杯子都变干净，最早的结束时间（返回）
     */
public static int bestTime(int[] drinks, int wash, int air, int index, int free) {
    if (index == drinks.length) {
        //说明所有杯子都洗完了,就不用洗了
        return 0;
    }
    //1、index号杯子用洗咖啡机洗
    //index杯子洗完的时间
    int cleanIndex1 = Math.max(drinks[index], free) + wash;
    //剩余杯子变干净时间
    int cleanOther1 = bestTime(drinks, wash, air, index + 1, cleanIndex1);
    //所有杯子变干净的时间
    int p1 = Math.max(cleanIndex1, cleanOther1);

    //2、index号杯子挥发
    //index杯子挥发完的时间
    int cleanIndex2 = drinks[index] + air;
    //剩余杯子变干净时间
    int cleanOther2 = bestTime(drinks, wash, air, index + 1, free);
    //所有杯子变干净的时间
    int p2 = Math.max(cleanIndex2, cleanOther2);

    //3、就上面这两种可能,返回时间最早的
    return Math.min(p1, p2);
}

//2、动态规划
public static int minTime2(int[] arr, int n, int a, int b) {
    //1、建立小根堆，用来获取并排序每个杯子最早可以开始洗的时间
    PriorityQueue<Machine> heap = new PriorityQueue<>(new Comparator<Machine>() {
        @Override
        public int compare(Machine o1, Machine o2) {
            return (o1.timePoint + o1.workTime) - (o2.timePoint + o2.workTime);
        }
    });
    //初始化小根堆
    for (int i = 0; i < arr.length; i++) {
        heap.add(new Machine(0, arr[i]));
    }
    //每个杯子最早可以开始洗的时间
    int[] drinks = new int[n];
    for (int i = 0; i < n; i++) {
        //选择最合适的咖啡机
        Machine cur = heap.poll();
        //更新这台咖啡机的信息，并重新放回小根堆
        cur.timePoint += cur.workTime;
        heap.add(cur);
        //获取这个杯子可以开始洗的时间
        drinks[i] = cur.timePoint;
    }
    //2、动态规划，用来求所有杯子变干净的最优时间
    int maxFree = 0;
    for (int i = 0; i < n; i++) {
        //2.1、获取洗碗机能使用的最晚时间
        maxFree = Math.max(maxFree, drinks[i]) + a;
    }
    //建表，行是第几个杯子，列是洗咖啡机可以使用的时间点。因为列的范围不好规定，用最差情况来作为列的边界
    //dp[i][j]代表 在洗咖啡机j时间点可以使用时 第i号及剩下的所有杯子变干净的最早时间
    //dp[n][...] = 0; 建表时已经初始化好了，就不用在写了。第n行代表所有杯子都洗完了，就不用洗了
    int[][] dp = new int[n + 1][maxFree + 1];
    for (int index = n - 1; index >= 0; index--) {
        for (int free = 0; free <= maxFree; free++) {
            //2.2、index杯子就下面面这两种可能,返回时间最早的
            //2.2.1、index号杯子用洗咖啡机洗
            //index杯子洗完的时间
            int cleanIndex1 = Math.max(drinks[index], free) + a;
            if(cleanIndex1 > maxFree){
                //越界了，index号杯子后面的也不用填了
                break;
            }
            //剩余杯子变干净时间
            int cleanOther1 = dp[index + 1][cleanIndex1];
            //所有杯子变干净的时间
            int p1 = Math.max(cleanIndex1, cleanOther1);
            //2.2.2、index号杯子挥发
            //index杯子挥发完的时间
            int cleanIndex2 = drinks[index] + b;
            //剩余杯子变干净时间
            int cleanOther2 = dp[index + 1][free];
            //所有杯子变干净的时间
            int p2 = Math.max(cleanIndex2, cleanOther2);
            //2.2.3、就上面这两种可能,选择时间最早的
            dp[index][free] = Math.min(p1,p2);
        }
    }
    //2.3、返回在洗咖啡机0时间点可以使用时 第0号及剩下的所有杯子变干净的最早时间
    return dp[0][0];
}
```

### 21、class21--从暴力递归到动态规划4

#### 1）最小距离累加和

题目：给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角，沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和，返回最小距离累加和

```java
//动态规划，空间压缩
public static int minPathSum2(int[][] m) {
    if (m == null || m.length == 0 || m[0] == null || m[0].length == 0) {
        return 0;
    }
    int row = m.length;
    int col = m[0].length;
    //空间压缩，用一个数组来装一行的数据。因为每一行都能由上一行推出，最终能得到最后一行的数据
    // dp[i]最终代表(0,0)到(row-1,j)的最小距离累加和
    int[] dp = new int[col];
    dp[0] = m[0][0];
    //1、初始化第一行的数据
    for (int j = 1; j < col; j++) {
        dp[j] = dp[j - 1] + m[0][j];
    }
    //2、初始化剩下每一行的数据，最后dp表装的是最后一行的数据
    for (int i = 1; i < row; i++) {
        //3、初始化第i行第一列的数据
        dp[0] += m[i][0];
        for (int j = 1; j < col; j++) {
            //dp[j-1]：第i行左边的值   dp[j]：第i-1行上边的值
            //4、第i行第j列的数据取左边和上面最小的再加m[i][j]
            dp[j] = Math.min(dp[j - 1], dp[j]) + m[i][j];
        }
    }
    //5、此时dp表存放的是第row-1行的数据，返回col-1列的值即可
    return dp[col - 1];
}
```

#### 2）换钱的方法数(单张)

题目：arr是**货币**数组，其中的值都是正数，再给定一个正数aim。每个值都认为是一张货币，即便是值相同的货币也认为每一张都是不同的，返回组成aim的方法数。例如：arr = {1,1,1}，aim =2。第0个和第1个能组成2，第1个和第2个能组成2，第0个和第2个能组成2，一共就3种方法，所以返回3

```java
//1、暴力递归
public static int coinWays(int[] arr, int aim) {
    if (aim == 0) {
        //目标钱数为0，所有货币都不选即可，方法数为1
        return 1;
    }
    return process(arr, 0, aim);
}
// 当前讨论第index号货币，之前的已经讨论完了，此时还需要rest
public static int process(int[] arr, int index, int rest) {
    if (rest < 0) {
        return 0;
    }
    if (index == arr.length) {
        // 此时货币都讨论完了，没钱了。检验是否完成rest了
        return rest == 0 ? 1 : 0;
    } else {
        //第index号货币只有两种选择，要还是不要，将两种可能相加
        //不要
        int p1 = process(arr, index + 1, rest);
        //要
        int p2 = process(arr, index + 1, rest - arr[index]);
        return p1 + p2;
    }
}

//2、动态规划
public static int dp(int[] arr, int aim) {
    if (aim == 0) {
        //目标钱数为0，所有货币都不选即可，方法数为1
        return 1;
    }
    int N = arr.length;
    //建表，dp[i][j]表示目标j元钱，从第i号货币开始选择的方法数
    int[][] dp = new int[N + 1][aim + 1];
    //1、初始化表，(N,0)为1，剩下N行的所有列都是0。此时货币都讨论完了，没钱了，只有目标前为0，方法数才+1
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            //2、第index号货币只有两种选择，要还是不要，将两种可能相加
            //不要
            int p1 = dp[index + 1][rest];
            //要
            int p2 = rest - arr[index] < 0 ? 0 : dp[index + 1][rest - arr[index]];
            dp[index][rest] = p1 + p2;
        }
    }
    //3、返回目标aim元钱，从第0号货币开始选择的方法数
    return dp[0][aim];
}
```

#### 3）换钱的方法数(无限张)

题目：arr是**面值**数组，其中的值都是正数且没有重复，再给定一个正数aim。每个值都认为是一种面值，且认为张数是无限的，返回组成aim的方法数。例如：arr = {1,2}，aim =4。方法如下：1+1+1+1、1+1+2、2+2，一共就3种方法，所以返回3

```java
//1、暴力递归
public static int coinsWay(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    return process(arr, 0, aim);
}
// 当前讨论第index号钱，之前的已经讨论完了，此时还需要rest
public static int process(int[] arr, int index, int rest) {
    if (index == arr.length) {
        //index越界了，没钱了，若rest=0，方法数+1
        return rest == 0 ? 1 : 0;
    }
    int ways = 0;
    //每张钱都可以选择0,1,2.。。。张， 其中面值 * 张数 <= rest
    for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
        //由于rest - zhang * arr[index] >= 0，即每次递归调用，rest >=0，肯定不越界，故不用在做判断了
        ways += process(arr, index + 1, rest - zhang * arr[index]);
    }
    return ways;
}

//2、动态规划
public static int dp2(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    int N = arr.length;
    //建表，dp[i][j]表示目标j元钱，从第i号货币开始选择的方法数
    int[][] dp = new int[N + 1][aim + 1];
    //1、初始化表，(N,0)为1，剩下N行的所有列都是0。此时货币都讨论完了，没钱了，只有目标前为0，方法数才+1
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            //                //2.1、填表。直接3层循环填表，dp[index][rest]依赖dp[index + 1][rest - (zhang * arr[index])]满足条件下的所有位置
            //                //每张钱都可以选择0,1,2.。。。张， 其中面值 * 张数 <= rest
            //                int ways = 0;
            //                for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
            //                    ways += dp[index+1][rest - zhang * arr[index]];
            //                }
            //                dp[index][rest] = ways;
            //2.2、填表。通过列表观察！！发现dp[index][rest]依赖dp[index + 1][rest] 和 dp[index][rest - arr[index]](确保不越界)。避免了第3层for循环
            dp[index][rest] = dp[index + 1][rest] + (rest - arr[index] < 0 ? 0 : dp[index][rest - arr[index]]);
        }
    }
    //3、返回目标aim元钱，从第0号货币开始选择的方法数
    return dp[0][aim];
}
```

#### 4）换钱的方法数(有限张)

题目：arr是**货币**数组，其中的值都是正数，再给定一个正数aim。每个值都认为是一张货币，认为值相同的货币没有任何不同，返回组成aim的方法数。例如：arr = {1,2,1,1,2,1,2}，aim =4。方法：1+1+1+1、1+1+1、2+2，一共就3种方法，所以返回3

```java
//存放两个数组，一个coins[]类似题目2中的数组，另一个zhangs存放每种面值的钱有多少张
public static class Info {
    public int[] coins;     //每张钱的面值，正数且去重
    public int[] zhangs;    //每种面值的钱有多少张

    public Info(int[] c, int[] z) {
        coins = c;
        zhangs = z;
    }
}
//将原问题的数组arr转化成封装好的Info
public static Info getInfo(int[] arr) {
    HashMap<Integer, Integer> counts = new HashMap<>();
    for (int value : arr) {
        if (!counts.containsKey(value)) {
            counts.put(value, 1);
        } else {
            counts.put(value, counts.get(value) + 1);
        }
    }
    int N = counts.size();
    int[] coins = new int[N];
    int[] zhangs = new int[N];
    int index = 0;
    for (Entry<Integer, Integer> entry : counts.entrySet()) {
        coins[index] = entry.getKey();
        zhangs[index++] = entry.getValue();
    }
    return new Info(coins, zhangs);
}

//1、暴力递归
public static int coinsWay(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    Info info = getInfo(arr);
    return process(info.coins, info.zhangs, 0, aim);
}
// 当前讨论第index号钱，之前的已经讨论完了，此时还需要rest
public static int process(int[] coins, int[] zhangs, int index, int rest) {
    if (index == coins.length) {
        return rest == 0 ? 1 : 0;
    }
    int ways = 0;
    //！！！相比题目2，加了条件zhang <= zhangs[index]，确保张数不能越界
    for (int zhang = 0; zhang * coins[index] <= rest && zhang <= zhangs[index]; zhang++) {
        ways += process(coins, zhangs, index + 1, rest - (zhang * coins[index]));
    }
    return ways;
}    

//2、动态规划
public static int dp2(int[] arr, int aim) {
    if (arr == null || arr.length == 0 || aim < 0) {
        return 0;
    }
    Info info = getInfo(arr);
    int[] coins = info.coins;
    int[] zhangs = info.zhangs;
    int N = coins.length;
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 1;
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            //                //1、直接3层循环填表，dp[index][rest]依赖dp[index + 1][rest - (zhang * arr[index])]满足条件下的所有位置
            //                int ways = 0;
            //                //！！！相比题目2，加了条件zhang <= zhangs[index]，确保张数不能越界
            //                for (int zhang = 0; zhang * coins[index] <= rest && zhang <= zhangs[index]; zhang++) {
            //                    ways += dp[index + 1][rest - (zhang * coins[index])];
            //                }
            //                dp[index][rest] = ways;

            //2、通过列表观察！！发现dp[index][rest]依赖dp[index + 1][rest] 和 dp[index][rest - arr[index]](确保不越界)。避免了第3层for循环
            dp[index][rest] = dp[index + 1][rest];
            if (rest - coins[index] >= 0) {
                //确保不越界
                dp[index][rest] += dp[index][rest - coins[index]];
            }
            //！！！相比题目2，这里要减去当前rest不需要的部分(若存在的话)，即dp[index + 1][rest - coins[index] * (zhangs[index] + 1)];
            // 因为dp[index][rest]依赖的dp[index][rest - arr[index]]其中有一个值是当前rest不需要的部分，要减去
            if (rest - coins[index] * (zhangs[index] + 1) >= 0) {
                dp[index][rest] -= dp[index + 1][rest - coins[index] * (zhangs[index] + 1)];
            }
        }
    }
    return dp[0][aim];
}
```

#### 5）醉汉迈步

题目：给定5个参数，N，M，row，col，k。表示在N * M的区域上，醉汉Bob初始在(row，col)位置，Bob一共要迈出k步，且每步都会等概率向上下左右四个方向走一个单位，任何时候Bob只要离开N * M的区域就直接死亡。返回k步之后，Bob还在N*M的区域的概率。

```java
//1、暴力递归
public static double livePosibility1(int row, int col, int k, int N, int M) {
    //醉汉不死概率 = 醉汉从(row,col)开始走剩下所有的生存点数 / 总点数4^k。
    return (double) process(row, col, k, N, M) / Math.pow(4, k);
}
// 目前在row，col位置，还有rest步要走，走完了如果还在棋盘中就获得1个生存点，返回总的生存点数
public static long process(int row, int col, int rest, int N, int M) {
    //醉汉越界，这个生存点为0
    if (row < 0 || row == N || col < 0 || col == M) {
        return 0;
    }
    // 醉汉还在棋盘中，且要走的步数已经走完，方法数+1；
    if (rest == 0) {
        return 1;
    }
    // 醉汉还在棋盘中，还有步数要走，求出醉汉上下左右四种可能的生存点数
    long up = process(row - 1, col, rest - 1, N, M);
    long down = process(row + 1, col, rest - 1, N, M);
    long left = process(row, col - 1, rest - 1, N, M);
    long right = process(row, col + 1, rest - 1, N, M);
    return up + down + left + right;
}

//2、动态规划
public static double livePosibility2(int row, int col, int k, int N, int M) {
    //建表，dp[i][j][k]代表醉汉还有k步可以走，醉汉从(i,j)开始走剩下所有的生存点数
    long[][][] dp = new long[N][M][k + 1];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            //1、醉汉还在棋盘中，且要走的步数已经走完，方法数+1；
            dp[i][j][0] = 1;
        }
    }
    for (int rest = 1; rest <= k; rest++) {
        for (int r = 0; r < N; r++) {
            for (int c = 0; c < M; c++) {
                //2、醉汉还在棋盘中，还有步数要走，求出醉汉上下左右四种可能的生存点数
                dp[r][c][rest] = pick(dp, N, M, r - 1, c, rest - 1);
                dp[r][c][rest] += pick(dp, N, M, r + 1, c, rest - 1);
                dp[r][c][rest] += pick(dp, N, M, r, c - 1, rest - 1);
                dp[r][c][rest] += pick(dp, N, M, r, c + 1, rest - 1);
            }
        }
    }
    //3、醉汉不死概率 = 醉汉从(row,col)开始走剩下所有的生存点数 / 总点数4^k。
    return (double) dp[row][col][k] / Math.pow(4, k);
}
//pick函数，用来防止越界，越界返回0
public static long pick(long[][][] dp, int N, int M, int r, int c, int rest) {
    if (r < 0 || r == N || c < 0 || c == M) {
        return 0;
    }
    return dp[r][c][rest];
}
```

### 22、class22--从暴力递归到动态规划5

#### 1）英雄砍怪兽

题目：给定3个参数，N，M，K，怪兽有N滴血，等着英雄来砍自己，英雄每一次打击，都会让怪兽流失[0~M]的血量到底流失多少？每一次在[0~M]上等概率的获得一个值，求K次打击之后，英雄把怪兽砍死的概率。

```java
//1、暴力递归
public static double right(int N, int M, int K) {
    if (N < 1 || K < 1 || M < 1) {
        return 0;
    }
    double all = Math.pow(M + 1, K);
    long kill = process(K, M, N);
    return kill / all;
}

/**
     * @param times 还有times次可以砍
     * @param M     每次的伤害在[0~M]范围上
     * @param hp    怪兽还剩hp点血
     * @return 返回砍死的情况数
     */
public static long process(int times, int M, int hp) {
    if (times == 0) {
        //都砍完了
        return hp <= 0 ? 1 : 0;
    }
    if (hp <= 0) {
        //怪兽没血了，但是还可以砍
        return (long) Math.pow(M + 1, times);
    }
    //怪兽有血，并且还可以砍
    int ways = 0;
    for (int i = 0; i <= M; i++) {
        ways += process(times - 1, M, hp - i);
    }
    return ways;
}

//2、动态规划
public static double dp(int N, int M, int K) {
    if (N < 1 || M < 1 || K < 1) {
        return 0;
    }
    double all = Math.pow(M + 1, K);
    long[][] dp = new long[K + 1][N + 1];
    //1、怪兽没血(血为负就不列表里了)，并且砍的次数都用完了
    dp[0][0] = 1;
    for (int times = 1; times <= K; times++) {
        //2、怪兽没血(血为负就不列表里了),但是砍得次数还有
        dp[times][0] = (long) Math.pow(M + 1, times);
        for (int hp = 1; hp <= N; hp++) {
            //                //for循环遍历
            //                long ways = 0;
            //                for (int i = 0; i <= M; i++) {
            //                    if (hp - i > 0) {
            //                        //3、如果砍完当前之后怪兽还有血
            //                        ways += dp[times - 1][hp - i];
            //                    } else {
            //                        ways += (long) Math.pow(M + 1, times - 1);
            //                    }
            //                }
            //                dp[times][hp] = ways;
            //通过观察
            if(hp - M - 1 > 0){
                dp[times][hp] = dp[times][hp - 1] + dp[times - 1][hp] - dp[times - 1][hp - M - 1];
            }else {
                dp[times][hp] = dp[times][hp - 1] + dp[times - 1][hp] - (long) Math.pow(M + 1, times - 1);
            }
        }
    }
    long kill = dp[K][N];
    return kill / all;
}
```

#### 2）换钱的最少货币数(无限张)

题目：arr是面值数组，其中的值都是正数且没有重复。再给定一个正数aim，每个值都认为是一种面值，且认为张数是无限的。返回组成aim的最少货币数

```java
//1、暴力递归
public static int minCoins(int[] arr, int aim) {
    if (aim == 0) {
        return 0;
    }
    return process(arr, 0, aim);
}

//目标rest钱，当前讨论index号钱，前面的已经讨论完了，返回最小货币数
public static int process(int[] arr, int index, int rest) {
    if (index == arr.length) {
        //钱都用完了。若目标钱已经达成rest==0，说明不再需要货币了，返回0。若rest != 0，说明无法凑成rest，返回Integer.MAX_VALUE;
        return rest == 0 ? 0 : Integer.MAX_VALUE;
    }
    int ans = Integer.MAX_VALUE;
    for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
        //获取从index+1往后返回的最小货币数
        int next = process(arr, index + 1, rest - zhang * arr[index]);
        if (next != Integer.MAX_VALUE) {
            //index+1后面能够凑成rest，更新ans，选择较小的。若后面不能凑成，不更新
            ans = Math.min(ans, next + zhang);
        }
    }
    return ans;
}

//2、动态规划
public static int dp(int[] arr, int aim) {
    if (aim == 0) {
        return 0;
    }
    int N = arr.length;
    //dp[i][j]代表讨论第i张货币，此时还需要j元钱，这个情况下的最小货币数
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 0;
    for (int j = 1; j <= aim; j++) {
        dp[N][j] = Integer.MAX_VALUE;
    }
    for (int index = N - 1; index >= 0; index--) {
        for (int rest = 0; rest <= aim; rest++) {
            //                dp[index][rest] = Integer.MAX_VALUE;
            //                for(int zhang = 0; zhang * arr[index] <= rest; zhang++){
            //                    int next = dp[index + 1][rest - zhang * arr[index]];
            //                    if(next != Integer.MAX_VALUE){
            //                        dp[index][rest] = Math.min(dp[index][rest], next + zhang);
            //                    }
            //                }
            //通过观察,dp[index][rest]依赖index行中一堆元素中较小的，
            dp[index][rest] = dp[index + 1][rest];
            if (rest - arr[index] >= 0 && dp[index][rest - arr[index]] != Integer.MAX_VALUE) {
                //只有+1了，dp[index][rest-1]下面依赖的才能根dp[index][rest]下面依赖的最小货币数相等
                dp[index][rest] = Math.min(dp[index][rest], dp[index][rest - arr[index]] + 1);
            }
        }
    }
    return dp[0][aim];
}
```

#### 3）一个正数裂开的方法数

题目：给定一个正数1，裂开的方法有一种（1）。给定一个正数2，裂开的方式有两种（1、1）（2）。给定一个正数3，裂开的方法有三种（1、1、1）（1、2）（3）。给定一个正数4，裂开的方法有五种（1、1、1、1）（1、1、2）（1、3）（2、2）（4）。给定一个正数n，其中裂开的后面的数要大于等于前面的数，求裂开的方法数。

```java
//1、暴力递归
public static int ways(int n) {
    // n为正数，若为负，返回0
    if (n < 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    //n拆出来的数肯定是在[1,n]，这里pre初始值为1，就可以不耽误n的拆分
    return process(1, n);
}

/**
     * @param pre  上一个拆出来的数是pre
     * @param rest 还剩rest需要去拆
     * @return 返回拆解的方法数
     */
public static int process(int pre, int rest) {
    if (rest == 0) {
        //说明之前的拆分策略可以，方法数+1
        return 1;
    }
    if (pre > rest) {
        //此时已经不满足条件，这个方法不行，返回0
        return 0;
    }
    int ways = 0;
    //从rest中再拆出一个数，这个数要>=pre
    for (int one = pre; one <= rest; one++) {
        ways += process(one, rest - one);
    }
    return ways;

}

//2、动态规划
public static int dp(int n) {
    if (n < 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    //dp[i][j]代表上一个拆出来的数是i，此时还剩j需要去拆，这个情况下的裂开的方法数
    int[][] dp = new int[n + 1][n + 1];
    //第0行不用管
    for (int i = 1; i <= n; i++) {
        //第0列都是1，说明之前的拆分策略可以，方法数+1
        dp[i][0] = 1;
        //对角线pre == rest，拆分方法只有一种
        dp[i][i] = 1;
    }
    for (int pre = n - 1; pre >= 1; pre--) {
        for (int rest = pre + 1; rest <= n; rest++) {
            //                int ways = 0;
            //                for (int one = pre; one <= rest; one++) {
            //                    ways += dp[one][rest - one];
            //                }
            //                dp[pre][rest] = ways;
            //通过观察,dp[pre][rest]依赖这一行rest - pre这个值以及往左下斜着途中的几个值。
            //而,dp[pre+1][rest]依赖也如此，所以dp[pre][rest]= dp[pre+1][rest]再加上pre这一行的这个dp[pre][rest - pre]
            dp[pre][rest] = dp[pre+1][rest] +  dp[pre][rest - pre];
        }
    }
    return dp[1][n];
}
```

### 23、class23--从暴力递归到动态规划6

#### 1）数组分割成累加和尽量相等的两个集合(个数随意)

题目：给定一个正数数组arr，请把arr中所有的数分成两个集合。尽量让两个集合的累加和接近，返回最接近的情况下，较小集合的累加和

```java
//1、暴力递归
public static int right(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    return process(arr, 0, sum / 2);
}

// arr[i...]可以自由选择，请返回累加和尽量接近rest，但不能超过rest的情况下，最接近的累加和是多少？
public static int process(int[] arr, int i, int rest) {
    if (i == arr.length) {
        //之前所有情况都讨论完了，没数了，累加和返回0
        return 0;
    }
    //1、不选当前数
    int p1 = process(arr, i + 1, rest);
    //2、选当前数。要先确保当前数可选，能选返回累加和，不能选返回0
    int p2 = 0;
    if (arr[i] <= rest) {
        p2 += arr[i] + process(arr, i + 1, rest - arr[i]);
    }
    //3、返回以上两种可能中最接近rest的，即较大的
    return Math.max(p1, p2);
}

//2、动态规划
public static int dp(int[] arr) {
    if (arr == null || arr.length <= 1) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    //返回的累加和要 <= sum /2，先将sum除以2，然后建表
    sum /= 2;

    int N = arr.length;
    //dp[i][j]代表当前讨论第i个数，返回<= j累加和
    int[][] dp = new int[N + 1][sum + 1];
    //dp[N][...] = 0
    for (int i = N - 1; i >= 0; i--) {
        for (int rest = 0; rest <= sum; rest++) {
            //1、不选当前数
            int p1 = dp[i + 1][rest];
            //2、选当前数。要先确保当前数可选，能选返回累加和，不能选返回0
            int p2 = 0;
            if (arr[i] <= rest) {
                p2 += arr[i] + dp[i + 1][rest - arr[i]];
            }
            //3、选择以上两种可能中最接近rest的，即较大的
            dp[i][rest] = Math.max(p1, p2);
        }
    }
    return dp[0][sum];
}
```

#### 2）数组分割成累加和尽量相等的两个集合(个数平均)

题目：给定一个正数数组arr，请把arr中所有的数分成两个集合。如果arr长度为偶数，两个集合包含数的个数要一样多。如果arr长度为奇数，两个集合包含数的个数必须只差一个。请尽量让两个集合的累加和接近，返回最接近的情况下，较小集合的累加和

```java
//1、暴力递归
public static int right(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    //如果是偶数，返回的累加和必须有 arr.length / 2 个元素
    if ((arr.length & 1) == 0) {
        return process(arr, 0, arr.length / 2, sum / 2);
    } else {
        //如果是奇数，返回的累加和有 arr.length / 2 个或者 arr.length / 2 + 1个元素，返回离 sum/2最接近的
        int p1 = process(arr, 0, arr.length / 2, sum / 2);
        int p2 = process(arr, 0, arr.length / 2 + 1, sum / 2);
        return Math.max(p1, p2);
    }
}
// arr[i....]自由选择，挑选的个数一定要是picks个，累加和<=rest, 离rest最近的返回
public static int process(int[] arr, int i, int picks, int rest) {
    if (i == arr.length) {
        //若pick==0，代表之前的选择可以，此时返回累加和0。若pick != 0，代表之前的选择不可以，即这条策略不满足要求，返回-1
        return picks == 0 ? 0 : -1;
    }
    //1、不选当前数
    int p1 = process(arr, i + 1, picks, rest);
    //2、选当前数
    int p2 = -1;
    if (arr[i] <= rest) {
        //2.1、判断当前数是否能选
        int next = process(arr, i + 1, picks - 1, rest - arr[i]);
        if (next != -1) {
            //2.2、判断选完当前数以后，后面的那些数还能否满足要求
            p2 = arr[i] + next;
        }
    }
    return Math.max(p1, p2);
}

//2、动态规划
public static int dp(int[] arr) {
    if (arr == null || arr.length < 2) {
        return 0;
    }
    int sum = 0;
    for (int num : arr) {
        sum += num;
    }
    //返回的累加和要 <= sum /2，先将sum除以2，然后建表
    sum /= 2;
    int N = arr.length;
    //两个集合中的元素个数最大值是 N / 2 向上取整。例N=9,最终的两个集合一个有4个元素，一个有5个，返回最接近sum/2的那个。
    int M = (N + 1) / 2;
    //dp[i][j][k]代表当前讨论第i个数，此时还能选j个元素，返回 <= k的累加和
    int[][][] dp = new int[N + 1][M + 1][sum + 1];
    for (int i = 0; i <= N; i++) {
        for (int j = 0; j <= M; j++) {
            for (int k = 0; k <= sum; k++) {
                //先都设置成无效值-1
                dp[i][j][k] = -1;
            }
        }
    }
    //index = N此时越界，pick==0，代表之前的选择可以，此时返回累加和0。
    for (int rest = 0; rest <= sum; rest++) {
        dp[N][0][rest] = 0;
    }
    for (int index = N - 1; index >= 0; index--) {
        for (int picks = 0; picks <= M; picks++) {
            for (int rest = 0; rest <= sum; rest++) {
                //1、不选当前值
                int p1 = dp[index + 1][picks][rest];
                //2、选当前值
                int p2 = -1;
                //2.1、判断当前数是否能选
                if (picks - 1 >= 0 && arr[index] <= rest) {
                    int next = dp[index + 1][picks - 1][rest - arr[index]];
                    if(next != -1){
                        //2.2、判断选完当前数以后，后面的那些数还能否满足要求
                        p2 = arr[index] + next;
                    }
                }
                dp[index][picks][rest] = Math.max(p1,p2);
            }
        }
    }
    //如果是偶数，返回的累加和必须有 arr.length / 2 个元素
    if ((arr.length & 1) == 0) {
        return dp[0][arr.length / 2][sum];      //这里sum已经除以2了
    } else {
        //如果是奇数，返回的累加和有 arr.length / 2 个或者 arr.length / 2 + 1个元素，返回离 sum/2最接近的
        int p1 = dp[0][arr.length / 2][sum];
        int p2 = dp[0][arr.length / 2 + 1][sum];
        return Math.max(p1, p2);
    }

}
```

#### 3）N皇后问题

题目：N皇后问题是指在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列， 也不在同一条斜线上。给定一个整数n，返回n皇后的摆法有多少种。n=1，返回1。n=2或3，2皇后和3皇后问题无论怎么摆都不行，返回0。n=8，返回92。

```java
//1、暴力递归
public static int num1(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    //用来记录之前每行的数据，record[i] = j 代表第i行的皇后放在了j列上
    int[] record = new int[n];
    return process1(0, record, n);
}
/**
     * @param i      当前来到第i行。每一行放一个皇后
     * @param record record记录着0~i-1行的数据
     * @param n      代表要放n个皇后，固定值
     * @return 返回i行往后合法的方法，不管i-1行之前的
     */
public static int process1(int i, int[] record, int n) {
    if (i == n) {
        //前面n-1行都放完皇后了并且全部合法，方法数+1
        return 1;
    }
    int ways = 0;
    for (int j = 0; j < n; j++) {
        //如果放在i行j列合法
        if (isValid(i, j, record)) {
            record[i] = j;
            ways += process1(i + 1, record, n);
        }
    }
    return ways;
}
//检验这一个皇后放在i行j列后是否满足要求
public static boolean isValid(int i, int j, int[] record) {
    //检验0~i-1行
    for (int row = 0; row < i; row++) {
        int col = record[row];
        if (col == j || Math.abs(j - col) == Math.abs(i - row)) {
            //0~i-1行中某一个皇后也在j列  或者 (i,j)在0~i-1行中某一个皇后的斜线位置上
            return false;
        }
    }
    //0~i-1行都满足条件，返回true
    return true;
}

//2、利用位运算
// 请不要超过32皇后问题
public static int num2(int n) {
    if (n < 1 || n > 32) {
        return 0;
    }
    // 如果你是13皇后问题，limit 最右13个1，其他都是0
    int limit = n == 32 ? -1 : (1 << n) - 1;
    return process2(limit, 0, 0, 0);
}

// 7皇后问题
// limit : 0....0 1 1 1 1 1 1 1
// 之前皇后的列影响：colLim
// 之前皇后的左下对角线影响：leftDiaLim
// 之前皇后的右下对角线影响：rightDiaLim
public static int process2(int limit, int colLim, int leftDiaLim, int rightDiaLim) {
    if (colLim == limit) {
        //前面几行都放完皇后了并且全部合法，方法数+1
        return 1;
    }
    // pos中所有是1的位置，是你可以去尝试皇后的位置
    int pos = limit & (~(colLim | leftDiaLim | rightDiaLim));
    int mostRightOne = 0;
    int res = 0;
    while (pos != 0) {
        //从pos最右侧的1开始尝试
        mostRightOne = pos & (~pos + 1);
        pos = pos - mostRightOne;
        //递归算出下一行的结果
        res += process2(limit, colLim | mostRightOne, (leftDiaLim | mostRightOne) << 1,
                        (rightDiaLim | mostRightOne) >>> 1);
    }
    return res;
}
```

### 24、class24--窗口内最大值或最小值的更新结构

双端队列含义：假设此时让窗口依次缩小的话(只能L++，L和R不能--)，哪些位置的数会依次成为窗口内的最大值

#### 1）生成窗口最大值数组

题目：假设一个固定大小为W的窗口，依次划过arr，返回每一次滑出状况的最大值。例如，arr = [4,3,5,4,3,3,6,7], W = 3。返回：[5,5,5,4,6,7]

```java
//利用窗口内最大值更新结构
public static int[] getMaxWindow(int[] arr, int w) {
    if (arr == null || w < 1 || arr.length < w) {
        return null;
    }
    //1、创建双端队列，存放的是arr的下标。双端队列要确保数组值从头到尾严格递减
    //双端队列含义：假设此时让窗口依次缩小的话，哪些位置的数会依次成为窗口内的最大值
    LinkedList<Integer> maxWindow = new LinkedList<>();
    //用于存放结果，有arr.length - w + 1个元素
    int[] res = new int[arr.length - w + 1];
    int index = 0;

    //滑动窗口从0位置开始移动
    for (int R = 0; R < arr.length; R++) {
        while (!maxWindow.isEmpty() && arr[maxWindow.peekLast()] <= arr[R]) {
            //2、若双端队列有元素，并且尾端数组值<=要放进来的元素，弹出尾端元素
            maxWindow.pollLast();
        }
        //3、该元素加入尾端
        maxWindow.addLast(R);
        //4、检验是否构成w大小的滑动窗口
        if (R - w + 1 >= 0) {
            //4.1、并丢弃双端队列中下标为R-w的元素，确保滑动窗口大小为w
            if (maxWindow.peekFirst() == R - w) {
                maxWindow.pollFirst();
            }
            //4.2、双端队列首端元素，就是此时这个窗口下的最大值
            res[index++] = arr[maxWindow.peekFirst()];
        }

    }
    return res;
}
```

#### 2）最大值减最小值小于等于num的子数组数量

题目：给定一个整型数组arr，和一个整数num。某个arr中的子数组sub，如果想达标，必须满足：sub中最大值 – sub中最小值 <= num，返回arr中达标子数组的数量

```java
public static int num(int[] arr, int sum) {
    if (arr == null || arr.length == 0 || sum < 0) {
        return 0;
    }
    int N = arr.length;
    LinkedList<Integer> maxWindow = new LinkedList<>();  //记录滑动窗口内的最大值
    LinkedList<Integer> minWindow = new LinkedList<>();  //记录滑动窗口内的最小值
    int counts = 0;  //记录结果
    //R用来记录 以L为开始下标的子数组 的滑动窗口的右边界，R不会回退。[L,R)：[i,i)代表滑动窗口内没有值
    int R = 0;
    //1、依次求出以L为开始下标的子数组数量。一直到N-1，所有情况全部讨论完毕
    for (int L = 0; L < N; L++) {
        while (R < N) {       //R一越界就停止
            //2、初始化最大值双端队列
            while (!maxWindow.isEmpty() && arr[maxWindow.peekLast()] <= arr[R]) {
                maxWindow.pollLast();
            }
            maxWindow.addLast(R);
            //3、初始化最小值双端队列
            while (!minWindow.isEmpty() && arr[minWindow.peekLast()] >= arr[R]) {
                minWindow.pollLast();
            }
            minWindow.addLast(R);
            //4、若数组[L,R)内max - min > sum，就停止，去讨论[L+1,R)。
            // 若满足max - min <= sum，R++，去讨论[L,R+1)
            if (arr[maxWindow.peekFirst()] - arr[minWindow.peekFirst()] > sum) {
                break;
            } else {
                R++;
            }
        }
        //5、此时 以L为开始下标的子数组 满足条件的子数组数量为R-L个。
        counts += R - L;
        //6、准备讨论以L+1为下标的子数组。不过先要把两个双端队列过期的元素，即下标为L的元素先淘汰掉，不能让L的元素影响L+1的判断
        if (maxWindow.peekFirst() == L) {
            maxWindow.pollFirst();
        }
        if (minWindow.peekFirst() == L) {
            minWindow.pollFirst();
        }
    }
    //7、所有子数组全部讨论完，返回符合条件的数量
    return counts;
}
```

#### 3）加油站的良好出发点问题

题目：在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则保证它是唯一的。

```java
public static int canCompleteCircuit1(int[] gas, int[] cost) {
    boolean[] good = goodArray(gas, cost);
    for (int i = 0; i < gas.length; i++) {
        if (good[i]) {
            return i;
        }
    }
    return -1;
}

public static boolean[] goodArray(int[] g, int[] c) {
    int N = g.length;
    int M = N << 1;
    int[] arr = new int[M];
    for (int i = 0; i < N; i++) {
        arr[i] = g[i] - c[i];
        arr[i + N] = g[i] - c[i];
    }
    for (int i = 1; i < M; i++) {
        arr[i] += arr[i - 1];
    }
    LinkedList<Integer> w = new LinkedList<>();
    for (int i = 0; i < N; i++) {
        while (!w.isEmpty() && arr[w.peekLast()] >= arr[i]) {
            w.pollLast();
        }
        w.addLast(i);
    }
    boolean[] ans = new boolean[N];
    for (int offset = 0, i = 0, j = N; j < M; offset = arr[i++], j++) {
        if (arr[w.peekFirst()] - offset >= 0) {
            ans[i] = true;
        }
        if (w.peekFirst() == i) {
            w.pollFirst();
        }
        while (!w.isEmpty() && arr[w.peekLast()] >= arr[j]) {
            w.pollLast();
        }
        w.addLast(j);
    }
    return ans;
}

public int canCompleteCircuit2(int[] gas, int[] cost) {
    int n = gas.length;
    //从第i号加油站开始讨论
    int i = 0;
    while(i < n){
        int gasSum = 0;     //总共加的油
        int costSum = 0;    //总共消费的油
        int count = 0;      //记录能走过几个站点
        int j = i;			//j代表从i号站点出发沿途的那些站点
        //要确保能绕一圈
        while(count < n){
            gasSum += gas[j];
            costSum += cost[j];
            if(gasSum  - costSum < 0){
                //这个站点发现油不够了
                break;
            }else {
                //这个站点发现油够，准备检验下一个站点
                count++;  
                j = (j + 1) % n;
            }      
        }
        // 如果能环绕一圈
        if(count == n){
            return i;
        }else {
            //从油不够的那个站点开始检查(重要优化)
            i = i + count + 1;
        }
    }
    //所有站点都讨论完了，没有复合要求的
    return -1;
}
```

#### 4）子数组长度不超过M的最大累加和

题目：给定一个数组arr，和一个正数M，返回在arr的子数组在长度不超过M的情况下，最大的累加和

```java
public static int maxSum(int[] arr, int M) {
    int N = arr.length;
    if (arr == null || arr.length == 0 || M < 1) {
        return 0;
    }
    //1、创建前缀和数组
    int[] sum = new int[N];
    sum[0] = arr[0];
    for (int i = 1; i < N; i++) {
        sum[i] = sum[i - 1] + arr[i];
    }
    int len = Math.min(N, M); //子数组最大长度
    //2、创建双端队列，用来做滑动窗口。滑动窗口求每一部分的最大值，O(N)
    LinkedList<Integer> qMax = new LinkedList<>();
    //3、滑动窗口先放0~len-1上的前缀和
    int i = 0;
    for (; i < len; i++) {
        while (!qMax.isEmpty() && sum[qMax.peekLast()] <= sum[i]) {
            //确保双端队列左边一直是最大值
            qMax.pollLast();
        }
        qMax.addLast(i);
    }
    int max = sum[qMax.peekFirst()];
    //4、i=len，此时i指向窗口右边第一个数，开始移动滑动窗口，并求出每部分的最大值
    int L = 0;  //移动窗口后左边的值，一会前缀和要减去这部分
    for (; i < N; i++, L++) {
        if (qMax.peekFirst() == L) {
            qMax.pollFirst();   //弹出不在滑动窗口内的值
        }
        while (!qMax.isEmpty() && sum[qMax.peekLast()] <= sum[i]) {
            //确保双端队列左边一直是最大值
            qMax.pollLast();
        }
        qMax.addLast(i);
        max = Math.max(max, sum[qMax.peekFirst()] - sum[L]);  //这里要注意减去L前面的前缀和，答案才是正确的
    }
    //5、L=N-len，此时L指向窗口左边第一个数,窗口内的数不够len个了
    for (; L < N - 1; L++) {
        if (qMax.peekFirst() == L) {
            qMax.pollFirst();   //弹出不在滑动窗口内的值
        }
        max = Math.max(max, sum[qMax.peekFirst()] - sum[L]);
    }
    return max;
}
```

#### 5）动态规划中利用窗口内最大值或最小值更新结构做优化，难

题目：arr是货币数组，其中的值都是正数。再给定一个正数aim。每个值都认为是一张货币，返回组成aim的最少货币数。注意：因为是求最少货币数，所以每一张货币认为是相同或者不同就不重要了
```java
// 优化需要用到窗口内最小值的更新结构
public static int dp3(int[] arr, int aim) {
    if (aim == 0) {
        return 0;
    }
    // 得到info时间复杂度O(arr长度)
    Info info = getInfo(arr);
    int[] c = info.coins;
    int[] z = info.zhangs;
    int N = c.length;
    //dp[i][j]代表从第i个货币往后讨论，目标钱为j的最少货币数
    int[][] dp = new int[N + 1][aim + 1];
    dp[N][0] = 0;
    for (int j = 1; j <= aim; j++) {
        dp[N][j] = Integer.MAX_VALUE;
    }
    // 虽然是嵌套了很多循环，但是时间复杂度为O(货币种数 * aim)
    // 因为用了窗口内最小值的更新结构
    for (int i = N - 1; i >= 0; i--) {
        //mod代表组号。例如aim=30，c[i]=3，则aim=0 3 6 9..为第0组，1 4 7..为第1组，
        for (int mod = 0; mod < Math.min(aim + 1, c[i]); mod++) {
            // 当前面值 X
            // mod mod + x mod + 2*x mod + 3 * x，这些位置形成窗口
            LinkedList<Integer> w = new LinkedList<>();
            w.add(mod);
            dp[i][mod] = dp[i + 1][mod];
            for (int r = mod + c[i]; r <= aim; r += c[i]) {
                while (!w.isEmpty() && (dp[i + 1][w.peekLast()] == Integer.MAX_VALUE
                                        || dp[i + 1][w.peekLast()] + compensate(w.peekLast(), r, c[i]) >= dp[i + 1][r])) {
                    w.pollLast();
                }
                w.addLast(r);
                int overdue = r - c[i] * (z[i] + 1);
                if (w.peekFirst() == overdue) {
                    w.pollFirst();
                }
                if (dp[i + 1][w.peekFirst()] == Integer.MAX_VALUE) {
                    dp[i][r] = Integer.MAX_VALUE;
                } else {
                    dp[i][r] = dp[i + 1][w.peekFirst()] + compensate(w.peekFirst(), r, c[i]);
                }
            }
        }
    }
    return dp[0][aim];
}
```

### 25、class25--单调栈

#### 1）单调栈结构

单调栈结构为了解决如下的问题：给定一个可能含有重复值的数组arr，i位置的一定存在如下两个信息

1）arr[i]的左侧离i最近并且小于（或者大于）arr[i]的数在哪

2）arr[i]的右侧离i最近并且小于（或者大于）arr[i]的数在哪

如果想得到arr中所有位置的两个信息，用单调栈能让得到信息的过程尽量快

```java
//1、单调栈，原数组元素不重复
public static int[][] getNearLessNoRepeat(int[] arr) {
    // res二维数组存的是原数组下标，没有存-1。
    // res[i][0]代表原数组第i个位置的这个数左边比它小的最近的数的下标。res[i][1]代表原数组第i个位置的这个数右边比它小的最近的数的下标
    int[][] res = new int[arr.length][2];
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < arr.length; i++) { // 当遍历到i位置的数，arr[i]
        //1、当前数arr[i]无法加入到栈中
        while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {
            //2、弹出记录栈顶元素的相关信息
            int j = stack.pop();
            //3、若栈为空，j元素左边没有比它小的最近的数，返回-1。栈不为空，弹出j后的栈顶元素就是j元素左边比它小的最近的数
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
            res[j][0] = leftLessIndex;
            //4、arr[i]就是j元素右边比它小的最近的数
            res[j][1] = i;
        }
        stack.push(i);
    }
    //5、arr数组已经全部放入到栈中过了，此时栈中还有元素，依次弹出并记录相关信息
    while (!stack.isEmpty()) {
        int j = stack.pop();
        int leftLessIndex = stack.isEmpty() ? -1 : stack.peek();
        res[j][0] = leftLessIndex;
        //已经没有arr[i]了都讨论完了，所以j元素右边没有比它小的最近的数
        res[j][1] = -1;
    }
    return res;
}

//2、单调栈，原数组元素有重复的
public static int[][] getNearLess(int[] arr) {
    // res二维数组存的是原数组下标，没有存-1。
    // res[i][0]代表原数组第i个位置的这个数左边比它小的最近的数的下标。res[i][1]代表原数组第i个位置的这个数右边比它小的最近的数的下标
    int[][] res = new int[arr.length][2];
    //单调栈结构，存的是一组原数组值相等的那些下标
    Stack<List<Integer>> stack = new Stack<>();
    //1、开始从数组第一个元素开始讨论
    for (int i = 0; i < arr.length; i++) {
        //2、栈顶元素对应的值严格 > arr[i]，弹出栈顶元素并记录所有下标的信息
        while (!stack.isEmpty() && arr[stack.peek().get(0)] > arr[i]) {
            List<Integer> popIs = stack.pop();
            //3、若栈为空，这组下标所有的数左边没有比它小的最近的数，返回-1。
            //栈不为空，弹出后的栈顶元素中一组下标最右边的下标所对应的值就是这组下标所有的数左边比它小的最近的数
            int leftLessIndex = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
            for (Integer popI : popIs) {
                res[popI][0] = leftLessIndex;
                //4、arr[i]就是popIs所有数的右边比它小的最近的数
                res[popI][1] = i;
            }
        }
        //5、检验栈顶元素的所对应的值是否与arr[i]相等
        //5.1、若相等，加入到集合中
        if (!stack.isEmpty() && arr[stack.peek().get(0)] == arr[i]) {
            stack.peek().add(i);
        } else {
            //5.2、若不相等，创建新的集合并加入栈中
            ArrayList<Integer> list = new ArrayList<>();
            list.add(i);
            stack.push(list);
        }
    }
    //6、arr数组已经全部放入到栈中过了，此时栈中还有元素，依次弹出并记录相关信息
    while (!stack.isEmpty()) {
        List<Integer> popIs = stack.pop();
        for (Integer popI : popIs) {
            res[popI][0] = stack.isEmpty() ? -1 : stack.peek().get(stack.peek().size() - 1);
            //已经没有arr[i]了都讨论完了，popIs所有数的右边都没有比它小的最近的数
            res[popI][1] = -1;
        }
    }
    return res;
}
```

#### 2）子数组最小乘积的最大值

题目：给定一个只包含正数的数组arr，arr中任何一个子数组sub，一定都可以算出(sub累加和 )* (sub中的最小值)是什么，那么所有子数组中，这个值最大是多少？

```java
public int maxSumMinProduct(int[] arr) {
    int size = arr.length;
    //1、先求前缀和数组，用来以后 求从i到j位置的累加和
    long[] sums = new long[size];
    sums[0] = arr[0];
    for(int i = 1; i < size; i++){
        sums[i] = sums[i-1] + arr[i];
    }
    long max = Long.MIN_VALUE;
    //2、建立单调栈
    int[] stack = new int[size];
    int stackSize = 0;
    for(int i = 0; i < size; i++){
        //3、栈顶元素值>=arr[i]时弹出元素，并记录弹出元素作为sub中的最小值，此时(sub累加和 )* (sub中的最小值)。
        //注意：若栈顶元素值=arr[i]也弹出元素，此时弹出元素的右侧最近最小是错误的，不过不耽误，
        //假设arr[i]就是与栈顶元素值相同的最后一个元素，则arr[i]与栈顶元素左侧最近最小和右侧最近最小是一样的，最终不耽误取最大值
        while(stackSize != 0 && arr[stack[stackSize-1]] >= arr[i]){
            //记录原数组j下标位置的值 作为sub中的最小值，来求此时(sub累加和 )* (sub中的最小值)。
            int j = stack[--stackSize];
            long res = stackSize == 0 ? sums[i-1] * arr[j] : (sums[i-1] - sums[stack[stackSize-1]]) * arr[j]; 
            max = Math.max(max,res);

        }
        //这个数组下标入栈
        stack[stackSize++] = i;
    }
    //4、arr数组已经全部放入到栈中过了，此时栈中还有元素，依次弹出并记录相关信息
    while(stackSize != 0){
        int j = stack[--stackSize];
        //已经没有arr[i]了都讨论完了，所以j元素右边没有比它小的最近的数
        long res = stackSize == 0 ? sums[size-1] * arr[j] : (sums[size-1] - sums[stack[stackSize-1]]) * arr[j]; 
        max = Math.max(max,res);

    }
    return max;
}
```

#### 3）柱状图中最大的矩形

题目：给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积

```java
public int largestRectangleArea(int[] heights) {
    if(heights == null || heights.length == 0){
        return 0;
    }
    int N = heights.length;
    int[] stack = new int[N];
    int stackSize = 0;
    int maxArea = 0;
    for(int i = 0; i < N; i++){
        while(stackSize != 0 && heights[stack[stackSize - 1]] >= heights[i]){
            //分别讨论高度以height[j]的柱状图的最大面积是多少
            int j = stack[--stackSize];
            int chang = stackSize == 0 ? i : i - 1 - stack[stackSize-1];
            maxArea = Math.max(maxArea,chang * heights[j]);

        }
        stack[stackSize++] = i;
    }
    while(stackSize != 0){
        int j = stack[--stackSize];
        int chang = stackSize == 0 ? N : N - 1 - stack[stackSize-1];
        maxArea = Math.max(maxArea,chang * heights[j]);
    }
    return maxArea;
}
```

#### 4）最大矩形

题目：给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积

```java
//可以将这道题看成柱形图问题，以每一行作为直方图底部，求直方图的最大面积
public int maximalRectangle(char[][] matrix) {
    if(matrix == null || matrix[0].length == 0 || matrix.length == 0){
        return 0;
    }
    int maxArea = 0;
    int[] height = new int[matrix[0].length];
    //初始化以每一行为直方图底部的直方图数组
    for(int i = 0; i < matrix.length; i++){
        for(int j = 0; j < matrix[0].length; j++){
            //height[j]代表以第i行作为直方图底部时，j上的直方图有多高，即j上有几个1
            height[j] = matrix[i][j] == '0' ? 0 : height[j] + 1;
        }
        maxArea = Math.max(maxRecFromBottom(height), maxArea);
    }
    return maxArea;

}
// height是直方图数组
public static int maxRecFromBottom(int[] height) {
    if (height == null || height.length == 0) {
        return 0;
    }
    int N = height.length;
    int maxArea = 0;
    int[] stack = new int[N];
    int stackSize = 0;
    for(int i = 0; i < N; i++){
        while(stackSize != 0 && height[stack[stackSize-1]] >= height[i]){
            int j = stack[--stackSize];
            int chang = stackSize == 0 ? i : i - 1 - stack[stackSize-1];
            maxArea = Math.max(maxArea,chang * height[j]);
        }
        stack[stackSize++] = i;
    }
    while(stackSize != 0){
        int j = stack[--stackSize];
        int chang = stackSize == 0 ? N : N - 1 - stack[stackSize-1];
        maxArea = Math.max(maxArea,chang * height[j]);
    }
    return maxArea;
}
```

#### 5）统计全 1 子矩形

题目：给你一个 m x n 的二进制矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。

```java
public static int numSubmat(int[][] mat) {
    if (mat == null || mat.length == 0 || mat[0].length == 0) {
        return 0;
    }
    int N = mat[0].length;
    int[] height = new int[N];
    int nums = 0;
    for(int i = 0; i < mat.length; i++){
        for(int j = 0; j < N; j++){
            height[j] = mat[i][j] == 0 ? 0 : height[j] + 1;
        }
        nums += countFromBottom(height);
    }
    return nums;
}

public static int countFromBottom(int[] height) {
    int N = height.length;
    int[] stack = new int[N];
    int stackSize = 0;
    int nums = 0;
    for(int i = 0; i < N; i++){
        while(stackSize != 0 && height[stack[stackSize-1]] >= height[i]){
            int j = stack[--stackSize];
            //长
            int n = stackSize == 0 ? i : i - 1 - stack[stackSize-1];
            //取左右边界高度较高的
            int down = Math.max(stackSize == 0 ? 0 : height[stack[stackSize-1]],height[i]);
            //高度为down~height[cur]的这些矩形，在弹出cur时计算，比down小的后面一定会单独算到
            //一行若有连续n个1，则这一行连续n个1的全1子矩阵有(n*(n+1)/2)个。共有height[cur] - down行
            nums += (height[j] - down) * (n*(n+1)/2);
        }
        stack[stackSize++] = i;
    }
    while(stackSize != 0){
        int j = stack[--stackSize];
        int n = stackSize == 0 ? N : N - 1 - stack[stackSize-1];
        int down = stackSize == 0 ? 0 : height[stack[stackSize-1]];
        nums += (height[j] - down)  * (n*(n+1)/2);
    }
    return nums;
}
```

#### 6）子数组的最小值之和

题目：给定一个数组arr，返回所有子数组最小值的累加和

```java
public static int sumSubarrayMins(int[] arr) {
    int N = arr.length;
    //left[i]代表原数组左边 < arr[i]的最近数的下标，用单调栈实现
    int[] left = new int[N];
    //right[i]代表原数组右边 <= arr[i]的最近数的下标，用单调栈实现
    int[] right = new int[N];
    int[] stack = new int[N];
    int stackSize = 0;
    for(int i = 0; i < N; i++){
        while(stackSize != 0 && arr[stack[stackSize-1]] >= arr[i]){
            int j = stack[--stackSize];
            left[j] = stackSize == 0 ? -1 : stack[stackSize - 1];
            right[j] = i;
        }
        stack[stackSize++] = i;
    }
    while(stackSize != 0){
        int j = stack[--stackSize];
        left[j] = stackSize == 0 ? -1 : stack[stackSize - 1];
        right[j] = N;
    }

    long ans = 0;
    for(int i = 0; i < N; i++){
        //start = arr[i]连续左边>arr[i]数的个数 + 1(arr[i]本身)
        int start = i - left[i];
        //end = arr[i]连续右边>arr[i]数额个数 + 1(arr[i]本身)
        int end = right[i] - i;
        ans += start * end * (long)arr[i];
        ans %= 1000000007;
    }
    return (int) ans;
}
```

### 26、class26--求斐波那契数列矩阵乘法的方法

#### 1）母牛生小牛问题

题目：第一年农场有1只成熟的母牛A，往后的每年：每一只成熟的母牛都会生一只母牛；每一只新出生的母牛都在出生的第三年成熟；每一只母牛永远不会死。返回N年后牛的数量

```java
//f(n) = f(n-1) + f(n-3)
public static int c3(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2 || n == 3) {
        return n;
    }
    int[][] base = {
        { 1, 1, 0 },
        { 0, 0, 1 },
        { 1, 0, 0 } };
    int[][] res = matrixPower(base, n - 3);
    return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
}
public static int[][] matrixPower(int[][] m, int p) {
    int[][] res = new int[m.length][m[0].length];
    for (int i = 0; i < res.length; i++) {
        res[i][i] = 1;
    }
    // res = 矩阵中的1
    int[][] t = m;// 矩阵1次方
    for (; p != 0; p >>= 1) {
        if ((p & 1) != 0) {
            //此时p的二进制形式最后一位是1，res * t，否则res不变，t矩阵在每一次判断后都会变成t * t
            res = product(res, t);
        }
        t = product(t, t);
    }
    return res;
}
// 两个矩阵乘完之后的结果返回
public static int[][] product(int[][] a, int[][] b) {
    int n = a.length;
    int m = b[0].length;
    int k = a[0].length; // a的列数同时也是b的行数
    int[][] ans = new int[n][m];
    for(int i = 0 ; i < n; i++) {
        for(int j = 0 ; j < m;j++) {
            for(int c = 0; c < k; c++) {
                ans[i][j] += a[i][c] * b[c][j];
            }
        }
    }
    return ans;
}
```

#### 2）有效的字符串数量

题目：给定一个数N，想象只由0和1两种字符，组成的所有长度为N的字符串，如果某个字符串，任何0字符的左边都有1紧挨着，认为这个字符串达标。返回有多少达标的字符串

```java
//1、暴力递归   
public static int getNum1(int n) {
    if (n < 1) {
        return 0;
    }
    return process(1, n);
}
//所有达标的字符串第一个位置一定是1，说明N个字符串有N-1个位置需要考虑
// 这个函数代表总共有n个数，从i位置考虑有多少个达标的
// 1 1 _ _ _ _ _
// 1 0 1 _ _ _ _  只有这两种可能
public static int process(int i, int n) {
    //        if (i == n - 1) {
    //            return 2;
    //        }
    //        if (i == n) {
    //            //越界了，返回1种可能
    //            return 1;
    //        }
    if (i >= n) {
        //越界了，返回1种可能
        return 1;
    }
    return process(i + 1, n) + process(i + 2, n);
}
//2、由于能推出f(n) = f(n-1) + f(n-2)，改成斐波那契数列O(logN)的解法
public static int getNum3(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    int[][] base = {{1, 1}, {1, 0}};
    int[][] res = matrixPower(base, n - 2);
    return 2 * res[0][0] + res[1][0];
}
public static int[][] matrixPower(int[][] m, int p) {
    int[][] res = new int[m.length][m[0].length];
    for (int i = 0; i < res.length; i++) {
        res[i][i] = 1;
    }
    int[][] tmp = m;
    for (; p != 0; p >>= 1) {
        if ((p & 1) != 0) {
            res = product(res, tmp);
        }
        tmp = product(tmp, tmp);
    }
    return res;
}
// 两个矩阵乘完之后的结果返回
public static int[][] product(int[][] a, int[][] b) {
    int n = a.length;
    int m = b[0].length;
    int k = a[0].length; // a的列数同时也是b的行数
    int[][] ans = new int[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            for (int c = 0; c < k; c++) {
                ans[i][j] += a[i][c] * b[c][j];
            }
        }
    }
    return ans;
}
```

#### 3）铺瓷砖的方法数

题目：用1 * 2的瓷砖，把N * 2的区域填满，返回铺瓷砖的方法数

```java
//1、暴力递归
public static int getNum1(int n) {
    if (n < 1) {
        return 0;
    }
    return process(0, n);
}
//这个函数代表下标为[i,n)这些区域的方法数
public static int process(int i, int n) {
    if (i == n - 1) {
        //当讨论在最后一个位置时，砖只能竖着放
        return 1;
    }
    if (i == n) {
        //越界了，返回正在讨论的这一种方法
        return 1;
    }
    //i位置上的砖的放法只有两种可能:
    //1、把1*2的砖竖过来放在i位置，再去讨论i+1位置
    //2、把1*2的砖横过来，两块砖放在占据i和i+1位置，再去讨论i+2位置
    return process(i + 1, n) + process(i + 2, n);
}

//2、由于能推出f(n) = f(n-1) + f(n-2)，改成斐波那契数列O(logN)的解法
public static int getNum2(int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1 || n == 2) {
        return n;
    }
    int[][] base = {{1, 1}, {1, 0}};
    int[][] res = matrixPower(base, n - 2);
    return 2 * res[0][0] + res[1][0];
}
public static int[][] matrixPower(int[][] m, int p) {
    int[][] res = new int[m.length][m[0].length];
    for (int i = 0; i < res.length; i++) {
        res[i][i] = 1;
    }
    int[][] tmp = m;
    for (; p != 0; p >>= 1) {
        if ((p & 1) != 0) {
            res = product(res, tmp);
        }
        tmp = product(tmp, tmp);
    }
    return res;
}
// 两个矩阵乘完之后的结果返回
public static int[][] product(int[][] a, int[][] b) {
    int n = a.length;
    int m = b[0].length;
    int k = a[0].length; // a的列数同时也是b的行数
    int[][] ans = new int[n][m];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            for (int c = 0; c < k; c++) {
                ans[i][j] += a[i][c] * b[c][j];
            }
        }
    }
    return ans;
}
```

### 27、class27--KMP算法

KMP算法用来判断一个字符串是否是另一个字符串的子串，O(n)

#### 1）KMP算法实现

题目：给定两个字符串s1，s2，如果字符串s1中含有子串s2，则返回s2在s1中的开始位置，不含有返回-1

```java
public static int getIndexOf(String s1, String s2) {
    if (s1 == null || s2 == null || s2.length() < 1 || s1.length() < s2.length()) {
        return -1;
    }
    char[] str1 = s1.toCharArray();
    char[] str2 = s2.toCharArray();
    //xy都可代表字符串数组下标
    int x = 0;
    int y = 0;
    // O(M) m <= n
    int[] next = getNextArray(str2);
    // O(N)·    若跳出循环是因为y越界说明已经从str1中找到str2的片段，若是因为x越界说明没找到
    while (x < str1.length && y < str2.length) {
        if (str1[x] == str2[y]) {
            x++;
            y++;
        } else if (next[y] == -1) { //此时y=0
            // abcabcd x=7 ->  abcabcd     x=7 ->  abcabcd         x=7 -> abcabcd_          x=8
            // abcabct y=7 ->     abcabct  y=3 ->        abcabct   y=0 ->        abcabct    y=0
            x++;
        } else {
            //x不变，y来到str[next[y]]位置，此时str1 x位置的字符与str2 y位置的字符比较
            // abcabcd x=7 ->  abcabcd       x=7        xy都可代表字符串数组下标
            // abcabct y=7 ->     abcabct    y=3
            y = next[y];
        }
    }
    //如果y越界，返回str1中包含s tr2片段的字符串开始下标，否则没找到返回-1
    return y == str2.length ? x - y : -1;
}

public static int[] getNextArray(char[] str2) {
    if (str2.length == 1) {
        return new int[] { -1 };
    }
    int[] next = new int[str2.length];
    next[0] = -1;
    next[1] = 0;
    int i = 2; // 目前在哪个位置上求next数组的值
    int cn = 0; // 当前是哪个位置的值再和i-1位置的字符比较
    while (i < next.length) {
        if (str2[i - 1] == str2[cn]) { // 配成功的时候
            //           cn             i-1  i    next[i-1] = 9  next[i]= 10
            // acdbstacd b f e acdbstacd b   k
            next[i++] = ++cn;
        } else if (cn == 0) {
            //  next[cn]=0                                                                 next[i]=0，准备讨论i+1
            //     cn                       i-1  i        cn                             i-1  i
            // acd b s t acd t f e acdbstacd t   k    ->  a c d b s t acd t f e acdbstacd t   k
            next[i++] = 0;
        } else {
            //       next[cn]=3     next[i-1] = 9
            //           cn             i-1  i   ->         cn                       i-1  i
            // acdbstacd t f e acdbstacd b   k   ->     acd b s t acd t f e acdbstacd b   k
            cn = next[cn];
        }
    }
    return next;
}
```

#### 2）另一棵树的子树

题目：给定两棵二叉树的头节点head1和head2，返回head1中是否有某个子树的结构和head2完全一样

```java
public static class TreeNode {
    public int val;
    public TreeNode left;
    public TreeNode right;

    public TreeNode(int v) {
        val = v;
    }
}
public static boolean isSubtree(TreeNode big, TreeNode small) {
    if (small == null) {
        return true;
    }
    if (big == null) {
        return false;
    }
    ArrayList<String> b = preSerial(big);
    ArrayList<String> s = preSerial(small);
    String[] str = new String[b.size()];
    for (int i = 0; i < str.length; i++) {
        str[i] = b.get(i);
    }

    String[] match = new String[s.size()];
    for (int i = 0; i < match.length; i++) {
        match[i] = s.get(i);
    }
    return getIndexOf(str, match) != -1;
}
//先序遍历
public static ArrayList<String> preSerial(TreeNode head) {
    ArrayList<String> ans = new ArrayList<>();
    pres(head, ans);
    return ans;
}
public static void pres(TreeNode head, ArrayList<String> ans) {
    if (head == null) {
        ans.add(null);
    } else {
        ans.add(String.valueOf(head.val));
        pres(head.left, ans);
        pres(head.right, ans);
    }
}

public static int getIndexOf(String[] str1, String[] str2) {
    if (str1 == null || str2 == null || str1.length < 1 || str1.length < str2.length) {
        return -1;
    }
    int x = 0;
    int y = 0;
    int[] next = getNextArray(str2);
    while (x < str1.length && y < str2.length) {
        if (isEqual(str1[x], str2[y])) {
            x++;
            y++;
        } else if (next[y] == -1) {
            x++;
        } else {
            y = next[y];
        }
    }
    return y == str2.length ? x - y : -1;
}
public static int[] getNextArray(String[] ms) {
    if (ms.length == 1) {
        return new int[] { -1 };
    }
    int[] next = new int[ms.length];
    next[0] = -1;
    next[1] = 0;
    int i = 2;
    int cn = 0;
    while (i < next.length) {
        if (isEqual(ms[i - 1], ms[cn])) {
            next[i++] = ++cn;
        } else if (cn > 0) {
            cn = next[cn];
        } else {
            next[i++] = 0;
        }
    }
    return next;
}
public static boolean isEqual(String a, String b) {
    if (a == null && b == null) {
        return true;
    } else {
        if (a == null || b == null) {
            return false;
        } else {
            return a.equals(b);
        }
    }
}
```

#### 3）判断旋转字符串

题目：判断str1和str2是否互为旋转字符串

```java
public static boolean isRotation(String a, String b) {
    if (a == null || b == null || a.length() != b.length()) {
        return false;
    }
    String b2 = b + b;
    return getIndexOf(b2, a) != -1;
}

// KMP Algorithm
public static int getIndexOf(String s, String m) {
    if (s.length() < m.length()) {
        return -1;
    }
    char[] ss = s.toCharArray();
    char[] ms = m.toCharArray();
    int si = 0;
    int mi = 0;
    int[] next = getNextArray(ms);
    while (si < ss.length && mi < ms.length) {
        if (ss[si] == ms[mi]) {
            si++;
            mi++;
        } else if (next[mi] == -1) {
            si++;
        } else {
            mi = next[mi];
        }
    }
    return mi == ms.length ? si - mi : -1;
}

public static int[] getNextArray(char[] ms) {
    if (ms.length == 1) {
        return new int[] { -1 };
    }
    int[] next = new int[ms.length];
    next[0] = -1;
    next[1] = 0;
    int pos = 2;
    int cn = 0;
    while (pos < next.length) {
        if (ms[pos - 1] == ms[cn]) {
            next[pos++] = ++cn;
        } else if (cn > 0) {
            cn = next[cn];
        } else {
            next[pos++] = 0;
        }
    }
    return next;
}
```

### 28、class28--Manacher算法

Manacher算法用来求一个字符串中的最长回文子串	

#### 1）Manacher算法实现

题目：给定一个字符串str，返回str中最长回文子串的长度

```java
public static int manacher(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    // 将原字符串变成处理字符串。如"12132" -> "#1#2#1#3#2#"  
    char[] str = manacherString(s);
    //  处理字符串的回文半径的大小
    int[] pArr = new int[str.length];
    // coding：最右的扩成功位置的，再下一个位置。讲述中：R代表最右的扩成功的位置
    int R = -1;
    // C是对于回文直径L~R的中点位置
    int C = -1;
    int max = Integer.MIN_VALUE;
    //1、求处理字符串每一个位置的pArr[i]回文半径的大小
    for (int i = 0; i < str.length; i++) { // 0 1 2
        //1、若i在R外，先pArr[i]=1，因为它至少是1
        //2、若i在R内，综合以下三种可能，i的回文半径 = Math.min(pArr[2 * C - i], R - i)
        //   1）、i‘的回文直径在L~R内，即i'的L'在L右边，i的回文半径=i'的回文半径，pArr[i]=pArr[2*C-i]。i'的回文半径要小
        //   a b c d e d e b a t s t a b e d e d c f      注意：这里面其实有#，为了方便看，就省略了
        //     L L'  i'  R'      C           i     R    pArr[i] = pArr[i']=pArr[2*C-i]=2，
        //   2）、i'的回文直径一部分在L~R外，即i'的L'在L左边，i的回文半径=R-i，pArr[i]=R-i。i'的回文半径要大
        //   a b c d e d c b a t s t a b c d e d c f      注意：这里面其实有#，为了方便看，就省略了
        // L'  L     i'  R'      C(R')       i     R    pArr[i] = R-i=3，
        //   3）、i'的回文直径压在L~R上，即即i'的L'在L位置上，i的回文半径 至少 = i'的回文半径(等于R-i)。具体i的回文半径还要往后比较
        //   a b c d e d c a c t s t c a c d e d c a      注意：这里面其实有#，为了方便看，就省略了
        //     L(L') i'  R'      C           i     R  pArr[i] 至少= pArr[i']=pArr[2*C-i]=R-i=3，这个例子最后就是4

        // R第一个违规的位置，i>= R
        // pArr[i]是i位置扩出来的答案，目前i位置扩的区域，至少是多大。
        //2.1、pArr[i]至少是多少
        pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1;   //重点要记住！！！
        while (i + pArr[i] < str.length && i - pArr[i] > -1) { //i往左和往右的最新的位置不越界
            if (str[i + pArr[i]] == str[i - pArr[i]])
                //只有上面的2、3）才会走到这里
                //2.2、结束循环后得到最终的pArr[i]
                pArr[i]++;
            else {
                //上面的2、1）和2）会直接结束循环
                break;
            }
        }
        //2.3、把R位置推得更往右了，更新R，更新C
        if (i + pArr[i] > R) {
            R = i + pArr[i];
            C = i;
        }
        //2.4、记录处理串的最大回文半径
        max = Math.max(max, pArr[i]);
    }
    //3、最终求的是处理串的最大回文半径，max-1后就是原字符串的最大回文长度（最大回文直径）
    return max - 1;
}
// 将原字符串变成处理字符串。如"12132" -> "#1#2#1#3#2#"  
public static char[] manacherString(String str) {
    char[] charArr = str.toCharArray();
    char[] res = new char[str.length() * 2 + 1];  //返回处理字符串
    int index = 0;
    for (int i = 0; i != res.length; i++) {
        res[i] = (i & 1) == 0 ? '#' : charArr[index++];
    }
    return res;
}
```

#### 2）后面添字符整体变回文串

题目：给定一个字符串str，只能在str的后面添加字符，想让str整体变成回文串，返回至少要添加几个字符

思想：找到必须包含最后一个字符的最长回文子串，然后将子串前面剩下的部分翻转放到后面。例：abcd123321 ->  找到123321，再将abcd翻转放到后面 -> 结果：abcd123321dcba

```java
public static String shortestEnd(String s) {
    if (s == null || s.length() == 0) {
        return null;
    }
    char[] str = manacherString(s);
    int[] pArr = new int[str.length];
    int C = -1;
    int R = -1;
    int maxContainsEnd = -1;
    for (int i = 0; i != str.length; i++) {
        pArr[i] = R > i ? Math.min(pArr[2 * C - i], R - i) : 1;
        while (i + pArr[i] < str.length && i - pArr[i] > -1) {
            if (str[i + pArr[i]] == str[i - pArr[i]])
                pArr[i]++;
            else {
                break;
            }
        }
        if (i + pArr[i] > R) {
            R = i + pArr[i];
            C = i;
        }
        if (R == str.length) {
            //当某个字符的R扩到结尾，就找到包含最后一个字符的最长回文子串了，结束循环，记下这个字符处理字符串下的回文半径
            maxContainsEnd = pArr[i];
            break;
        }
    }
    //对于原字符串后面至少添加的字符串，字符个数是s.length() - maxContainsEnd + 1
    char[] res = new char[s.length() - maxContainsEnd + 1];
    for (int i = 0; i < res.length; i++) {
        //从后往前填res，str是处理字符串，注意下标对应
        res[res.length - 1 - i] = str[i * 2 + 1];
    }
    return String.valueOf(res);
}
// 将原字符串变成处理字符串。如"12132" -> "#1#2#1#3#2#"
public static char[] manacherString(String str) {
    char[] charArr = str.toCharArray();
    char[] res = new char[str.length() * 2 + 1];
    int index = 0;
    for (int i = 0; i != res.length; i++) {
        res[i] = (i & 1) == 0 ? '#' : charArr[index++];
    }
    return res;
}
```

### 29、class29--bfprt算法、蓄水池算法，(聊)

bfprt算法就是用来在无序数组中求第K小的数

#### 1）无序数组中求第K小的数

题目：在无序数组中求第K小的数。

```java
//1、改写快排，递归形式，O(N)。因为递归只走一侧，递归也可以改成迭代
public static int minKth2(int[] arr, int k) {   // k >= 1，第k小，从k=1开始
    //在0~arr.length-1上，假如排序的话，找下标为k-1的值，即求无序数组中第K小的数
    return process2(arr, 0, arr.length - 1, k - 1);
}
// 快排是左右两侧都进递归，而这里就有一侧进入递归，O(N)。因为递归只走一侧，可以改成迭代
// 这个方法代表 arr[L..R]  范围上，如果排序的话(不是真的去排序)，找 位于index的数
public static int process2(int[] arr, int L, int R, int index) {
    if (L == R) { // L = =R ==INDEX
        //数组中就剩一个数了
        return arr[L];
    }
    //1、在arr[L~R]上等概率随机出一个数
    int pivot = arr[L + (int) (Math.random() * (R - L + 1))];
    //2、将原数组分拨了，L~range[0]-1是<pivot的数，range[0]~range[1]是=pivot的数，range[1]+1~R是>pivot的数。（注：左右两侧并没有排序）
    int[] range = partition(arr, L, R, pivot);
    if (index >= range[0] && index <= range[1]) {
        //3.1、index在中间区域，随机的这个数就是所求
        return pivot;
    } else if (index < range[0]) {
        //3.2、index在左侧，递归调用L~range[0]-1
        return process2(arr, L, range[0] - 1, index);
    } else {
        //3.3、index在右侧，递归调用range[1]+1~R
        return process2(arr, range[1] + 1, R, index);
    }
}
public static int[] partition(int[] arr, int L, int R, int pivot) {
    //arr[0~less]是<pivot  arr[less+1 ~ more-1]是=pivot，arr[more~R]是>pivot
    int less = L - 1;
    int more = R + 1;
    int cur = L;
    while (cur < more) {
        if (arr[cur] < pivot) {
            swap(arr, ++less, cur++);
        } else if (arr[cur] > pivot) {
            swap(arr, cur, --more);
        } else {
            cur++;
        }
    }
    return new int[] { less + 1, more - 1 };
}
public static void swap(int[] arr, int i1, int i2) {
    int tmp = arr[i1];
    arr[i1] = arr[i2];
    arr[i2] = tmp;
}
//2、利用bfprt算法，O(N)。(了解即可，平常不用，就用改写快排)
// bfprt算法就是把改写快排中1、在arr[L~R]上等概率随机出一个数 改成 讲究的拿出一个数
public static int minKth3(int[] arr, int k) {
    return bfprt(arr, 0, arr.length - 1, k - 1);
}
// arr[L..R]  如果排序的话，位于index位置的数，是什么，返回
public static int bfprt(int[] arr, int L, int R, int index) {
    if (L == R) {
        return arr[L];
    }
    //1、讲究的拿出一个数
    // L...R  每五个数一组
    // 每一个小组内部排好序
    // 小组的中位数组成新数组
    // 这个新数组的中位数返回
    int pivot = medianOfMedians(arr, L, R);
    //2、将原数组分拨了，L~range[0]-1是<pivot的数，range[0]~range[1]是=pivot的数，range[1]+1~R是>pivot的数。（注：左右两侧并没有排序）
    int[] range = partition(arr, L, R, pivot);
    if (index >= range[0] && index <= range[1]) {
        //3.1、index在中间区域，随机的这个数就是所求
        return pivot;
    } else if (index < range[0]) {
        //3.2、index在左侧，递归调用L~range[0]-1
        return bfprt(arr, L, range[0] - 1, index);
    } else {
        //3.3、index在右侧，递归调用range[1]+1~R
        return bfprt(arr, range[1] + 1, R, index);
    }
}
//讲究的拿出一个数
public static int medianOfMedians(int[] arr, int L, int R) {
    // 1、arr[L...R]  五个数一组
    int size = R - L + 1;
    int offset = size % 5 == 0 ? 0 : 1;
    int[] mArr = new int[size / 5 + offset];
    for (int team = 0; team < mArr.length; team++) {
        //每个小组的第一个数
        int teamFirst = L + team * 5;
        // L ... L + 4
        // L +5 ... L +9
        // L +10....L+14
        // 2、每个小组内部排序
        // 3、每个小组中位数领出来，组成marr
        mArr[team] = getMedian(arr, teamFirst, Math.min(R, teamFirst + 4));
    }
    // 4、marr中，找到中位数
    // marr(0, marr.len - 1,  mArr.length / 2 )
    return bfprt(mArr, 0, mArr.length - 1, mArr.length / 2);
}
//获取有序数组的中位数
public static int getMedian(int[] arr, int L, int R) {
    //每个小组内部进行插入排序
    insertionSort(arr, L, R);
    return arr[(L + R) / 2];
}
public static void insertionSort(int[] arr, int L, int R) {
    for (int i = L + 1; i <= R; i++) {
        for (int j = i - 1; j >= L && arr[j] > arr[j + 1]; j--) {
            swap(arr, j, j + 1);
        }
    }
}
```

#### 2）返回top k个最大的数

题目：设计在无序数组中收集最大的前K个数字的算法（根据不同的三个时间复杂度，设计三个算法）
给定一个无序数组arr中，长度为N，给定一个正数k，返回top k个最大的数
不同时间复杂度三个方法：1）O(N * logN)。2）O(N + K * logN)。3）O(n + k * logk)

```java
// 方法一，时间复杂度O(N*logN)
// 排序+收集
public static int[] maxTopK1(int[] arr, int k) {
    if (arr == null || arr.length == 0) {
        return new int[0];
    }
    int N = arr.length;
    k = Math.min(N, k);
    Arrays.sort(arr);
    int[] ans = new int[k];
    for (int i = N - 1, j = 0; j < k; i--, j++) {
        ans[j] = arr[i];
    }
    return ans;
}

// 方法二，时间复杂度O(N + K*logN)
// 解释：堆
public static int[] maxTopK2(int[] arr, int k) {
    if (arr == null || arr.length == 0) {
        return new int[0];
    }
    int N = arr.length;
    k = Math.min(N, k);
    // 从底向上建堆，时间复杂度O(N)
    for (int i = N - 1; i >= 0; i--) {
        heapify(arr, i, N);
    }
    // 只把前K个数放在arr末尾，然后收集，O(K*logN)
    int heapSize = N;
    swap(arr, 0, --heapSize);
    int count = 1;
    while (heapSize > 0 && count < k) {
        heapify(arr, 0, heapSize);
        swap(arr, 0, --heapSize);
        count++;
    }
    int[] ans = new int[k];
    for (int i = N - 1, j = 0; j < k; i--, j++) {
        ans[j] = arr[i];
    }
    return ans;
}

public static void heapInsert(int[] arr, int index) {
    while (arr[index] > arr[(index - 1) / 2]) {
        swap(arr, index, (index - 1) / 2);
        index = (index - 1) / 2;
    }
}

public static void heapify(int[] arr, int index, int heapSize) {
    int left = index * 2 + 1;
    while (left < heapSize) {
        int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
        largest = arr[largest] > arr[index] ? largest : index;
        if (largest == index) {
            break;
        }
        swap(arr, largest, index);
        index = largest;
        left = index * 2 + 1;
    }
}

public static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

// 方法三，时间复杂度O(n + k * logk)
public static int[] maxTopK3(int[] arr, int k) {
    if (arr == null || arr.length == 0) {
        return new int[0];
    }
    int N = arr.length;
    k = Math.min(N, k);
    // O(N)
    int num = minKth(arr, N - k);
    int[] ans = new int[k];
    int index = 0;
    for (int i = 0; i < N; i++) {
        if (arr[i] > num) {
            ans[index++] = arr[i];
        }
    }
    for (; index < k; index++) {
        ans[index] = num;
    }
    // O(k*logk)
    Arrays.sort(ans);
    for (int L = 0, R = k - 1; L < R; L++, R--) {
        swap(ans, L, R);
    }
    return ans;
}
// 改写快排，迭代形式，O(N)
public static int minKth(int[] arr, int index) {
    int L = 0;
    int R = arr.length - 1;
    int pivot = 0;
    int[] range = null;
    while (L < R) {
        pivot = arr[L + (int) (Math.random() * (R - L + 1))];
        range = partition(arr, L, R, pivot);
        if (index < range[0]) {
            R = range[0] - 1;
        } else if (index > range[1]) {
            L = range[1] + 1;
        } else {
            return pivot;
        }
    }
    return arr[L];
}
public static int[] partition(int[] arr, int L, int R, int pivot) {
    int less = L - 1;
    int more = R + 1;
    int cur = L;
    while (cur < more) {
        if (arr[cur] < pivot) {
            swap(arr, ++less, cur++);
        } else if (arr[cur] > pivot) {
            swap(arr, cur, --more);
        } else {
            cur++;
        }
    }
    return new int[] { less + 1, more - 1 };
}
```

#### 3）蓄水池算法

题目：假设有一个源源吐出不同球的机器，只有装下10个球的袋子，每一个吐出的球，要么放入袋子，要么永远扔掉。如何做到机器吐出每一个球之后，所有吐出的球都等概率被放进袋子里

```java
public static class RandomBox {
    private int[] bag;
    private int N;
    private int count;

    public RandomBox(int capacity) {
        bag = new int[capacity];
        N = capacity;
        count = 0;
    }
    private int rand(int max) {
        return (int) (Math.random() * max) + 1;
    }

    public void add(int num) {
        count++;
        if (count <= N) {
            bag[count - 1] = num;
        } else {
            if (rand(count) <= N) {     //决定进不进袋子
                bag[rand(N) - 1] = num;
            }
        }
    }

    public int[] choices() {
        int[] ans = new int[N];
        for (int i = 0; i < N; i++) {
            ans[i] = bag[i];
        }
        return ans;
    }

}
```

### 30、class30--Morris遍历(聊)

#### 1）Morris遍历的实现

Morris遍历时间复杂度O(N)，额外空间复杂度O(1)，通过利用原树中大量空闲指针的方式，达到节省空间的目的。利用某个节点左子树的最右节点的右指针状态做标记，来判断当前节点是第一次还是第二次

假设来到当前节点cur，开始时cur来到头节点位置
1）如果cur没有左孩子，cur向右移动(cur = cur.right)
2）如果cur有左孩子，找到左子树上最右的节点mostRight：
	a.如果mostRight的右指针指向空，让其指向cur，然后cur向左移动(cur = cur.left)
	b.如果mostRight的右指针指向cur，让其指向null，然后cur向右移动(cur = cur.right)
3）cur为空时遍历停止

```java
public static void morris(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;            //标记当前节点
    Node mostRight = null;      //标记当前节点左子树的最右节点的右指针
    while (cur != null) {       //当前节点为空，说明全部节点都讨论完
        mostRight = cur.left;
        //1、当前节点有左子树
        if (mostRight != null) {
            //1.1、找到当前节点左子树的最右节点。最右节点的右指针要么指向空，要么指向当前节点(说明这个节点来过一次了)
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                //1.2、最右节点的右指针指向空，说明是第一次讨论当前节点，最右节点的右指针指向当前节点，做标记。并准备讨论该节点的左子树
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                //1.3、最右节点的右指针指向当前节点，说明是第二次讨论当前节点，最右节点的右指针指向空，取消标记。并准备讨论该节点的右子树
                mostRight.right = null;
            }
        }
        //2.1、当前结点没有左子树，该节点讨论完，准备去讨论该节点的右子树
        //2.2、或者当前节点的左子树都讨论完了，准备去讨论该节点的右子树
        cur = cur.right;
    }
}
//先序morris遍历
public static void morrisPre(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                //第一次讨论该节点，打印
                System.out.print(cur.value + " ");
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
            }
        } else {
            //该节点没有左树，说明该节点只会经过一次，直接打印
            System.out.print(cur.value + " ");
        }
        cur = cur.right;
    }
    System.out.println();
}
//中序morris遍历
public static void morrisIn(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
                //第一次讨论该节点，打印
                System.out.print(cur.value + " ");
            }
        } else {
            //该节点没有左树，说明该节点只会经过一次，直接打印
            System.out.print(cur.value + " ");
        }
        cur = cur.right;
    }
    System.out.println();
}
//后序morris遍历
public static void morrisPos(Node head) {
    if (head == null) {
        return;
    }
    Node cur = head;
    Node mostRight = null;
    while (cur != null) {
        mostRight = cur.left;
        if (mostRight != null) {
            while (mostRight.right != null && mostRight.right != cur) {
                mostRight = mostRight.right;
            }
            if (mostRight.right == null) {
                mostRight.right = cur;
                cur = cur.left;
                continue;
            } else {
                mostRight.right = null;
                //第二次讨论该节点，逆序打印该节点左树一直到右边界
                printEdge(cur.left);
            }
        }
        cur = cur.right;
    }
    //经过两次的节点的左树右边界都打印完了，在逆序打印整棵树一直到右边届
    printEdge(head);
    System.out.println();
}
//逆序打印该节点一直到右边界
public static void printEdge(Node head) {
    //翻转该节点左树一直到右边界。类似翻转链表
    Node tail = reverseEdge(head);
    Node cur = tail;
    while (cur != null) {
        //逆序打印
        System.out.print(cur.value + " ");
        cur = cur.right;
    }
    //再翻转回来
    reverseEdge(tail);
}
//翻转链表
public static Node reverseEdge(Node from) {
    Node pre = null;
    Node next = null;
    while (from != null) {
        next = from.right;
        from.right = pre;
        pre = from;
        from = next;
    }
    return pre;
}
```

#### 2）二叉树的最小深度

题目：给定一棵二叉树的头节点head，求以head为头的树中，最小深度是多少？

```java
//1、递归解法 
public static int minDepth1(TreeNode head) {
    if (head == null) {
        return 0;
    }
    return p(head);
}
// 返回x为头的树，最小深度是多少
public static int p(TreeNode x) {
    if (x.left == null && x.right == null) {
        return 1;
    }
    // 左右子树起码有一个不为空
    int leftH = Integer.MAX_VALUE;
    if (x.left != null) {
        leftH = p(x.left);
    }
    int rightH = Integer.MAX_VALUE;
    if (x.right != null) {
        rightH = p(x.right);
    }
    return 1 + Math.min(leftH, rightH);
}
//2、morris遍历解法
 public static int minDepth2(TreeNode head) {
     if (head == null) {
         return 0;
     }
     TreeNode cur = head;
     TreeNode mostRight = null;
     int curLevel = 0;
     int minHeight = Integer.MAX_VALUE;
     while (cur != null) {
         mostRight = cur.left;
         if (mostRight != null) {
             int rightBoardSize = 1;
             while (mostRight.right != null && mostRight.right != cur) {
                 rightBoardSize++;
                 mostRight = mostRight.right;
             }
             if (mostRight.right == null) { // 第一次到达
                 curLevel++;
                 mostRight.right = cur;
                 cur = cur.left;
                 continue;
             } else { // 第二次到达
                 if (mostRight.left == null) {
                     minHeight = Math.min(minHeight, curLevel);
                 }
                 curLevel -= rightBoardSize;
                 mostRight.right = null;
             }
         } else { // 只有一次到达
             curLevel++;
         }
         cur = cur.right;
     }
     int finalRight = 1;
     cur = head;
     while (cur.right != null) {
         finalRight++;
         cur = cur.right;
     }
     if (cur.left == null && cur.right == null) {
         minHeight = Math.min(minHeight, finalRight);
     }
     return minHeight;
 }
```

### 31、class31--线段树

线段树是一种支持范围整体修改和范围整体查询的数据结构

线段树解决的问题范畴：大范围信息可以只由左、右两侧信息加工出，而不必遍历左右两个子范围的具体状况

#### 1）线段树的实现

题目：给定一个数组arr，用户希望你实现如下三个方法
1）void add(int L, int R, int V) :  让数组arr[L…R]上每个数都加上V
2）void update(int L, int R, int V) :  让数组arr[L…R]上每个数都变成V
3）int sum(int L, int R) :让返回arr[L…R]这个范围整体的累加和
怎么让这三个方法，时间复杂度都是O(logN)

```java
public static class SegmentTree {
    private int MAXN;           
    private int[] arr;           // arr[]为原序列的信息从0开始，但在arr里是从1开始的
    private int[] sum;           // sum[]模拟线段树维护区间和
    private int[] lazy;          // lazy[]为累加和懒惰标记
    private int[] change;        // change[]为更新的值
    private boolean[] update;    // update[]为更新慵懒标记。用于区分类似change[i]=0 含义到底是更新成0，还是从未更新

    public SegmentTree(int[] origin) {
        MAXN = origin.length + 1;
        arr = new int[MAXN]; // arr[0] 不用 从1开始使用
        for (int i = 1; i < MAXN; i++) {
            arr[i] = origin[i - 1];
        }
        sum = new int[MAXN << 2]; // 用来支持脑补概念中，某一个范围的累加和信息
        lazy = new int[MAXN << 2]; // 用来支持脑补概念中，某一个范围沒有往下傳遞的纍加任務
        change = new int[MAXN << 2]; // 用来支持脑补概念中，某一个范围有没有更新操作的任务
        update = new boolean[MAXN << 2]; // 用来支持脑补概念中，某一个范围更新任务，更新成了什么
    }
    //将左右子树的sum向上累加
    private void pushUp(int rt) {
        sum[rt] = sum[rt << 1] + sum[rt << 1 | 1];
    }
    // 将之前所有的懒增加和懒更新，从父范围，向下发给左右两个子范围
    // ln表示左子树元素结点个数，rn表示右子树结点个数
    private void pushDown(int rt, int ln, int rn) {
        if (update[rt]) {
            update[rt << 1] = true;
            update[rt << 1 | 1] = true;
            change[rt << 1] = change[rt];
            change[rt << 1 | 1] = change[rt];
            lazy[rt << 1] = 0;
            lazy[rt << 1 | 1] = 0;
            sum[rt << 1] = change[rt] * ln;
            sum[rt << 1 | 1] = change[rt] * rn;
            update[rt] = false;
        }
        if (lazy[rt] != 0) {
            //将懒信息下发一层到左右孩子，当前懒信息清空
            lazy[rt << 1] += lazy[rt];
            sum[rt << 1] += lazy[rt] * ln;
            lazy[rt << 1 | 1] += lazy[rt];
            sum[rt << 1 | 1] += lazy[rt] * rn;
            lazy[rt] = 0;
        }
    }
    //建立sum数组，rt是sum数组的下标
    public void build(int l, int r, int rt) {
        if (l == r) {
            sum[rt] = arr[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(l, mid, rt << 1);
        build(mid + 1, r, rt << 1 | 1);
        pushUp(rt);
    }
    //在L~R上都改成C，此时是在l~r这块上进行讨论
    public void update(int L, int R, int C, int l, int r, int rt) {
        //1、l~r都是任务L~R的一部分，不用再找左右子树了，更新后直接停
        if (L <= l && r <= R) {
            update[rt] = true;
            change[rt] = C;
            sum[rt] = C * (r - l + 1);
            lazy[rt] = 0;
            return;
        }
        //2、l~r只有一部分是任务L~R一部分，再去找左右子树
        int mid = (l + r) >> 1;
        //3、将该层信息传递给左右子树
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {
            //4、左子树包含L~R的部分
            update(L, R, C, l, mid, rt << 1);
        }
        if (R > mid) {
            //5、右子树包含L~R的部分
            update(L, R, C, mid + 1, r, rt << 1 | 1);
        }
        //6、左右子树信息都处理完后，将左右子树的sum累加
        pushUp(rt);
    }
    //在L~R上都增加C，此时是在l~r这块上进行讨论
    public void add(int L, int R, int C, int l, int r, int rt) {
        //1、l~r都是任务L~R的一部分，不用再找左右子树了，更新后直接停
        if (L <= l && r <= R) {
            sum[rt] += C * (r - l + 1);
            lazy[rt] += C;
            return;
        }
        //2、l~r只有一部分是任务L~R一部分，再去找左右子树
        int mid = (l + r) >> 1;
        //3、将该层信息传递给左右子树
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {
            //4、左子树包含L~R的部分
            add(L, R, C, l, mid, rt << 1);
        }
        if (R > mid) {
            //5、右子树包含L~R的部分
            add(L, R, C, mid + 1, r, rt << 1 | 1);
        }
        //6、左右子树信息都处理完后，将左右子树的sum累加
        pushUp(rt);
    }
    //查询L~R上的累加和，此时是在l~r这块上进行讨论
    public long query(int L, int R, int l, int r, int rt) {
        //1、l~r都是任务L~R的一部分，不用再找左右子树了，直接返回
        if (L <= l && r <= R) {
            return sum[rt];
        }
        //2、l~r只有一部分是任务L~R一部分，再去找左右子树
        int mid = (l + r) >> 1;
        //3、将该层信息传递给左右子树
        pushDown(rt, mid - l + 1, r - mid);
        long ans = 0;
        if (L <= mid) {
            //4、左子树包含L~R的部分
            ans += query(L, R, l, mid, rt << 1);
        }
        if (R > mid) {
            //5、右子树包含L~R的部分
            ans += query(L, R, mid + 1, r, rt << 1 | 1);
        }
        //6、左右子树信息都处理完后，将左右子树的sum累加
        return ans;
    }
}
```

#### 2）掉落的方块，难

题目：想象一下标准的俄罗斯方块游戏，X轴是积木最终下落到底的轴线。下面是这个游戏的简化版：
1）只会下落正方形积木
2）[a,b] -> 代表一个边长为b的正方形积木，积木左边缘沿着X = a这条线从上方掉落
3）认为整个X轴都可能接住积木，也就是说简化版游戏是没有整体的左右边界的
4）没有整体的左右边界，所以简化版游戏不会消除积木，因为不会有哪一层被填满。
给定一个N*2的二维数组matrix，可以代表N个积木依次掉落，返回每一次掉落之后的最大高度。

```java
public static class SegmentTree {
    private int[] max;
    private int[] change;
    private boolean[] update;

    public SegmentTree(int size) {
        int N = size + 1;
        max = new int[N << 2];

        change = new int[N << 2];
        update = new boolean[N << 2];
    }

    private void pushUp(int rt) {
        max[rt] = Math.max(max[rt << 1], max[rt << 1 | 1]);
    }

    // ln表示左子树元素结点个数，rn表示右子树结点个数
    private void pushDown(int rt, int ln, int rn) {
        if (update[rt]) {
            update[rt << 1] = true;
            update[rt << 1 | 1] = true;
            change[rt << 1] = change[rt];
            change[rt << 1 | 1] = change[rt];
            max[rt << 1] = change[rt];
            max[rt << 1 | 1] = change[rt];
            update[rt] = false;
        }
    }

    public void update(int L, int R, int C, int l, int r, int rt) {
        if (L <= l && r <= R) {
            update[rt] = true;
            change[rt] = C;
            max[rt] = C;
            return;
        }
        int mid = (l + r) >> 1;
        pushDown(rt, mid - l + 1, r - mid);
        if (L <= mid) {
            update(L, R, C, l, mid, rt << 1);
        }
        if (R > mid) {
            update(L, R, C, mid + 1, r, rt << 1 | 1);
        }
        pushUp(rt);
    }

    public int query(int L, int R, int l, int r, int rt) {
        if (L <= l && r <= R) {
            return max[rt];
        }
        int mid = (l + r) >> 1;
        pushDown(rt, mid - l + 1, r - mid);
        int left = 0;
        int right = 0;
        if (L <= mid) {
            left = query(L, R, l, mid, rt << 1);
        }
        if (R > mid) {
            right = query(L, R, mid + 1, r, rt << 1 | 1);
        }
        return Math.max(left, right);
    }

}

public HashMap<Integer, Integer> index(int[][] positions) {
    TreeSet<Integer> pos = new TreeSet<>();
    for (int[] arr : positions) {
        pos.add(arr[0]);
        pos.add(arr[0] + arr[1] - 1);
    }
    HashMap<Integer, Integer> map = new HashMap<>();
    int count = 0;
    for (Integer index : pos) {
        map.put(index, ++count);
    }
    return map;
}

public List<Integer> fallingSquares(int[][] positions) {
    HashMap<Integer, Integer> map = index(positions);
    int N = map.size();
    SegmentTree segmentTree = new SegmentTree(N);
    int max = 0;
    List<Integer> res = new ArrayList<>();
    // 每落一个正方形，收集一下，所有东西组成的图像，最高高度是什么
    for (int[] arr : positions) {
        int L = map.get(arr[0]);
        int R = map.get(arr[0] + arr[1] - 1);
        int height = segmentTree.query(L, R, 1, N, 1) + arr[1];
        max = Math.max(max, height);
        res.add(max);
        segmentTree.update(L, R, height, 1, N, 1);
    }
    return res;
}
```

### 32、class32--IndexTree、AC自动机

#### 1）一维IndexTree实现

一维IndexTree：关键在于利用指定数最右侧的1

1、随便一个二进制的数，需要在index上+d，index不断加上最右侧的1，这些index的数组值都需要+d

2、随便一个二进制的数，求1~这个数的累加和，index不断减去最右侧的1，这些index的数组值的累加和即为所求

```java
public static class IndexTree {
    private int[] tree;
    private int N;

    // 0位置弃而不用！
    public IndexTree(int size) {
        N = size;
        tree = new int[N + 1];
    }

    // 1~index 累加和是多少
    public int sum(int index) {
        int ret = 0;
        while (index > 0) {
            ret += tree[index];
            //删去最右侧的1，就是上一个需要累加的位置
            index -= index & -index;
        }
        return ret;
    }

    // index & -index : 提取出index最右侧的1出来
    // index :           0011001000
    // index & -index :  0000001000
    //在index位置加d。还会影响后面的某些位置
    public void add(int index, int d) {
        while (index <= N) {
            tree[index] += d;
            //加上最右侧的1，就是下一个受牵连的位置
            index += index & -index;
        }
    }
}
```

#### 2）二维IndexTree实现

```java
public static class IndexTree2D {
    private int[][] tree;
    private int[][] nums;
    private int N;
    private int M;

    public IndexTree2D(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return;
        }
        N = matrix.length;
        M = matrix[0].length;
        tree = new int[N + 1][M + 1];
        nums = new int[N][M];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < M; j++) {
                update(i, j, matrix[i][j]);
            }
        }
    }

    private int sum(int row, int col) {
        int sum = 0;
        for (int i = row + 1; i > 0; i -= i & (-i)) {
            for (int j = col + 1; j > 0; j -= j & (-j)) {
                sum += tree[i][j];
            }
        }
        return sum;
    }

    public void update(int row, int col, int val) {
        if (N == 0 || M == 0) {
            return;
        }
        int add = val - nums[row][col]; //update改成add的代码形式。更新成val相当于加add
        nums[row][col] = val;
        for (int i = row + 1; i <= N; i += i & (-i)) {
            for (int j = col + 1; j <= M; j += j & (-j)) {
                tree[i][j] += add;
            }
        }
    }
	//求[row1,col1] ~ [row2,col2]这个区间的累加和
    public int sumRegion(int row1, int col1, int row2, int col2) {
        if (N == 0 || M == 0) {
            return 0;
        }
        return sum(row2, col2) + sum(row1 - 1, col1 - 1) - sum(row1 - 1, col2) - sum(row2, col1 - 1);
    }
}
```

#### 3）AC自动机的实现，难

```java
// 前缀树的节点
public static class Node {
    // 如果一个node，end为空，不是结尾
    // 如果end不为空，表示这个点是某个字符串的结尾，end的值就是这个字符串
    public String end;
    // 只有在上面的end变量不为空的时候，endUse才有意义
    // 表示，这个字符串之前有没有加入过答案
    public boolean endUse;
    public Node fail;
    public Node[] nexts;

    public Node() {
        endUse = false;
        end = null;
        fail = null;
        nexts = new Node[26];
    }
}

public static class ACAutomation {
    private Node root;

    public ACAutomation() {
        root = new Node();
    }

    // 将每个敏感词加入到前缀树中。有多少个匹配串，就调用多少次insert
    public void insert(String s) {
        char[] str = s.toCharArray();
        Node cur = root;
        int index = 0;
        for (int i = 0; i < str.length; i++) {
            index = str[i] - 'a';
            if (cur.nexts[index] == null) {
                cur.nexts[index] = new Node();
            }
            cur = cur.nexts[index];
        }
        cur.end = s;
    }

    public void build() {
        //广度优先遍历
        Queue<Node> queue = new LinkedList<>();
        queue.add(root);
        Node cur = null;
        Node cfail = null;
        while (!queue.isEmpty()) {
            //当前讨论节点作为父亲的姿态，然后把它的所有子节点的fail指针填好
            cur = queue.poll(); // 弹出某个父亲
            for (int i = 0; i < 26; i++) { // 检验每条路是否有孩子
                if (cur.nexts[i] != null) { // 该路下有子节点
                    //1、初始时孩子的fail先设置root
                    cur.nexts[i].fail = root;
                    //2、找父亲的fail
                    cfail = cur.fail;
                    while (cfail != null) { // cur不是头节点
                        if (cfail.nexts[i] != null) {
                            //3、父亲的fail指向的那个结点有i号路，子节点的fail指向父亲的fail，停
                            cur.nexts[i].fail = cfail.nexts[i];
                            break;
                        }
                        //4、父亲的fail指向的那个结点没有i号路，找父亲的fail的fail(只要没找到，就找fail)
                        cfail = cfail.fail;
                    }
                    //5、这个孩子节点加入队列
                    queue.add(cur.nexts[i]);
                }
            }
        }
    }

    // 大文章：content
    public List<String> containWords(String content) {
        char[] str = content.toCharArray();
        Node cur = root;
        Node follow = null;
        int index = 0;
        List<String> ans = new ArrayList<>();
        for (int i = 0; i < str.length; i++) {
            index = str[i] - 'a'; // 路
            // 如果当前字符在这条路上没配出来，就随着fail方向走向下条路径
            while (cur.nexts[index] == null && cur != root) {
                cur = cur.fail;
            }
            // 1) 现在来到的路径，是可以继续匹配的
            // 2) 现在来到的节点，就是前缀树的根节点
            cur = cur.nexts[index] != null ? cur.nexts[index] : root;
            follow = cur;
            while (follow != root) {
                //沿着follow的fai的转一圈到root，检验途中是否有 follow.end != null(每个敏感词的最后一个字符follow.end!=null)，有就记录，找到一个敏感词
                if (follow.endUse) {
                    break;
                }
                // 不同的需求，在这一段之间修改
                if (follow.end != null) {
                    ans.add(follow.end);
                    follow.endUse = true;
                }
                // 不同的需求，在这一段之间修改
                follow = follow.fail;
            }
        }
        return ans;
    }

}
```

### 33、class33--与哈希函数有关的结构

1、认识哈希函数 --> out f(in data)

1）输入参数data，假设是in类型，特征：可能性无穷大，比如str类型的参数

2）输出参数类型out，特征：可能性可以很大，但一定是有穷尽的

3）哈希函数没有任何随机的机制，固定的输入一定是固定的输出

4）输入无穷多但输出值有限，所以不同输入也可能输出相同（哈希碰撞）

5）重点：再相似的不同输入，得到的输出值，会几乎均匀的分布在out域上

2、哈希函数作用：可以把数据根据不同值，几乎均匀的分开（例：哈希表的设计）

3、布隆过滤器：用于集合的建立与查询，并可以节省大量空间

准备一个空间（可以理解是数组），准备k个哈希函数，每个str通过k个哈希函数找出k个位置，进空间进行描黑

查的时候一个str通过k个哈希函数找出k个位置，k个位置都是黑的就认为在空间里，有一个不是黑的就不认为在。

布隆过滤器重要的三个公式。先问面试官允许有失误率么，允许就是布隆过滤器题目，不允许就是其他题目

![image-20230215170052575](C:\Users\14452\AppData\Roaming\Typora\typora-user-images\image-20230215170052575.png)

4、一致性哈希：解决数据服务器的负载管理问题

解决增加减少机器，让数据迁移不是全量的，而且还能做到负载均衡

分布式存储结构最常见的结构

1）哈希域变成环的设计

2）虚拟节点技术。解决一上来机器就不均匀的问题，加机器后不均匀的问题

### 34、class34--资源限制类题目

资源限制技巧

1）布隆过滤器用于集合的建立与查询，并可以节省大量空间
2）一致性哈希解决数据服务器的负载管理问题
3）利用并查集结构做岛问题的并行计算
4）哈希函数可以把数据按照种类均匀分流
5）位图解决某一范围上数字的出现情况，并可以节省大量空间
6）利用分段统计思想、并进一步节省大量空间
7）利用堆、外排序来做多个处理单元的结果合并

#### 题目一：32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，可以使用最多1GB的内存，怎么找到出现次数最多的数？

使用方法四：利用哈希函数进行分流。

因为有40亿个无符号整数，因此如果直接开辟一个数组对其中的所有整数进行排序，那么需要的数组大小是40亿 * 4 =160亿个B，即16G，就超过了题目限定的1G内找到出现次数最多的数。

那么我们可以用哈希表，它的大小跟整数出现的次数没有关系，而是跟这40亿个整数的种类有关系。因为一个数再怎么多，用哈希表记录的还是对应的key-value，只不过value在增加。而它们分别是4个字节，加起来就是8个字节。

假设最坏情况下，出现的40亿个无符号整数都不相同，则哈希表的大小为40亿 * 8 = 320亿个B，即32G，还不如直接在数组中排序再统计的内存大小。

我们可以反过来想，1G的内存如果用哈希表对数据进行记录，那么可以记录的条数有：1G约等于10亿B，再用10亿除以8，则记录的条数有1亿两千500条。但是哈希表中除了数据外，还有其它的属性会占用空间，因此为了保守起见，就假设该哈希表就只能装1千万条数据。

因此我们可以用40亿个数 / 1千万条数据=400，当一个数来的时候，就可以将该数字用哈希函数，算出一个哈希值后，模上400，那么最后的范围一定是0~399（文件号）。再将该数字放入最后模的文件号当中。因为哈希函数的均匀性，即使是有40亿种不同的数，最后也会均分地放到各个文件当中。

即使有些碰撞，一个文件中的数据多于1千万条，但没有关系。因为在前面我们算过，一个文件真正可以存的数据条数是1亿两千500条。1千万条只是比较保守的一个数，因此一个文件超了1千万条数据也不会有什么，也不会超的了多少。

按照哈希函数的性质，一个相同的东西经哈希函数算出的哈希值一定相同。因此就一个东西就不可能会分配到多个文件当中。那么就可以用一个哈希表依次记录各个文件中出现次数最多的数，记录完一个文件的就释放哈希表的内存空间，再记录下一个文件中出现次数最多的数。到最后，得到的是这400个文件中各个文件的出现最多次数的数，再求其中的出现次数最多的数，就能够得到所有数中出现次数最多的数。(仔细读有点绕，但不难)

推广：
当一个超级大文件来的时候，给你一个限制条件，一个文件不能超过多少G，当我们发现如果用哈希表直接进行记录时会超出该限制条件。
解决方法：
同样地，对大文件中的数据用哈希函数求出哈希值再%，得到一个数代表文件号，就放到对应的文件中。但是我们说了如果直接存的话会超出内存限制，因此可以进行二次哈希，对进入小文件的数据用另一个哈希函数求出hash值后，进行小小文件，直到满足题目给定的条件位置。

#### 题目二：32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。可以使用最多1GB的内存，怎么找到所有未出现过的数？

使用方法五：位图解决某一范围上数字的出现情况，并可以节省大量空间。

如果使用Set，则内存会有40亿*4=160亿B=16G，超出了题目给出的内存限制。

我们可以使用位图，创建一个由bit类型组成的数组，其中的一个下标就是1个bit。因此可以创建2的32次方个bit大小的数组。又因为8个bit组成一个B，则该数组就一共有2的32次方 / 8 个B，这个是肯定在1G的范围内的，因此就满足了题目的限定条件。

但是对于一个具体的bit(将一个整型当作一个大bit来看，对应到数组中的位置)要对应到数组中的bit，该如何设置？
可以先创建整型数组，大小为10，即创建出了320个bit大小的数组。此时要求出一个具体的i(bit)对应到数组中的哪个bit，则可以用i先除一个32，得到i归属于哪个下标表示bit位。再用i%32求出i在该部分的哪个具体位置。

举个例子：此时有一个i为64，数组是整型数组，大小为10。则arr[0]=0~31，arr[1]=32 ~63，arr[2]=64 ~95，此时64先除32，得到2，则属于2下标的位置。再用64%32=0，则在下标为2的0号bit位。得到该bit位后&1，如果得到的是1，则原本为1状态；如果得到的是0，则原本为0状态。用代码表示为：int status = (arr[i/32]&(1<<(i%32)))==0?0:1;

因此对于一个40亿整数的文件，遍历该文件中的数字，出现一个数字就用哈希函数求出哈希值再对应到数组中的bit位置，再把该位置描黑代表出现过。到最后，如果bit数组中有对应的bit位没有描黑，则对应的位数就是没有出现的数字。

【进阶】内存限制为 3KB，但是只用找到一个没出现过的数即可
使用方法六：利用分段统计思想、并进一步节省大量空间。

因为内存限制为3KB，则为3000B，如果开辟一个整型数组，那么整型数组的长度为3000B / 4B = 750 。这个是刚好不会超出内存范围的。为了让2的32次方个数能够均分到数组中，我们可以将数组的大小一个离750这个数最近的2的几次方的一个数，即512。

因此该数组的一个下标代表的范围是2的32次方 / 512 = 8388608，因为40亿个数是在43亿个数的范围内的，则肯定有某些数是没有出现过的。

因为按照题目要求，找到一个没出现的数即可，那么肯定能够找到不满的其中一个下标的范围。再在该范围中去找哪个数字没出现。在该范围中得知有没出现的数字，我们可以再将该范围分成512份，因此在新的小范围中肯定又有不满的小范围，再把不满的新的小范围分成512份，直到定位出没出现的数为止。

【进阶】只用有限几个变量，如何在40亿个无符号整数中找出一个没有出现过的数？
我们可以定义一个L和R，L到0位置，R到2的32次方位置。进行二分，mid就是在中间的位置，划分左右两边为2的31次方那么多数。就必然存在左右两侧不够2的31次方的情况，再在不够的一侧进行二分，到最后一定能把没出现的数二分出来。

总结：在3K内存限制的时候，进行512分。在有限几个变量限制的时候，进行二分。

#### 题目三：有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL

首先可以使用布隆过滤器，但是利用它会有失误率。如果不能有失误率，则用哈希函数进行分流的方法。
先对大文件中的数据用哈希函数求出哈希值，分配到小文件当中。如果该小文件不能满足题目的内存限制要求，就对小文件中的数据再次进行哈希，放入到直到满足题目要求的文件中即可。主要的就是利用多次哈希。

【补充】某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法
哈希函数可以把数据按照种类均匀分流，将所有词汇按种类分配进入不同的小文件中，然后求出每一个文件中的前100，最后汇总求出总体的前100。

#### 题目四：32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。

可以利用位图，建立一个bit数组。每两个bit代表一个数字的出现次数的情况。假设数组最前两个bit位代表的是0，后面两个bit位代表的是1，可以代表1的两个bit位进行统计出现的次数。如果是00，代表1一次都没有出现；如果是01，代表出现了1次；如果是10，代表出现了两次；如果是11，代表出现了三次或三次以上。出现一个数就人为地设置它代表的两个bit位，出现11之后就无需再管它。

最后遍历数组，找出哪个数对应的bit位是10的，那么就说明它出现了两次。

但是，因为我们是用两个bit位代表一个数字的出现次数，假设用一个bit位的时候，数组的大小为：2的32次方 / 8 / 1000 = 536,870,912M，因为是两bit位，则再乘2，超过了1G。那么如何解决？

可以使用分段加位图的思想。我们可以先统计前半部分的2的31次方哪个数出现了两次，再统计后半部分的2的31次方哪个数出现了两次，最后就能够求出这40亿个数哪些数出现了两次。

#### 题目五：32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多3K的内存，怎么找到这40亿个整数的中位数？

分段统计思想，将数分为各个区间，然后区间内统计词频，可以知道中位数在哪个区间中，然后再将该区间在分段求解。

同样地，因为是最多3K内存，可以设置一个长度512的数组对2的32次方个数进行划分。在数组中对每个下标代表的数进行统计。如：下标0代表的数是0~8388608。

因为要找出40亿个数的中位数，那么要找出第20亿个数是哪个。如果下标0中出现的数有1亿个，那么中位数绝对不可能出现在下标0代表的某个数中。假设统计0到170下标的数有19亿个，到171下标的数有23亿个，那么中位数肯定就是在171下标代表的某个数中。找到171下标中第一亿个数就是中位数。

#### 题目六：32位无符号整数的范围是0~4294967295，有一个10G大小的文件，每一行都装着这种类型的数字，整个文件是无序的，给你5G的内存空间，请你输出一个10G大小的文件，就是原文件所有数字排序的结果

先创建一个容器，它是可以排序的，并且能够记录出现的数字与对应的次数。放三条记录。遍历大文件，如果遇到一个数比该容器中出现的最大值小，那么就让容器中的最大值出去，小的数进来。到最后一定是该文件中数字最小的前三名。

例如1出现了1000次，6出现了9万次，13出现了15万次。创建一个大文件，将容器中的数字从小到大并且按统计的次数放多少个，依次放入大文件中。当放完容器中的数后，用一个变量t记住容器中最大的数。当下次遍历大文件的时候，如果出现了小于t的数就不用管统计。重复按照这些步骤，最后的大文件中一定是原来大文件的排序好的结果。

按照题目要求是5G，那么我们可以创建的容器有5G的大小。步骤跟上面的完全一样。容器的结构就是大根堆。

#### 题目七：求一个大文件中出现次数最多的前100名

方法：哈希函数分流+堆上堆的方法。

先将大文件用哈希函数求出哈希值分流到小文件中，在小文件中利用大根堆按照出现的次数进行TOP100的排序。最后从各个小文件中取出自己的TOP1，放入到一个新的大根堆中，在新大根堆中按照出现次数排序，这里的TOP1才是全局的TOP1。假设这个TOP1来自二号文件。再从二号文件的TOP2中入新的大根堆，这次就TOP1就是全局的TOP2，以此类推。

### 35、class35--根据对数器找规律、卡特兰数

1、对数器找规律：

1）某个面试题，输入参数类型简单，并且只有一个实际参数

2）要求的返回值类型也简单，并且只有一个

3）用暴力方法，把输入参数对应的返回值，打印出来看看，进而找规律优化code

#### 1）最少袋子装苹果

题目：小虎去买苹果，商店只提供两种类型的塑料袋，每种类型都有任意数量
1）能装下6个苹果的袋子
2）能装下8个苹果的袋子
小虎可以自由使用两种袋子来装苹果，但是小虎有强迫症，他要求自己使用的袋子数量必须最少，且使用的每个袋子必须装满，给定一个正整数N，返回至少使用多少袋子。如果N无法让使用的每个袋子必须装满，返回-1

```java
//1、暴力解
public static int minBags(int apple) {
    if (apple < 0) {
        return -1;
    }
    //先用最多的装8个苹果的袋子，然后袋子依次减少，装6个苹果的袋子依次增多，直到找到合适的最少袋子
    int bag8 = (apple >> 3);
    int rest = apple - (bag8 << 3);
    while(bag8 >= 0) {
        // rest 个
        if(rest % 6 ==0) {
            return bag8 + (rest / 6);
        } else {
            bag8--;
            rest += 8;
        }
    }
    return -1;
}
//2、根据对数器找规律
public static int minBagAwesome(int apple) {
    //1、如果是奇数，返回-1
    if ((apple & 1) != 0) {
        return -1;
    }
    //2、apple<18，没看出啥规律，直接硬写
    if (apple < 18) {
        return apple == 0 ? 0 : (apple == 6 || apple == 8) ? 1
            : (apple == 12 || apple == 14 || apple == 16) ? 2 : -1;
    }
    //3、apple>=18,8个数为一组，奇数为-1，偶数从3开始总过4个3，每一组过后偶数的值+1
    return (apple - 18) / 8 + 3;
}
```

#### 2）牛羊吃草

题目：给定一个正整数N，表示有N份青草统一堆放在仓库里，有一只牛和一只羊，牛先吃，羊后吃，它俩轮流吃草。不管是牛还是羊，每一轮能吃的草量必须是：1，4，16，64…(4的某次方)。谁最先把草吃完，谁获胜，假设牛和羊都绝顶聪明，都想赢，都会做出理性的决定。根据唯一的参数N，返回谁会赢

```java
//1、暴力解
public static String winner1(int n) {
    if (n < 5) {        //n<5，硬写
        return n == 0 || n == 2 ? "后手" : "先手";
    }
    // 进到这个过程里来，当前的先手，先选
    int want = 1;
    while (want <= n) {
        //后续过程的后手 和 当前过程的先手是一个人，如果后续过程的后手赢了，说明当前过程的先手就赢了
        if (winner1(n - want).equals("后手")) {
            return "先手";
        }
        if (want <= (n / 4)) {  //这条判断防止数据*4后溢出超出int所能表示的最大范围
            want *= 4;
        } else {
            break;  //再*4就超出int所能表示的最大范围，这里就break
        }
    }
    return "后手";
}
//2、根据对数器找规律
public static String winner2(int n) {
    if (n % 5 == 0 || n % 5 == 2) {
        return "后手";
    } else {
        return "先手";
    }
}
```

#### 3）验证某数是否能表示成若干连续正数和

题目：定义一种数：可以表示成若干（数量>1）连续正数和的数。比如，5=2+3，5就是这样的数；12=3+4+5，12就是这样的数。2=1+1，2不是这样的数，因为等号右边不是连续正数。给定一个参数N，返回是不是可以表示成若干连续正数和的数

```java
//1、暴力解
public static boolean isMSum1(int num) {
    for (int start = 1; start <= num; start++) {
        //num第一个加数从1开始试，把所有可能都试一遍，不行的话在从2开始试，以此类推
        int sum = start;
        for (int j = start + 1; j <= num; j++) {
            //从两个数开始试(1+2)，不行的话1+2+3，以此类推，直到超出num，start换2开始
            if (sum + j > num) {
                //超出num，换start
                break;
            }
            if (sum + j == num) {
                //满足条件，返回true
                return true;
            }
            sum += j;
        }
    }
    return false;
}

//2、根据对数器找规律
public static boolean isMSum2(int num) {
    //只要num是2的倍数，即num的二进制表示只有一个1，就返回false
    //提取num最右侧的1,num减去后，看是否是0，是0，num就是2的倍数，返回false
    return num - (num & (~num + 1)) != 0;  //num & (~num + 1) 也可写成 num & (-num)
}
```

#### 4）卡特兰数

k(0) = 1, k(1) = 1，如果接下来的项满足

范式1：k(n) = k(0) * k(n - 1) + k(1) * k(n - 2) + ... + k(n - 2) * k(1) + k(n - 1) * k(0)
或者 范式2：k(n) = c(2n, n) - c(2n, n-1)。或者 范式3：k(n) = c(2n, n) / (n + 1)

就说这个表达式满足卡特兰数，常用的是范式1和2，3几乎不会用到

对于卡特兰数相关题目要注意：1）范式1和2要记住。2）括号模型要记住，就是左右括号数量相等时求合法情况3）发现通项公式符合范式1，就用卡特兰数求答案

题目一：假设给你N个0，和N个1，你必须用全部数字拼序列，返回有多少个序列满足任何前缀串，1的数量都不少于0的数量

ans = c(2n, n) - c(2n, n-1)

题目二：有N个二叉树节点，每个节点彼此之间无任何差别，返回由N个二叉树节点，组成的不同结构数量是多少

ans = c(2n, n) - c(2n, n-1)

### 36、class36--根据数据量猜解法

#### 1）贿赂怪兽

题目：int[] d，d[i]：i号怪兽的能力。int[] p，p[i]：i号怪兽要求的钱。开始时你的能力是0，你的目标是从0号怪兽开始，通过所有的怪兽。如果你当前的能力，小于i号怪兽的能力，你必须付出p[i]的钱，贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上；如果你当前的能力，大于等于i号怪兽的能力，你可以选择直接通过，你的能力并不会下降，你也可以选择贿赂这个怪兽，然后怪兽就会加入你，他的能力直接累加到你的能力上。返回通过所有的怪兽，需要花的最小钱数

```java
// int[] d d[i]：i号怪兽的武力
// int[] p p[i]：i号怪兽要求的钱
//1、适用于怪兽能力值小，dp时以怪兽能力值为列，花的钱多少无所谓
public static long func1(int[] d, int[] p) {
    //从第0号怪兽开始谈论，此时能力值为0
    return process1(d, p, 0, 0);
}
//适用于怪兽能力值小，dp时以怪兽能力值为列，花的钱多少无所谓
//当前讨论第index号怪兽，此时我现在的能力是ability，返回通过所有怪兽需要花的最小钱数
public static long process1(int[] d, int[] p, int index, int ability) {
    if (index == d.length) {
        //怪兽都讨论完了,不需要花钱了
        return 0;
    }
    //1、只有当前有的能力 >= 怪兽的能力 才能选择贿赂不贿赂。
    if (ability >= d[index]) {
        //1.1、不贿赂index号怪兽
        long p1 = process1(d, p, index + 1, ability);
        //1.2、贿赂index号怪兽
        long p2 = p[index] + process1(d, p, index + 1, ability + d[index]);
        return Math.min(p1, p2);
    } else {
        //2、当前有的能力 < 怪兽的能力只能贿赂，不贿赂就打不过
        return p[index] + process1(d, p, index + 1, ability + d[index]);
    }
}
public static long dp1(int[] d, int[] p) {
    int N = d.length; //怪兽的数量
    int maxAbility = 0; //最大的能力值
    for (int i = 0; i < N; i++) {
        maxAbility += d[i];
    }
    //dp[i][j]代表当前讨论第i号怪兽，此时我的能力值是j时，通过所有怪兽需要花的最小钱数
    long[][] dp = new long[N + 1][maxAbility + 1];
    //dp[N][...] = 0;
    for (int i = N - 1; i >= 0; i--) {
        for (int j = 0; j <= maxAbility; j++) {
            if(j + d[i] > maxAbility){
                //如果 当前能力+怪兽能力 越界了，这一行后面的值不用填了，没意义了
                break;
            }
            //1、只有当前有的能力 >= 怪兽的能力 才能选择贿赂不贿赂。
            if (j >= d[i]) {
                //1.1、不贿赂index号怪兽
                long p1 = dp[i + 1][j];
                //1.2、贿赂index号怪兽
                long p2 = p[i] + dp[i + 1][j + d[i]];
                dp[i][j] = Math.min(p1, p2);
            } else {
                //2、当前有的能力 < 怪兽的能力只能贿赂，不贿赂就打不过
                dp[i][j] = p[i] + dp[i + 1][j + d[i]];
            }
        }
    }
    return dp[0][0];
}
//2、适用于怪兽花的钱少，dp时以怪兽花的钱为列,能力值多少无所谓
public static int func2(int[] d, int[] p) {
    int N = d.length; // 怪兽数量
    int sumMoney = 0;
    for (int i = 0; i < N; i++){
        sumMoney += p[i];
    }
    for(int money = 0; money < sumMoney; money++){
        //讨论最后一个怪兽，第一个合格的钱就是需要花的最小钱数
        if(process2(d,p,N-1,money) != -1){
            return money;
        }
    }
    //如果都不行，就返回所有怪兽的钱数
    return sumMoney;
}
//适用于怪兽花的钱少，dp时以怪兽花的钱为列,能力值多少无所谓
//当前讨论第index号怪兽，要求之前花money钱，返回通过所有怪兽的最大能力值，能力越大后面才能选择贿赂还是不贿赂所以返回最大能力值
public static long process2(int[] d, int[] p, int index, int money) {
    if(index == -1){
        //还没遇见怪兽呢
        //返回-1就是之前无法满足花money
        return money == 0 ? 0 : -1;
    }
    //1、不贿赂index号怪兽
    long preMaxAbility1 = process2(d,p,index-1,money);
    long p1 = -1;
    //只有之前有的能力 >= 怪兽的能力 才能选择贿赂不贿赂。
    if(preMaxAbility1 != -1 && preMaxAbility1 >= d[index]){
        p1 = preMaxAbility1;
    }
    //2、贿赂index号怪兽
    long preMaxAbility2 = process2(d,p,index-1,money-p[index]);
    long p2 = -1;
    if(preMaxAbility2 != -1){
        //确保讨论index-1怪兽时，花了money-p[index]
        p2 = d[index] + preMaxAbility2;
    }
    return Math.max(p1,p2);
}
public static long dp2(int[] d, int[] p) {
    int sum = 0;
    for (int num : p) {
        sum += num;
    }
    // dp[i][j]含义：
    // 能经过0～i的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
    // 如果dp[i][j]==-1，表示经过0～i的怪兽，花钱为j是无法通过的，或者之前的钱怎么组合也得不到正好为j的钱数
    int[][] dp = new int[d.length][sum + 1];
    for (int i = 0; i < dp.length; i++) {
        for (int j = 0; j <= sum; j++) {
            dp[i][j] = -1;
        }
    }
    // 经过0～i的怪兽，花钱数一定为p[0]，达到武力值d[0]的地步。其他第0行的状态一律是无效的
    dp[0][p[0]] = d[0];
    for (int i = 1; i < d.length; i++) {
        for (int j = 0; j <= sum; j++) {
            // 可能性一，为当前怪兽花钱
            // 存在条件：
            // j - p[i]要不越界，并且在钱数为j - p[i]时，要能通过0～i-1的怪兽，并且钱数组合是有效的。
            if (j >= p[i] && dp[i - 1][j - p[i]] != -1) {
                dp[i][j] = dp[i - 1][j - p[i]] + d[i];
            }
            // 可能性二，不为当前怪兽花钱
            // 存在条件：
            // 0~i-1怪兽在花钱为j的情况下，能保证通过当前i位置的怪兽
            if (dp[i - 1][j] >= d[i]) {
                // 两种可能性中，选武力值最大的
                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j]);
            }
        }
    }
    int ans = 0;
    // dp表最后一行上，dp[N-1][j]代表：
    // 能经过0～N-1的怪兽，且花钱为j（花钱的严格等于j）时的武力值最大是多少？
    // 那么最后一行上，最左侧的不为-1的列数(j)，就是答案
    for (int j = 0; j <= sum; j++) {
        if (dp[d.length - 1][j] != -1) {
            ans = j;
            break;
        }
    }
    return ans;
}
```

#### 2）子序列中累加和%m之后的最大值

题目：给定一个非负数组arr，和一个正数m，返回arr的所有子序列中累加和%m之后的最大值

```java
public static int max1(int[] arr, int m) {
    HashSet<Integer> set = new HashSet<>();
    //set装所有的累加和情况
    process(arr, 0, 0, set);
    int max = 0;
    for (Integer sum : set) {
        max = Math.max(max, sum % m);
    }
    return max;
}

//当前讨论第0~index号数，之前的累加和是sum，set装所有可能的累加和
public static void process(int[] arr, int index, int sum, HashSet<Integer> set) {
    if (index == arr.length) {
        //所有数都讨论完了，set装之前的累加和sum
        set.add(sum);
    } else {
        //1、不要这个数
        process(arr, index + 1, sum, set);
        //2、要这个数
        process(arr, index + 1, sum + arr[index], set);
    }
}

//1、适用于arr的值都不大数，即累加和不大，dp表以子序列的累加和为列。m很大
public static int max2(int[] arr, int m) {
    int sum = 0;
    int N = arr.length;
    for (int i = 0; i < N; i++) {
        sum += arr[i];
    }
    //dp[i][j]当前讨论第0~i号数，是否能搞定累加和j
    boolean[][] dp = new boolean[N][sum + 1];
    for (int i = 0; i < N; i++) {
        //累加和为0时，就是每个数都不选，一定能搞出来
        dp[i][0] = true;
    }
    //只讨论第一个数，累加和能搞出arr[0]，就是选他，
    dp[0][arr[0]] = true;
    for (int i = 1; i < N; i++) {
        for (int j = 1; j <= sum; j++) {
            //1、不选当前数
            dp[i][j] = dp[i - 1][j];
            if (j - arr[i] >= 0) {  //防止数组越界
                //2、选当前数
                dp[i][j] |= dp[i - 1][j - arr[i]];
            }
        }
    }
    int ans = 0;
    for (int j = 0; j <= sum; j++) {
        //讨论第0~N-1号数,把所有可能的累加和都试一遍，找出最大符合的
        if (dp[N - 1][j]) {
            ans = Math.max(ans, j % m);
        }
    }
    return ans;
}
//2、适用于m不大，dp表以子序列的累加和%m的余数为列。arr的值大，即累加和大。
public static int max3(int[] arr, int m) {
    int N = arr.length;
    // 0...m-1
    //dp[i][j]代表0~i-1之间的数子序列累加和%m的余数是否是j
    boolean[][] dp = new boolean[N][m];
    for (int i = 0; i < N; i++) {
        //子序列累加和%m的余数为0时，就是每个数都不选，一定能搞出来余数0
        dp[i][0] = true;
    }
    //只讨论第一个数，累加和%m余数是arr[0]%m
    dp[0][arr[0] % m] = true;
    for (int i = 1; i < N; i++) {
        for (int j = 1; j < m; j++) {
            //1、不选当前数
            dp[i][j] = dp[i - 1][j];
            //2、选当前数
            int cur = arr[i] % m;
            if (cur <= j) {
                //当前数%m余数 <= 当前要求的余数j，只需0~i-2之间的数子序列累加和%m的余数是j-cur
                dp[i][j] |= dp[i - 1][j - cur];
            } else {
                //当前数%m余数 > 当前要求的余数j，需0~i-2之间的数子序列累加和%m的余数是m + j - cur,要大一圈最终才能余数为j
                dp[i][j] |= dp[i - 1][m + j - cur];
            }
        }
    }
    int ans = 0;
    for (int i = m - 1; i > 0; i--) {
        if (dp[N - 1][i]) {
            //讨论第0~N-1号数,把所有可能的子序列累加和%m的余数都试一遍，找出最大符合的
            ans = i;
            break;
        }
    }
    return ans;
}

// 3、适用于arr的长度相对不大。arr的累加和很大，m也很大。采用分治法
public static int max4(int[] arr, int m) {
    if (arr.length == 1) {
        return arr[0] % m;
    }
    int mid = (arr.length - 1) / 2;
    TreeSet<Integer> sortSet1 = new TreeSet<>();
    //sortSet1装左边子序列累加和%m的余数的所有可能值
    process4(arr, 0, 0, mid, m, sortSet1);
    TreeSet<Integer> sortSet2 = new TreeSet<>();
    //sortSet2装右边子序列累加和%m的余数的所有可能值
    process4(arr, mid + 1, 0, arr.length - 1, m, sortSet2);
    int ans = 0;
    for (Integer leftMod : sortSet1) {
        //左边右边结合求出最大的余数，左右结合的值要<=m
        ans = Math.max(ans, leftMod + sortSet2.floor(m - 1 - leftMod));
    }
    return ans;
}
//讨论从第index号数到end号数之间，子序列累加和%m的余数的所有可能值，之前的累加和是sum
public static void process4(int[] arr, int index, int sum, int end, int m, TreeSet<Integer> sortSet) {
    if (index == end + 1) {
        //都讨论完了
        sortSet.add(sum % m);
    } else {
        //1、不要当前数
        process4(arr, index + 1, sum, end, m, sortSet);
        //2、要当前数
        process4(arr, index + 1, sum + arr[index], end, m, sortSet);
    }
}
```

#### 3）背包放零食

题目：牛牛家里一共有n袋零食, 第i袋零食体积为v[i]，背包容量为w，牛牛想知道在总体积不超过背包容量的情况下,一共有多少种零食放法，体积为0也算一种放法
1 <= n <= 30, 1 <= w <= 2 * 10^9，v[I] (0 <= v[i] <= 10^9）

```java
//1、适用于背包容量w不大时
public static int ways1(int[] arr, int w) {
    // arr[0...]
    return process(arr, 0, w);
}
// 讨论第index号背包一直到最后一个背包，背包还剩rest容量，返回零食放法数
public static int process(int[] arr, int index, int rest) {
    if (rest < 0) { // 没有容量了
        // -1 无方案的意思
        return -1;
    }
    // rest>=0,
    if (index == arr.length) { // 无零食可选
        return 1;
    }
    int next1 = process(arr, index + 1, rest); // 不要
    int next2 = process(arr, index + 1, rest - arr[index]); // 要
    return next1 + (next2 == -1 ? 0 : next2);
}
public static int dp1(int[] arr, int w) {
    int N = arr.length;
    int[][] dp = new int[N + 1][w + 1];
    for (int j = 0; j <= w; j++) {
        dp[N][j] = 1;
    }
    for (int i = N - 1; i >= 0; i--) {
        for (int j = 0; j <= w; j++) {
            dp[i][j] = dp[i + 1][j] + ((j - arr[i] >= 0) ? dp[i + 1][j - arr[i]] : 0);
        }
    }
    return dp[0][w];
}
//2、适用于第i袋零食体积为v[i]不大时
public static int dp2(int[] arr, int w) {
    int N = arr.length;
    //dp[i][j]代表第0~i-1号背包经过选择后，总体积为j的零食放法数
    int[][] dp = new int[N][w + 1];
    for (int i = 0; i < N; i++) {
        dp[i][0] = 1;
    }
    if (arr[0] <= w) {
        dp[0][arr[0]] = 1;
    }
    for (int i = 1; i < N; i++) {
        for (int j = 1; j <= w; j++) {
            dp[i][j] = dp[i - 1][j] + ((j - arr[i]) >= 0 ? dp[i - 1][j - arr[i]] : 0);
        }
    }
    int ans = 0;
    for (int j = 0; j <= w; j++) {
        ans += dp[N - 1][j];
    }
    return ans;
}
//3、适用于arr数组长度不大时。分治法，此题只能用这个方法时间才能过
public static long ways3(int[] arr, int bag) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    if (arr.length == 1) {
        return arr[0] <= bag ? 2 : 1;
    }
    int mid = (arr.length - 1) >> 1;
    TreeMap<Long, Long> lmap = new TreeMap<>();
    long ways = process(arr, 0, 0, mid, bag, lmap);
    TreeMap<Long, Long> rmap = new TreeMap<>();
    ways += process(arr, mid + 1, 0, arr.length - 1, bag, rmap);
    TreeMap<Long, Long> rpre = new TreeMap<>();
    long pre = 0;
    for (Entry<Long, Long> entry : rmap.entrySet()) {
        pre += entry.getValue();
        rpre.put(entry.getKey(), pre);
    }
    for (Entry<Long, Long> entry : lmap.entrySet()) {
        long lweight = entry.getKey();
        long lways = entry.getValue();
        Long floor = rpre.floorKey(bag - lweight);
        if (floor != null) {
            long rways = rpre.get(floor);
            ways += lways * rways;
        }
    }
    return ways + 1;
}
public static long process(int[] arr, int index, long sum, int end, int bag, TreeMap<Long, Long> map) {
    if (sum > bag) {
        return 0;
    }
    // sum <= bag
    if (index > end) {
        // 所有商品自由选择完了！
        if (sum != 0) {
            if (!map.containsKey(sum)) {
                map.put(sum, 1L);
            } else {
                map.put(sum, map.get(sum) + 1);
            }
            return 1;
        } else {
            return 0;
        }
    } else {
        // sum <= bag 并且 index <= end(还有货)
        // 1) 不要当前index位置的货
        long ways = process(arr, index + 1, sum, end, bag, map);
        // 2) 要当前index位置的货
        ways += process(arr, index + 1, sum + arr[index], end, bag, map);
        return ways;
    }
}
```

### 37、class37--子数组达到规定累加和的最大长度系列问题、矩阵处理技巧题

子数组问题解法一般是把流程定义成每个位置结尾(或开头)的情况下答案是什么，这样所有情况就全部讨论了，然后选择最后答案

#### 1）子数组题目一

题目：给定一个正整数组成的无序数组arr，给定一个正整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度

```java
public static int getMaxLength(int[] arr, int K) {
    if (arr == null || arr.length == 0 || K <= 0) {
        return 0;
    }
    //因为数组是非负，累加和具有单调性，所以利用滑动窗口解决
    int left = 0;
    int right = 0;
    int sum = arr[0];
    int len = 0;
    while (right < arr.length) {
        if (sum == K) {
            len = Math.max(len, right - left + 1);
            sum -= arr[left++];  //L++
        } else if (sum < K) {
            right++;  //R++
            if (right == arr.length) {
                //L到以后的任何子数组累加和都不会是K了
                break;
            }
            sum += arr[right];
        } else {    //sum > K
            sum -= arr[left++]; //L++
        }
    }
    return len;
}
```

#### 2）子数组题目二

题目：给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K，找到arr的所有子数组里，哪个子数组的累加和等于K，并且是长度最大的，返回其长度

```java
public static int maxLength(int[] arr, int k) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    // key: 前缀和
    // value :key这个前缀和最早出现在value位置，即0~value上的前缀和是最早的
    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
    map.put(0, -1); // 防止以0开头合适的那些答案被错过，很重要！
    int len = 0;
    int sum = 0;
    for (int i = 0; i < arr.length; i++) {  //以数组每个元素结尾的所有情况全部求出
        sum += arr[i];
        if (map.containsKey(sum - k)) {
            //表中有sum-k这个累加和，就能知道往前推多远了
            len = Math.max(i - map.get(sum - k), len);
        }
        if (!map.containsKey(sum)) {
            //表中没有这个累加和，就新增。表中有，啥也不做。因为表中存的是累加和的最早位置
            map.put(sum, i);
        }
    }
    return len;
}
```

#### 3）子数组题目三

题目：给定一个整数组成的无序数组arr，值可能正、可能负、可能0，给定一个整数值K，找到arr的所有子数组里，哪个子数组的累加和<=K，并且是长度最大的，返回其长度

```java
public static int maxLengthAwesome(int[] arr, int k) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    //minSums[i]：以arr[i]为开头的最小累加和
    int[] minSums = new int[arr.length];
    //minSumsEnd[i]：以arr[i]为开头的最小累加和的右边界
    int[] minSumEnds = new int[arr.length];
    //1、从右往左填这两个数组
    minSums[arr.length - 1] = arr[arr.length - 1];
    minSumEnds[arr.length - 1] = arr.length - 1;
    for (int i = arr.length - 2; i >= 0; i--) {
        if (minSums[i + 1] < 0) {
            //minSums[i]只依赖minSums[i+1]就可以
            minSums[i] = arr[i] + minSums[i + 1];
            minSumEnds[i] = minSumEnds[i + 1];
        } else {
            minSums[i] = arr[i];
            minSumEnds[i] = i;
        }
    }

    int end = 0;    // end是扩不进来那一块儿的开头位置
    int sum = 0;    // 窗口累加和
    int ans = 0;    //最终结果，最大长度
    for (int i = 0; i < arr.length; i++) {
        //!!! 2、求每一个位置最远能扩多久，这其中有可能某个位置扩的是错误的，它的真实答案是比这个长度小的，但是不影响结果，因为我们要求最长的
        // 这样就确保整个过程不回退，达到O(n)

        // while循环结束之后：
        // 1) 如果以i开头的情况下，累加和<=k的最长子数组是arr[i..end-1]，看看这个子数组长度能不能更新res；
        // 2) 如果以i开头的情况下，累加和<=k的最长子数组比arr[i..end-1]短，更新还是不更新res都不会影响最终结果；
        while (end < arr.length && sum + minSums[end] <= k) {
            //以arr[i]为开头子数组还可以往右扩
            sum += minSums[end];
            end = minSumEnds[end] + 1;
        }
        //end-i可能不是以arr[i]为开头且累加和<=K的长度，因为end-i可能>K，但是无所谓，
        // 如果这样的话arr[i]为开头且累加和<=K的长度一定比这个短，这就把这种可能给舍弃了不去讨论了，因为放弃这个可能不会耽误最终答案
        ans = Math.max(ans, end - i);

        if (end > i) { // 还有窗口，准备讨论arr[i+1]，把累加和减去
            sum -= arr[i];
        } else { // i == end,  即将 i++, i > end, 此时窗口概念维持不住了，所以end跟着i一起走
            //end能等于i说明，arr[i]这个数始终没法进入窗口里，即arr[i]为开头的所有累加和都>K，
            // 准备讨论下一个位置，i和end一块跳到下一个位置，检验arr[i+1]
            end = i + 1;
        }
    }
    return ans;
}
```

#### 4）子数组题目四

题目：给定一个数组arr，给定一个值v，求子数组平均值小于等于v的最长子数组长度

```java
public static int ways3(int[] arr, int v) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    //这道题求子数组平均值<=v，把每个数组的每个数都减v，
    //原问题就改成求子数组平均值<=0，即求子数组累加和<=0的最长子数组长度，变成题目三
    for (int i = 0; i < arr.length; i++) {
        arr[i] -= v;
    }
    return maxLengthAwesome(arr, 0);
}

// 找到数组中累加和<=k的最长子数组
public static int maxLengthAwesome(int[] arr, int k) {
    int N = arr.length;
    int[] sums = new int[N];
    int[] ends = new int[N];
    sums[N - 1] = arr[N - 1];
    ends[N - 1] = N - 1;
    for (int i = N - 2; i >= 0; i--) {
        if (sums[i + 1] < 0) {
            sums[i] = arr[i] + sums[i + 1];
            ends[i] = ends[i + 1];
        } else {
            sums[i] = arr[i];
            ends[i] = i;
        }
    }
    int end = 0;
    int sum = 0;
    int res = 0;
    for (int i = 0; i < N; i++) {
        while (end < N && sum + sums[end] <= k) {
            sum += sums[end];
            end = ends[end] + 1;
        }
        res = Math.max(res, end - i);
        if (end > i) {
            sum -= arr[i];
        } else {
            end = i + 1;
        }
    }
    return res;
}
```

#### 5）矩阵题目一

题目：给定一个正方形矩阵matrix，原地调整成顺时针90度转动的样子

```java
public static void rotate(int[][] matrix) {
    //(a,b)左上角位置，(c,d)右下角位置，用这两个点代表一圈
    int a = 0;
    int b = 0;
    int c = matrix.length - 1;
    int d = matrix[0].length - 1;
    while (a < c) {
        //每次调整一圈，从外到内
        rotateEdge(matrix, a++, b++, c--, d--);
    }
}

public static void rotateEdge(int[][] m, int a, int b, int c, int d) {
    int tmp = 0;
    //这一圈分为d-b组，每组要修改4个点
    for (int i = 0; i < d - b; i++) {
        tmp = m[a][b + i];
        m[a][b + i] = m[c - i][b];
        m[c - i][b] = m[c][d - i];
        m[c][d - i] = m[a + i][d];
        m[a + i][d] = tmp;
    }
}

public static void printMatrix(int[][] matrix) {
    for (int i = 0; i != matrix.length; i++) {
        for (int j = 0; j != matrix[0].length; j++) {
            System.out.print(matrix[i][j] + " ");
        }
        System.out.println();
    }
}
```

#### 6）矩阵题目二			

题目：给定一个正方形或者长方形矩阵matrix，实现转圈打印

```java
public static void spiralOrderPrint(int[][] matrix) {
    int tR = 0;
    int tC = 0;
    int dR = matrix.length - 1;
    int dC = matrix[0].length - 1;
    while (tR <= dR && tC <= dC) {
        //每次打印一圈，从外到内
        printEdge(matrix, tR++, tC++, dR--, dC--);
    }
}

public static void printEdge(int[][] m, int tR, int tC, int dR, int dC) {
    if (tR == dR) {
        //长方形矩阵只有一行
        for (int i = tC; i <= dC; i++) {
            System.out.print(m[tR][i] + " ");
        }
    } else if (tC == dC) {
        //长方形矩阵只有一列
        for (int i = tR; i <= dR; i++) {
            System.out.print(m[i][tC] + " ");
        }
    } else {
        //长方形矩阵有多行多列
        int curC = tC;
        int curR = tR;
        while (curC != dC) {
            System.out.print(m[tR][curC] + " ");
            curC++;
        }
        while (curR != dR) {
            System.out.print(m[curR][dC] + " ");
            curR++;
        }
        while (curC != tC) {
            System.out.print(m[dR][curC] + " ");
            curC--;
        }
        while (curR != tR) {
            System.out.print(m[curR][tC] + " ");
            curR--;
        }
    }
}
```

#### 7）矩阵题目三

题目：给定一个正方形或者长方形矩阵matrix，实现zigzag，之字形打印

```java
public static void printMatrixZigZag(int[][] matrix) {
    int tR = 0;
    int tC = 0;
    int dR = 0;
    int dC = 0;
    //(endR,endC)是矩阵最右下角的元素
    int endR = matrix.length - 1;
    int endC = matrix[0].length - 1;
    boolean fromUp = false;
    while (tR != endR + 1) {
        //一条斜线上为一组，每次打印一组
        printLevel(matrix, tR, tC, dR, dC, fromUp);
        //(tR,tC)是每一组的右上角元素
        tR = tC == endC ? tR + 1 : tR;
        tC = tC == endC ? tC : tC + 1;
        //(dR,dC)是每一组的左下角元素
        dC = dR == endR ? dC + 1 : dC;
        dR = dR == endR ? dR : dR + 1;
        //每次打印一组后，反向调换
        fromUp = !fromUp;
    }
    System.out.println();
}
//一条斜线上为一组，每次打印一组
public static void printLevel(int[][] m, int tR, int tC, int dR, int dC, boolean f) {
    //f为true从上往下斜线打印，f为false从下往上斜线打印
    if (f) {
        while (tR != dR + 1) {
            System.out.print(m[tR++][tC--] + " ");
        }
    } else {
        while (dR != tR - 1) {
            System.out.print(m[dR--][dC++] + " ");
        }
    }
}
```

#### 8）矩阵题目四

题目：转圈打印星号*问题

```java
public static void printStar(int N) {
    int leftUp = 0;
    int rightDown = N - 1;
    char[][] m = new char[N][N];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            m[i][j] = ' ';
        }
    }
    while (leftUp <= rightDown) {
        //每次打印两圈，从外到内
        set(m, leftUp, rightDown);
        //进行调整准备打印下一组两圈
        leftUp += 2;
        rightDown -= 2;
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            System.out.print(m[i][j] + " ");
        }
        System.out.println();
    }
}
//每次打印两圈
public static void set(char[][] m, int leftUp, int rightDown) {
    for (int col = leftUp; col <= rightDown; col++) {
        m[leftUp][col] = '*';
    }
    for (int row = leftUp + 1; row <= rightDown; row++) {
        m[row][rightDown] = '*';
    }
    for (int col = rightDown - 1; col > leftUp; col--) {
        m[rightDown][col] = '*';
    }
    for (int row = rightDown - 1; row > leftUp + 1; row--) {
        m[row][leftUp + 1] = '*';
    }
}
```

### 38、class38--状态压缩的动态规划，难

#### 1）我能赢么

题目：在"100 game"这个游戏中，两名玩家轮流选择从1到10的任意整数，累计整数和，先使得累计整数和达到或超过100的玩家，即为胜者。如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？
例如，两个玩家可以轮流从公共整数池中抽取从1到15的整数（不放回），直到累计整数和 >= 100
给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）
你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。

```java
public static boolean canIWin(int choose, int total) {
    if(total == 0){
        //累计和为0，算先手赢
        return true;
    }
    if((choose * (choose+1)) / 2 < total){
        //1~choose所有数加起来都不能到total，算先手输
        return false;
    }
    //dp[status]代表status这种可能时的先手输赢情况
    int[] dp = new int[1 << (choose + 1)];
    return func(choose,0,total,dp);
}
public static boolean func(int choose,int status,int rest,int[] dp){
    if(dp[status] != 0){
        //算完了， dp[status] == 1  true 代表先手赢了。dp[status] == -1  false 代表先手输了
        return dp[status] == 1 ? true : false;
    }
    // dp[status] == 0  func(status) 没算过，去算！
    boolean ans = false;
    if(rest > 0){
        //准备从第一位开始，讨论这次选每个数的先手输赢情况
        for(int i = 1; i <= choose; i++){
            if(((1 << i) & status) == 0){
                //选这个数
                if(!func(choose,(status | (1 << i)),rest-i,dp)){
                    ans = true;
                    break;
                }
            } 
        }
    }
    dp[status] = ans ? 1 : -1;
    return ans;
}
```

#### 2）TSP问题

题目：有N个城市，任何两个城市之间的都有距离，任何一座城市到自己的距离都为0。所有点到点的距离都存在一个N*N的二维数组matrix里，也就是整张图由邻接矩阵表示。现要求一旅行商从k城市出发必须经过每一个城市且只在一个城市逗留一次，最后回到出发的k城。参数给定一个matrix，给定k。返回总距离最短的路的距离

```java
public static int t3(int[][] matrix) {
    int N = matrix.length; // 0...N-1
    //初始化都是1，表示所有城都能去。例：7座城 1111111
    int allCity = (1 << N) - 1;
    //i用位信息来表示还有哪些城市可以去，dp[i][j]表示此时状态为i，开始城市为j准备绕一圈再返回0的距离
    //i共有 1 << N种可能，j共有N个城市N种可能
    int[][] dp = new int[1 << N][N];
    for (int i = 0; i < (1 << N); i++) {
        for (int j = 0; j < N; j++) {
            dp[i][j] = -1;
        }
    }
    //这道题就规定k=start=0，从0出发最终返回0
    return f3(matrix, allCity, 0, dp);
}
//cityStatus代表哪些城市可以去，start代表从哪个城市开始出发，dp是缓存
public static int f3(int[][] matrix, int cityStatus, int start, int[][] dp) {
    if (dp[cityStatus][start] != -1) {
        //缓存里有直接拿
        return dp[cityStatus][start];
    }
    if (cityStatus == (cityStatus & (~cityStatus + 1))) {
        //只剩一座城了，直接回到0这座城市
        dp[cityStatus][start] = matrix[start][0];
    } else {
        //去start这座城市，把start位的1去掉，
        cityStatus &= (~(1 << start));
        int min = Integer.MAX_VALUE;
        // 枚举所有的城市，挑选以start开始的所有可能
        for (int move = 0; move < matrix.length; move++) {
            if ((cityStatus & (1 << move)) != 0) {
                //cityStatus二进制哪一位是1，这座城市就能去，开始去
                int cur = matrix[start][move] + f3(matrix, cityStatus, move, dp);
                min = Math.min(min, cur);
            }
        }
        //还原现场，把start位的1再加上
        cityStatus |= (1 << start);
        //这样就获得了这个状态下从start出发的最小距离
        dp[cityStatus][start] = min;
    }
    return dp[cityStatus][start];
}
```

#### 3）铺砖问题，很难

题目：铺砖问题（最优解其实是轮廓线dp，但是这个解法对大厂刷题来说比较难，掌握课上的解法即可）
你有无限的1*2的砖块，要铺满M*N的区域，不同的铺法有多少种?

```java
// Min(N,M) 不超过 32
public static int ways3(int N, int M) {
    if (N < 1 || M < 1 || ((N * M) & 1) != 0) {
        return 0;
    }
    if (N == 1 || M == 1) {
        return 1;
    }
    int max = Math.max(N, M);   //max作为行数
    int min = Math.min(N, M);   //min作为列数
    int pre = (1 << min) - 1;   //pre用二进制形式表示上一行的状态，有min位
    //dp[i][j]代表上一层的状态为i，当前讨论该层的j行
    int[][] dp = new int[1 << min][max + 1];
    for (int i = 0; i < dp.length; i++) {
        for (int j = 0; j < dp[0].length; j++) {
            dp[i][j] = -1;
        }
    }
    return process3(pre, 0, max, min, dp);
}
//pre是上一行的状态，i是当前行，N是总共有多少行，M是总共有多少列，dp是缓存
public static int process3(int pre, int i, int N, int M, int[][] dp) {
    if (dp[pre][i] != -1) {
        //缓存里有直接拿
        return dp[pre][i];
    }
    int ans = 0;
    if (i == N) {
        //所有层都讨论完了，若上层满了，铺法+1，若上层不满，铺法+0
        ans = pre == ((1 << M) - 1) ? 1 : 0;
    } else {
        //讨论第i层，op二进制为0的位置表示 需要去深度优先遍历去讨论怎么放砖。为1的位置就代表不用讨论了，必须竖着放
        int op = ((~pre) & ((1 << M) - 1));
        //从最后一列往第0列开始讨论
        ans = dfs3(op, M - 1, i, N, M, dp);
    }
    dp[pre][i] = ans;
    return ans;

}
//op能表示哪些列可能考虑摆砖，col是当前列，level是当前行
public static int dfs3(int op, int col, int level, int N, int M, int[][] dp) {
    if (col == -1) {
        //这一行的所有列讨论完了，准备讨论下一行
        return process3(op, level + 1, N, M, dp);
    }
    int ans = 0;
    //1、砖竖着放
    ans += dfs3(op, col - 1, level, N, M, dp);
    if (col > 0 && (op & (3 << (col - 1))) == 0) { //3的二进制11左移col-1位
        //2、砖能横着放
        ans += dfs3((op | (3 << (col - 1))), col - 2, level, N, M, dp);
        //注：由于是值传递，op最终不会改变，不用恢复现场
    }
    return ans;
}
```

### 39、class39--动态规划猜法中的外部信息简化，思路难

#### 1）戳气球

题目：有n个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组nums中，现在要求你戳破所有的气球。戳破第i个气球，你可以获得nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。这里的i-1和i+1代表和i相邻的、没有被戳爆的！两个气球的序号，如果i-1或i+1超出了数组的边界，那么就当它是一个数字为1的气球。求所能获得硬币的最大数量

这道题的关键就是这个潜台词：[L-1] 和 [R+1]位置的气球一定没爆。还有要讨论最后打爆某个气球

```java
//1、暴力递归
public static int maxCoins(int[] arr) {
    if (arr == null || arr.length == 0) {
        return 0;
    }
    if (arr.length == 1) {
        return arr[0];
    }
    // [3,2,1,3]
    // [1,3,2,1,3,1]
    int N = arr.length;
    //将原数组的左右边界分别加上1，新数组大小为N+2
    int[] help = new int[N + 2];
    for (int i = 0; i < N; i++) {
        help[i + 1] = arr[i];
    }
    help[0] = 1;
    help[N + 1] = 1;
    //返回打爆1~N位置气球的最大得分，就是原来的0~N-1位置
    return func(help, 1, N);
}

// 由于原数组左右边界都加了1，所以L-1位置，和R+1位置，永远不越界
// 潜台词：[L-1] 和 [R+1]位置的气球一定没爆。这道题的关键就是这个潜台词，还有要讨论最后打爆某个气球
// 返回，arr[L...R]打爆所有气球，最大得分是什么
public static int func(int[] arr, int L, int R) {
    if (L == R) {
        //只剩一个气球了
        return arr[L - 1] * arr[L] * arr[R + 1];
    }
    int ans = 0;
    //1、最后打爆L位置上的气球。先打爆L+1~R，再加上arr[L-1] * arr[L] * arr[R+1]
    int p1 = func(arr, L + 1, R) + arr[L - 1] * arr[L] * arr[R + 1];
    //2、最后打爆R位置上的气球。先打爆L~R-1，再加上arr[L-1] * arr[L] * arr[R+1]
    int p2 = func(arr, L, R - 1) + arr[L - 1] * arr[R] * arr[R + 1];
    ans = Math.max(p1, p2);
    //3、最后打爆i位置上的气球。遍历L+1 ~ R-1
    for (int i = L + 1; i < R; i++) {
        //打爆L~i-1，然后打爆i+1~R，最后加上arr[L-1] * arr[i] * arr[R+1]
        int p3 = func(arr, L, i - 1) + func(arr, i + 1, R) + arr[L - 1] * arr[i] * arr[R + 1];
        ans = Math.max(ans, p3);
    }
    return ans;
}

//2、动态规划
public static int dp(int[] arr) {
    int N = arr.length;
    if (arr == null || N == 0) {
        return 0;
    }
    if (N == 1) {
        return arr[0];
    }
    int[] help = new int[N + 2];
    help[0] = 1;
    help[N + 1] = 1;
    for (int i = 0; i < N; i++) {
        help[i + 1] = arr[i];
    }
    //dp[i][j]表示打爆i~j位置气球的最大得分
    int[][] dp = new int[N + 2][N + 2];
    for (int i = 1; i <= N; i++) {
        //只剩一个气球
        dp[i][i] = help[i - 1] * help[i] * help[i + 1];
    }
    for (int L = N; L >= 1; L--) {
        for (int R = L + 1; R <= N; R++) {  //L<R
            //1、最后打爆L位置上的气球
            int p1 = dp[L + 1][R] + help[L - 1] * help[L] * help[R + 1];
            //2、最后打爆R位置上的气球
            int p2 = dp[L][R - 1] + help[L - 1] * help[R] * help[R + 1];
            dp[L][R] = Math.max(p1, p2);
            //3、最后打爆i位置上的气球
            for (int k = L + 1; k < R; k++) {
                int p3 = dp[L][k - 1] + dp[k + 1][R] + help[L - 1] * help[k] * help[R + 1];
                dp[L][R] = Math.max(dp[L][R], p3);
            }
        }
    }
    //返回打爆1~N位置气球的最大得分，就是原来的0~N-1位置
    return dp[1][N];
}
```

#### 2）移除盒子

题目：给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色，你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止，每一轮你可以移除具有相同颜色的连续k个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分，当你将所有盒子都去掉之后，求你能获得的最大积分和

```java
public static int removeBoxes2(int[] boxes) {
    if (boxes == null || boxes.length == 0) {
        return 0;
    }
    if (boxes.length == 1) {
        return 1;
    }
    int N = boxes.length;
    //傻缓存，dp[i][j][k]代表前面有k个盒子与i上的盒子颜色相同，消除i到j上盒子的最大积分和
    int[][][] dp = new int[N][N][N];
    //前面有0个盒子与0上的盒子颜色相同，消除0到N-1上的盒子
    return process(boxes, 0, N - 1, 0, dp);
}

//前面有K个盒子与L上的盒子颜色相同，消除L到R上的盒子，返回最大积分和
public static int process(int[] boxes, int L, int R, int K, int[][][] dp) {
    if (L > R) {
        //越界了，积分和为0
        return 0;
    }
    if (dp[L][R][K] > 0) {
        //有缓存就用缓存
        return dp[L][R][K];
    }
    //1、如果L紧后面有好多与L上盒子颜色一样的连续的盒子，前面K个盒子与这些盒子组合，最后要记得剩一个盒子留在数组里
    int last = L;
    while (last + 1 <= R && boxes[last + 1] == boxes[L]) {
        last++;
        //最后last指向最后一个与前面颜色相同的盒子
    }
    //这样前面有pre个相同颜色的盒子
    int pre = last - L + K;
    //2、前面pre个盒子与last上的盒子先一块消除，再消除剩下的
    int p1 = (pre + 1) * (pre + 1) + process(boxes, last + 1, R, 0, dp);
    int ans = p1;
    //3、前面pre个盒子与last上的盒子组合，然后找到下一组与last上盒子颜色一样的连续的盒子的第一个位置
    //要从last+2开始找，因为last+1肯定颜色不与last一样
    for (int i = last + 2; i <= R; i++) {
        if (boxes[i] == boxes[last] && boxes[i - 1] != boxes[last]) {
            //找到下一组与last上盒子颜色一样的连续的盒子的第一个位置
            //4、先消除中间的，然后再消除i到R，前面有pre+1(算上last)和盒子和i上的盒子颜色一样
            int p2 = process(boxes, last + 1, i - 1, 0, dp) + process(boxes, i, R, pre + 1, dp);
            ans = Math.max(ans, p2);
        }
    }
    dp[L][R][K] = ans;
    return ans;
}
```

#### 3）消除字母

题目：如果一个字符相邻的位置没有相同字符，那么这个位置的字符出现不能被消掉。比如:"ab"，其中a和b都不能被消掉。如果一个字符相邻的位置有相同字符，就可以一起消掉。比如:"abbbc"，中间一串的b是可以被消掉的，消除之后剩下"ac"。某些字符如果消掉了，剩下的字符认为重新靠在一起。
给定一个字符串，你可以决定每一步消除的顺序，目标是请尽可能多的消掉字符，返回最少的剩余字符数量
比如："aacca", 如果先消掉最左侧的"aa"，那么将剩下"cca"，然后把"cc"消掉，剩下的"a"将无法再消除，返回1
但是如果先消掉中间的"cc"，那么将剩下"aaa"，最后都消掉就一个字符也不剩了，返回0，这才是最优解。
再比如："baaccabb"，如果先消除最左侧的两个a，剩下"bccabb"，如果再消除最左侧的两个c，剩下"babb"，最后消除最右侧的两个b，剩下"ba"无法再消除，返回2
而最优策略是：如果先消除中间的两个c，剩下"baaabb"，如果再消除中间的三个a，剩下"bbb"，最后消除三个b，不留下任何字符，返回0，这才是最优解

```java
public static int restMin3(String s) {
    if (s == null) {
        return 0;
    }
    if (s.length() == 1) {
        return s.length();
    }
    char[] str = s.toCharArray();
    int N = str.length;
    int[][][] dp = new int[N][N][2];
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            for (int k = 0; k < 2; k++) {
                dp[i][j][k] = -1;
            }
        }
    }
    return process(str, 0, N - 1, false, dp);
}

//消除L到R上字符，返回最少的剩余字符数量。has T表示L左边的字符与L的一样，has F表示不一样
public static int process(char[] str, int L, int R, boolean has, int[][][] dp) {
    if (L > R) {
        //越界了，返回0
        return 0;
    }
    int K = has ? 1 : 0;
    if (dp[L][R][K] != -1) {
        return dp[L][R][K];
    }
    int ans = 0;
    if (L == R) {
        //只剩一个字符，L左边的字符与L的一样就都能消了，最少的剩余字符数量为0。不能消的话L~R最少的剩余字符数量为1
        ans = has ? 0 : 1;
    }else {
        int index = L;
        int all = has ? 1 : 0;
        while (index <= R && str[index] == str[L]) {
            //最后all表示有几个与L的一样的字符，算上L自己，故all一定 >= 1
            all++;
            index++;
        }
        // index此时在第一个不是[L]字符的位置。
        //1、L~index自己消除，index~R再消除
        int way1 = (all > 1 ? 0 : 1) + process(str, index, R, false, dp);
        int way2 = Integer.MAX_VALUE;
        for (int split = index; split <= R; split++) {
            if (str[split] == str[L] && str[split] != str[split - 1]) {
                //找到后面第一个与L相同字符的位置split
                if (process(str, index, split - 1, false, dp) == 0) {
                    //2、如果index~split都能消除，再消除split~R上字符
                    way2 = Math.min(way2, process(str, split, R, all > 0, dp));
                }
            }

        }
        ans = Math.min(way1, way2);
    }
    dp[L][R][K] = ans;
    return dp[L][R][K];
}
```

#### 4）奇怪的打印机

题目：有台奇怪的打印机有以下两个特殊要求：
打印机每次只能打印由同一个字符组成的序列。
每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。
给你一个字符串s，你的任务是计算这个打印机打印它需要的最少打印次数。

```java
//1、暴力递归
public static int strangePrinter1(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    return process1(str, 0, str.length - 1);
}
//刷出L~R上的样子，返回最小打印次数
public static int process1(char[] str, int L, int R) {
    if (L == R) {
        //只有一个字符，打印1次
        return 1;
    }
    //最小打印次数最长是L~R的长度
    int ans = R - L + 1;
    //i表示L~R上字符分成两部分后右部分的第一个字符，遍历所有情况
    for (int i = L + 1; i <= R; i++) {
        //1、打印左部分
        int p1 = process1(str, L, i - 1);
        //2、打印右部分
        int p2 = process1(str, i, R);
        //3、若左部分第一个和右部分第一个相同，这两个字符同时打印，打印数-1
        int p3 = str[L] == str[i] ? -1 : 0;
        ans = Math.min(ans, p1 + p2 + p3);
    }
    return ans;
}

//2、动态规划
public static int strangePrinter(String s) {
    if (s == null || s.length() == 0) {
        return 0;
    }
    char[] str = s.toCharArray();
    int N = str.length;
    //dp[i][j]表示刷出i~j上的样子，返回最小打印次数
    int[][] dp = new int[N][N];
    //只有一个字符，打印1次
    for (int i = 0; i < N; i++) {
        dp[i][i] = 1;
    }
    for (int L = N - 1; L >= 0; L--) {
        for (int R = L + 1; R < N; R++) {
            //最小打印次数最长是L~R的长度
            dp[L][R] = R - L + 1;
            //k表示L~R上字符分成两部分后右部分的第一个字符，遍历所有情况
            for (int k = L + 1; k <= R; k++) {
                //1、打印左部分
                int p1 = dp[L][k - 1];
                //2、打印右部分
                int p2 = dp[k][R];
                //3、若左部分第一个和右部分第一个相同，这两个字符同时打印，打印数-1
                int p3 = str[L] == str[k] ? -1 : 0;
                dp[L][R] = Math.min(dp[L][R], p1 + p2 + p3);
            }
        }
    }
    return dp[0][N - 1];
}
```

### 40、class40--哈夫曼树、最大网络流算法之Dinic算法，了解

#### 1）哈夫曼树的实现

```java
// 根据文章str, 生成词频统计表
public static HashMap<Character, Integer> countMap(String str) {
    HashMap<Character, Integer> ans = new HashMap<>();
    char[] s = str.toCharArray();
    for (char cha : s) {
        if (!ans.containsKey(cha)) {
            ans.put(cha, 1);
        } else {
            ans.put(cha, ans.get(cha) + 1);
        }
    }
    return ans;
}

public static class Node {
    public int count;
    public Node left;
    public Node right;

    public Node(int c) {
        count = c;
    }
}

public static class NodeComp implements Comparator<Node> {

    @Override
    public int compare(Node o1, Node o2) {
        return o1.count - o2.count;
    }

}

// 根据由文章生成词频表countMap，生成哈夫曼编码表
// key : 字符
// value: 该字符编码后的二进制形式
// 比如，频率表 A：60, B:45, C:13 D:69 E:14 F:5 G:3
// A 10
// B 01
// C 0011
// D 11
// E 000
// F 00101
// G 00100
public static HashMap<Character, String> huffmanForm(HashMap<Character, Integer> countMap) {
    HashMap<Character, String> ans = new HashMap<>();
    if (countMap.size() == 1) {
        for (char key : countMap.keySet()) {
            ans.put(key, "0");
        }
        return ans;
    }
    HashMap<Node, Character> nodes = new HashMap<>();
    PriorityQueue<Node> heap = new PriorityQueue<>(new NodeComp());
    for (Entry<Character, Integer> entry : countMap.entrySet()) {
        Node cur = new Node(entry.getValue());
        char cha = entry.getKey();
        nodes.put(cur, cha);
        heap.add(cur);
    }
    while (heap.size() != 1) {
        Node a = heap.poll();
        Node b = heap.poll();
        Node h = new Node(a.count + b.count);
        h.left = a;
        h.right = b;
        heap.add(h);
    }
    Node head = heap.poll();
    fillForm(head, "", nodes, ans);
    return ans;
}

public static void fillForm(Node head, String pre, HashMap<Node, Character> nodes, HashMap<Character, String> ans) {
    if (nodes.containsKey(head)) {
        ans.put(nodes.get(head), pre);
    } else {
        fillForm(head.left, pre + "0", nodes, ans);
        fillForm(head.right, pre + "1", nodes, ans);
    }
}

// 原始字符串str，根据哈夫曼编码表，转译成哈夫曼编码返回
public static String huffmanEncode(String str, HashMap<Character, String> huffmanForm) {
    char[] s = str.toCharArray();
    StringBuilder builder = new StringBuilder();
    for (char cha : s) {
        builder.append(huffmanForm.get(cha));
    }
    return builder.toString();
}

// 原始字符串的哈夫曼编码huffmanEncode，根据哈夫曼编码表，还原成原始字符串
public static String huffmanDecode(String huffmanEncode, HashMap<Character, String> huffmanForm) {
    TrieNode root = createTrie(huffmanForm);
    TrieNode cur = root;
    char[] encode = huffmanEncode.toCharArray();
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < encode.length; i++) {
        int index = encode[i] == '0' ? 0 : 1;
        cur = cur.nexts[index];
        if (cur.nexts[0] == null && cur.nexts[1] == null) {
            builder.append(cur.value);
            cur = root;
        }
    }
    return builder.toString();
}

public static TrieNode createTrie(HashMap<Character, String> huffmanForm) {
    TrieNode root = new TrieNode();
    for (char key : huffmanForm.keySet()) {
        char[] path = huffmanForm.get(key).toCharArray();
        TrieNode cur = root;
        for (int i = 0; i < path.length; i++) {
            int index = path[i] == '0' ? 0 : 1;
            if (cur.nexts[index] == null) {
                cur.nexts[index] = new TrieNode();
            }
            cur = cur.nexts[index];
        }
        cur.value = key;
    }
    return root;
}

public static class TrieNode {
    public char value;
    public TrieNode[] nexts;

    public TrieNode() {
        value = 0;
        nexts = new TrieNode[2];
    }
}
```

#### 2）最大网络流算法之Dinic算法

```java
public static class Edge {
    public int from;
    public int to;
    public int available;

    public Edge(int a, int b, int c) {
        from = a;
        to = b;
        available = c;
    }
}

public static class Dinic {
    private int N;
    private ArrayList<ArrayList<Integer>> nexts;
    private ArrayList<Edge> edges;
    private int[] depth;
    private int[] cur;

    public Dinic(int nums) {
        N = nums + 1;
        nexts = new ArrayList<>();
        for (int i = 0; i <= N; i++) {
            nexts.add(new ArrayList<>());
        }
        edges = new ArrayList<>();
        depth = new int[N];
        cur = new int[N];
    }

    public void addEdge(int u, int v, int r) {
        int m = edges.size();
        edges.add(new Edge(u, v, r));
        nexts.get(u).add(m);
        edges.add(new Edge(v, u, 0));
        nexts.get(v).add(m + 1);
    }

    public int maxFlow(int s, int t) {
        int flow = 0;
        while (bfs(s, t)) {
            Arrays.fill(cur, 0);
            flow += dfs(s, t, Integer.MAX_VALUE);
            Arrays.fill(depth, 0);
        }
        return flow;
    }

    private boolean bfs(int s, int t) {
        LinkedList<Integer> queue = new LinkedList<>();
        queue.addFirst(s);
        boolean[] visited = new boolean[N];
        visited[s] = true;
        while (!queue.isEmpty()) {
            int u = queue.pollLast();
            for (int i = 0; i < nexts.get(u).size(); i++) {
                Edge e = edges.get(nexts.get(u).get(i));
                int v = e.to;
                if (!visited[v] && e.available > 0) {
                    visited[v] = true;
                    depth[v] = depth[u] + 1;
                    if (v == t) {
                        break;
                    }
                    queue.addFirst(v);
                }
            }
        }
        return visited[t];
    }

    // 当前来到了s点，s可变
    // 最终目标是t，t固定参数
    // r，收到的任务
    // 收集到的流，作为结果返回，ans <= r
    private int dfs(int s, int t, int r) {
        if (s == t || r == 0) {
            return r;
        }
        int f = 0;
        int flow = 0;
        // s点从哪条边开始试 -> cur[s]
        for (; cur[s] < nexts.get(s).size(); cur[s]++) {
            int ei = nexts.get(s).get(cur[s]);
            Edge e = edges.get(ei);
            Edge o = edges.get(ei ^ 1);
            if (depth[e.to] == depth[s] + 1 && (f = dfs(e.to, t, Math.min(e.available, r))) != 0) {
                e.available -= f;
                o.available += f;
                flow += f;
                r -= f;
                if (r <= 0) {
                    break;
                }
            }
        }
        return flow;
    }
}
```

## 二、刷题

### 1、class01

#### 1）题目一，滑动窗口

题目：给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点？即使绳子边缘处盖住点也算盖住

```java
public static int maxPoint2(int[] arr, int K) {
    int L = 0;
    int R = 0;
    int ans = 0;
    int N = arr.length;
    while (L < N) {
        while (R < N && arr[R] - arr[L] <= K) {
            R++;
        }
        ans = Math.max(ans, R - L);
        L++;
    }
    return ans;
}
```

#### 2）题目二，BFS(也可以用DFS)

题目：给定一个文件目录的路径，写一个函数统计这个目录下所有的文件数量并返回，隐藏文件也算，但是文件夹不算

```java
// 注意这个函数也会统计隐藏文件
public static int getFileNumber1(String folderPath) {
    File root = new File(folderPath);
    if (!root.isDirectory() && !root.isFile()) {
        return 0;
    }
    if (root.isFile()) {
        return 1;
    }
    Queue<File> queue = new LinkedList<>();
    queue.add(root);
    int files = 0;
    while(!queue.isEmpty()){
        File folder = queue.poll();
        for (File next : folder.listFiles()) {
            if(next.isDirectory()){
                queue.add(next);
            }
            if(next.isFile()){
                files++;
            }
        }
    }
    return files;
}
```

#### 3）题目三，位运算

题目：给定一个非负整数num，如何不用循环语句，返回>=num，并且离num最近的，2的某次方

```java
//n是非负的
public static int tableSizeFor(int n) {
    if (n == 0) {
        return 1;
    }
    //将n这个数的二进制形式将左边第一个1一直往右推成所有都是1
    //若n正好是2的倍数，为了方便起见，n--。不是2的倍数也不会影响
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;  //int类型32位，故移动这些以后就可以保证第一个1往右都是1了
    return n + 1;
}
```

#### 4）题目四，两个变量遍历

题目：一个数组中只有两种字符'G'和'B'，可以让所有的G都放在左侧，所有的B都放在右侧，或者可以让所有的G都放在右侧，所有的B都放在左侧，但是只能在相邻字符之间进行交换操作，返回至少需要交换几次

```java
public static int minSteps1(String s) {
    if (s == null || s.equals("")) {
        return 0;
    }
    char[] str = s.toCharArray();
    //G在左侧
    int step1 = 0;
    int gi = 0;
    for(int i = 0; i < str.length; i++){
        if(str[i] == 'G'){
            step1 += i - gi;
            gi++;
        }
    }
    //B在左侧
    int step2 = 0;
    int bi = 0;
    for(int i = 0; i < str.length; i++){
        if(str[i] == 'B'){
            step2 += i - bi;
            bi++;
        }
    }
    //取较小的
    return Math.min(step1,step2);
}
```

#### 5）矩阵中的最长递增路径，dp

题目：给定一个二维数组matrix，你可以从任何位置出发，走向上、下、左、右四个方向，返回能走出来的最长的递增链长度

```java
public int longestIncreasingPath(int[][] m) {
    int M = m.length;
    int N = m[0].length;
    int ans = 0;
    //傻缓存,每个点的dp值最小是1
    int[][] dp = new int[M][N];
    //求每一个位置的最长递增路径
    for(int i = 0; i < M; i++){
        for(int j = 0; j < N; j++){
            ans = Math.max(ans,process(m,i,j,dp));
        }
    }
    return ans;
}
//求m[i][j]的最长递增路径
public static int process(int[][] m,int i,int j,int[][] dp){
    if(dp[i][j] != 0){
        return dp[i][j];
    }
    //往上走
    int up = i > 0 && m[i-1][j] > m[i][j] ? process(m,i-1,j,dp) : 0;
    //往下走
    int down = i < m.length - 1 && m[i+1][j] > m[i][j] ? process(m,i+1,j,dp) : 0;
    //往左走
    int left = j > 0 && m[i][j-1] > m[i][j] ? process(m,i,j-1,dp) : 0;
    //往右走
    int right = j < m[0].length -1  && m[i][j+1] > m[i][j] ? process(m,i,j+1,dp) : 0;
    //取四种可能中最长的，注意还要将自己算上
    int ans = Math.max(Math.max(up,down),Math.max(left,right)) + 1;

    dp[i][j] = ans;
    return ans;
}
```

#### 6）题目六，贪心，(线段树能优化，这里就不用了)

题目：给定两个非负数组x和hp，长度都是N，再给定一个正数range。x有序，x[i]表示i号怪兽在x轴上的位置，hp[i]表示i号怪兽的血量。再给定一个正数range，表示如果法师释放技能的范围长度，被打到的每只怪兽损失1点血量。返回要把所有怪兽血量清空，至少需要释放多少次AOE技能？

```java
//贪心，总是用技能的最左边缘刮死当前最左侧的没死的怪物， 然后向右找下一个没死的怪物，重复
public static int minAoe2(int[] x, int[] hp, int range) {
    // 怪兽所在，x数组  : 2 3 5 6 7 9
    // 怪兽血量，hp数组 : 2 4 1 2 3 1
    // 怪兽编号        : 0 1 2 3 4 5
    // 技能直径，range = 2
    //1、先找到以每一个怪兽为开头的不能覆盖的第一个位置
    // 如果技能左边界就在0号怪兽，那么技能到2号怪兽就覆盖不到了,所以cover[0] = 2;
    int N = x.length;
    int[] cover = new int[N];
    int r = 0;
    for(int i = 0; i < N; i++){
        while(r < N && x[r] - x[i] <= range){
            r++;
        }
        cover[i] = r;
    }
    //2、从左边第一个怪兽hp干成0，然后向右找下一个没死的怪物，重复
    int ans = 0;
    for(int i = 0; i < N; i++){
        if(hp[i] > 0){
            int minus = hp[i];
            for(int j = i; j < cover[i]; j++){
                hp[j] -= minus;
            }
            ans += minus;
        }
    }
    return ans;
}
```

#### 7）目标和，dp

题目：给定一个正数数组arr(要是有负数，只需把负数都改成正数，解题方法还是一样)，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target，请问最后算出target的方法数

```java
public int findTargetSumWays(int[] nums, int target) {
    if(nums == null || nums.length == 0){
        return 0;
    }
    return process(nums,0,target,new HashMap<>());
}
//正在讨论第i位上的数，此时还需要rest才达到target   
public static int process(int[] arr,int i,int rest,HashMap<Integer, HashMap<Integer, Integer>> dp){
    if(dp.containsKey(i) && dp.get(i).containsKey(rest)){
        return dp.get(i).get(rest);
    }
    int ans = 0;
    if(i == arr.length){
        //所有数都讨论完了
        ans = rest == 0 ? 1 : 0;
    } else{
        //当前数添加+
        int p1 = process(arr,i+1,rest-arr[i],dp);
        //当前数添加-
        int p2 = process(arr,i+1,rest+arr[i],dp);
        ans = p1 + p2;
    }
    if(!dp.containsKey(i)){
        dp.put(i, new HashMap<>());
    }
    dp.get(i).put(rest,ans);
    return ans;
}
```

### 2、class02

#### 1）题目一，有序表

题目：给定数组hard和money，长度都为N，hard[i]表示i号工作的难度， money[i]表示i号工作的收入。给定数组ability，长度都为M，ability[j]表示j号人的能力，每一号工作，都可以提供无数的岗位，难度和收入都一样，但是人的能力必须>=这份工作的难度，才能上班。返回一个长度为M的数组ans，ans[j]表示j号人能获得的最好收入

```java
public static class Job{
    public int hard;
    public int money;
    public Job(int h,int m){
        hard = h;
        money = m;
    }
}
public static class JobComparator implements Comparator<Job>{
    @Override
    public int compare(Job o1, Job o2) {
        //将工作按难度从小到大排序，难度一样按收入从大到小排序
        return o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money);
    }
}
public static int[] getMoneys(Job[] job, int[] ability) {
    Arrays.sort(job,new JobComparator());
    TreeMap<Integer,Integer> map = new TreeMap<>(); //有序表
    map.put(job[0].hard,job[0].money);
    //pre是指上一份进入map的工作
    Job pre = job[0];
    for(int i = 1; i < job.length; i++){
        if(job[i].hard != pre.hard && job[i].money > pre.money){
            map.put(job[i].hard,job[i].money);
            pre = job[i];
        }
    }

    int M = ability.length;
    int[] ans = new int[M];
    for(int i = 0; i < M; i++){
        //找到难度 <= ability[i] 且离它最近的工作
        Integer key = map.floorKey(ability[i]);
        ans[i] = key != null ? map.get(key) : 0; //注意key可能为空
    }
    return ans;
}
```

#### 2）题目二，难

题目：贩卖机只支持硬币支付，且收退都只支持10 ，50，100三种面额。一次购买只能出一瓶可乐，且投钱和找零都遵循优先使用大钱的原则。需要购买的可乐数量是m，其中手头拥有的10、50、100的数量分别为a、b、c，可乐的价格是x(x是10的倍数)。请计算出需要投入硬币次数

```java
// 要买的可乐数量，m。100元有a张。50元有b张。10元有c张。可乐单价x
public static int putTimes(int m, int a, int b, int c, int x) {
    //              0    1   2
    int[] qian = { 100, 50, 10 };
    int[] zhang = { c,  b,  a };
    // 总共需要多少次投币
    int puts = 0;
    // 之前面值的钱还剩下多少总钱数
    int preQianRest = 0;
    // 之前面值的钱还剩下多少总张数
    int preQianZhang = 0;
    for (int i = 0; i < 3 && m != 0; i++) {
        // 要用之前剩下的钱、当前面值的钱，共同买第一瓶可乐
        // 之前的面值剩下多少钱，是preQianRest
        // 之前的面值剩下多少张，是preQianZhang
        // 之所以之前的面值会剩下来，一定是剩下的钱，一直攒不出一瓶可乐的单价
        // 当前的面值付出一些钱+之前剩下的钱，此时有可能凑出一瓶可乐来
        // 那么当前面值参与搞定第一瓶可乐，需要掏出多少张呢？就是curQianFirstBuyZhang
        int curQianFirstBuyZhang = (x - preQianRest + qian[i] - 1) / qian[i];
        if (zhang[i] >= curQianFirstBuyZhang) { // 如果之前的钱和当前面值的钱，能凑出第一瓶可乐
            // 凑出来了一瓶可乐也可能存在找钱的情况，
            giveRest(qian, zhang, i + 1, (preQianRest + qian[i] * curQianFirstBuyZhang) - x, 1);
            puts += curQianFirstBuyZhang + preQianZhang;
            zhang[i] -= curQianFirstBuyZhang;
            m--;
        } else { // 如果之前的钱和当前面值的钱，不能凑出第一瓶可乐
            preQianRest += qian[i] * zhang[i];
            preQianZhang += zhang[i];
            continue;
        }
        // 凑出第一瓶可乐之后，当前的面值有可能能继续买更多的可乐
        // 以下过程就是后续的可乐怎么用当前面值的钱来买
        // 用当前面值的钱，买一瓶可乐需要几张
        int curQianBuyOneColaZhang = (x + qian[i] - 1) / qian[i];
        // 用当前面值的钱，一共可以搞定几瓶可乐
        int curQianBuyColas = Math.min(zhang[i] / curQianBuyOneColaZhang, m);
        // 用当前面值的钱，每搞定一瓶可乐，收货机会吐出多少零钱
        int oneTimeRest = qian[i] * curQianBuyOneColaZhang - x;
        // 每次买一瓶可乐，吐出的找零总钱数是oneTimeRest
        // 一共买的可乐数是curQianBuyColas，所以把零钱去提升后面几种面值的硬币数，
        // 就是giveRest的含义
        giveRest(qian, zhang, i + 1, oneTimeRest, curQianBuyColas);
        // 当前面值去搞定可乐这件事，一共投了几次币
        puts += curQianBuyOneColaZhang * curQianBuyColas;
        // 还剩下多少瓶可乐需要去搞定，继续用后面的面值搞定去吧
        m -= curQianBuyColas;
        // 当前面值可能剩下若干张，要参与到后续买可乐的过程中去，
        // 所以要更新preQianRest和preQianZhang
        zhang[i] -= curQianBuyOneColaZhang * curQianBuyColas;
        preQianRest = qian[i] * zhang[i];
        preQianZhang = zhang[i];
    }
    return m == 0 ? puts : -1;
}

public static void giveRest(int[] qian, int[] zhang, int i, int oneTimeRest, int times) {
    for (; i < 3; i++) {
        zhang[i] += (oneTimeRest / qian[i]) * times;
        oneTimeRest %= qian[i];
    }
}
```

#### 3）题目三，自己写结构

题目：已知一个消息流会不断地吐出整数1~N，但不一定按照顺序依次吐出，如果上次打印的序号为i， 那么当i+1出现时，请打印i+1及其之后接收过的并且连续的所有数，直到1~N全部接收并打印完，请设计这种接收并打印的结构

```java
public static class Node {
    public String info;
    public Node next;

    public Node(String str) {
        info = str;
    }
}

public static class MessageBox {
    private HashMap<Integer, Node> headMap;     //装头区间的map
    private HashMap<Integer, Node> tailMap;     //装尾区间的map
    private int waitPoint;                      //此时应该被打印的点的编号，初始化为1

    public MessageBox() {
        headMap = new HashMap<Integer, Node>();
        tailMap = new HashMap<Integer, Node>();
        waitPoint = 1;
    }

    // 消息的编号，info消息的内容, 消息一定从1开始
    public void receive(int num, String info) {
        if (num < 1) {
            return;
        }
        Node cur = new Node(info);
        // num~num
        // 建立了num~num这个连续区间的头和尾
        headMap.put(num, cur);
        tailMap.put(num, cur);
        // 查询有没有某个连续区间以num-1结尾。有就链表相连，并更新头表和尾表
        if (tailMap.containsKey(num - 1)) {
            tailMap.get(num - 1).next = cur;
            tailMap.remove(num - 1);
            headMap.remove(num);
        }
        // 查询有没有某个连续区间以num+1开头的。有就链表相连，并更新头表和尾表
        if (headMap.containsKey(num + 1)) {
            cur.next = headMap.get(num + 1);
            tailMap.remove(num);
            headMap.remove(num + 1);
        }
        //如果当前数就是等待要打印的数，打印，否则不打印
        if (num == waitPoint) {
            print();
        }
    }

    private void print() {
        //获取要打印的节点。后面要将头表和尾表相应的节点信息删除
        Node node = headMap.get(waitPoint);
        headMap.remove(waitPoint);
        while (node != null) {
            //打印链表上的内容
            System.out.print(node.info + " ");
            node = node.next;
            waitPoint++;
        }
        tailMap.remove(waitPoint-1);
        System.out.println();
    }
}
```

#### 4）题目四，dp

题目：现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为income[i] [0]，去B可得收入为income[i] [1].返回能使所有司机总收入最高的方案是多少钱?

```java
//1、暴力递归
//A、B两区域的司机数量必须是相等的，故司机数量必须是偶数
public static int maxMoney1(int[][] income) {
    int N = income.length;
    if (income == null || N == 0 || (N & 1) != 0) {
        return 0;
    }
    int M = N / 2; //A,B两区域的司机数量
    return process(income, 0, M);
}
//返回第i~N-1号司机的最高收入，此时A区域还剩rest个位置(只要A确定了，B就确定了，故参数就一个A即可)
public static int process(int[][] arr, int i, int rest) {
    if (i == arr.length) {
        //越界了，所有司机都讨论完了
        return 0;
    }
    //1、剩下的司机必须去A区域
    if (rest == arr.length - i) {
        return arr[i][0] + process(arr, i + 1, rest - 1);
    }
    //2、剩下的司机都必须去B区域
    if (rest == 0) {
        return arr[i][1] + process(arr, i + 1, rest);
    }
    //3、剩下的司机A、B区域都得去
    int p1 = arr[i][0] + process(arr, i + 1, rest - 1);
    int p2 = arr[i][1] + process(arr, i + 1, rest);
    return Math.max(p1, p2);
}

//2、动态规划
public static int maxMoney2(int[][] income) {
    int N = income.length;
    if (income == null || N == 0 || (N & 1) != 0) {
        return 0;
    }
    int M = N / 2; //A,B两区域的司机数量
    //dp[i][j]表示A区域还剩j个位置，此时i~N-1号司机的最高收入
    int[][] dp = new int[N + 1][M + 1];
    //dp[N][..] = 0  越界了，所有司机都讨论完了
    for (int i = N - 1; i >= 0; i--) {
        for (int rest = 0; rest <= M; rest++) {
            if (rest == N - i) {
                //1、剩下的司机都必须去A区域
                dp[i][rest] = income[i][0] + dp[i + 1][rest - 1];
            } else if (rest == 0) {
                //2、剩下的司机都必须去B区域
                dp[i][rest] = income[i][1] + dp[i + 1][rest];
            } else {
                //3、剩下的司机A、B区域都得去
                int p1 = income[i][0] + dp[i + 1][rest - 1];
                int p2 = income[i][1] + dp[i + 1][rest];
                dp[i][rest] = Math.max(p1, p2);
            }

        }
    }
    return dp[0][M];
}
```

#### 5）题目五，自己写结构

题目：设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)

```java
public static class MyValue<V> {
    public V value;
    public long time; //该节点被操作的时间点

    public MyValue(V v, long t) {
        value = v;
        time = t;
    }
}

public static class MyHashMap<K, V> {
    private HashMap<K, MyValue<V>> map;
    private long time;          //此时的时间点
    private MyValue<V> setAll;  //setAll的信息和时间点

    public MyHashMap() {
        map = new HashMap<>();
        time = 0;
        setAll = new MyValue<V>(null, -1);
    }

    public void put(K key, V value) {
        map.put(key, new MyValue<V>(value, time++));
    }

    public void setAll(V value) {
        setAll = new MyValue<V>(value, time++);
    }

    public V get(K key) {
        if (!map.containsKey(key)) {
            return null;
        }
        if (map.get(key).time > setAll.time) {
            //在setAll之后，又进行了其他操作，返回map中的值
            return map.get(key).value;
        } else {
            //最后进行setAll的，返回setAll的值
            return setAll.value;
        }
    }
}
```

#### 6）最短无序连续子数组，变量扣边界

题目：给定一个数组arr，只能对arr中的一个子数组排序，但是想让arr整体都有序，返回满足这一设定的子数组中最短的是多长

```java
public int findUnsortedSubarray(int[] nums) {
    int N = nums.length;
    if(nums == null || N <= 1){
        return 0;
    }
    //1、找到右边界，即最右一个需要排序的数，在往右都不需要排序了
    int leftMax = nums[0];
    int R = -1;
    for(int i = 1; i < N; i++){
        if(nums[i] >= leftMax){
            //只要nums[i] >= leftMax就假设给他划√，并更新leftMax
            leftMax = nums[i];
        }else {
            //只要nums[i] < leftMax就假设给他划×，用R记录该位置
            //最终R记录最右一个需要排序的数
            R = i;
        }
    }
    //2、找到左边界，即最左一个需要排序的数，在往左都不需要排序了
    int rightMin = nums[N-1];
    int L = N;
    for(int i = N-2; i >= 0; i--){
        if(nums[i] <= rightMin){
            //只要nums[i] <= rightMin就假设给他划√，并更新rightMin
            rightMin = nums[i];
        }else {
            //只要nums[i] > rightMinx就假设给他划×，用L记录该位置
            //最终L记录最左一个需要排序的数
            L = i;
        }
    }
    //L~R之间就是最短子数组。若不用排序则返回0
    return Math.max(0,R-L+1);
}
```

